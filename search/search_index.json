{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5","title":"Baes de Dades -- Bases de Dades NoSQL"},{"location":"1__introducci/","text":"1 - Introducci\u00f3 Qu\u00e8 \u00e9s NoSQL? El terme NoSQL ( Not Only SQL ) fa refer\u00e8ncia a bases de dades que no segueixen el model relacional. En alguns casos, poden ser m\u00e9s eficients perqu\u00e8 permeten una estructura de dades m\u00e9s flexible. \u2705 Avantatge: M\u00e9s adaptabilitat en escenaris on la informaci\u00f3 no encaixa b\u00e9 en taules relacionals. \u274c Consideraci\u00f3: NoSQL no sempre \u00e9s la millor opci\u00f3; la seva efic\u00e0cia dep\u00e8n del tipus d'informaci\u00f3 que es vulga gestionar. Tipus de Bases de Dades NoSQL Segons la forma en qu\u00e8 s'emmagatzemen les dades, podem trobar diferents categories: Bases de Dades Orientades a Objectes , per a poder guardar objectes, com per exemple DB4O Bases de Dades Orientades a Documents (o simplement Bases de Dades Documentals), per a guardar documents de determinats tipus: XML, JSON, ... Per exemple eXist que guarda documents XML, o MongoDB que guarda la informaci\u00f3 en un format similar a JSON. O Firebase , una Base de Dades que utilitza tamb\u00e9 el format JSON i que en temps real permet sincronitzar amb el n\u00favol les dades locals. Bases de Dades Clau-Valor , per a guardar informaci\u00f3 de forma molt senzilla, guardant \u00fanicament la clau (el nom de la propietat) i el seu valor Bases de Dades Orientades a Grafs , per a guardar estructures com els grafs, on hi ha una s\u00e8rie de nodes i arestes que comunicarien (relacionarien) els nodes Bases de Dades Orientades a Columna , que t\u00e9 una estructura pareguda a les taules del Model Relacional, per\u00f2 orientat a les columnes (o fam\u00edlies de columnes, de manera que un grup de columnes es guarda en el mateix lloc). Un exemple \u00e9s Cassandra Altres tipus com les Bases de Dades Multivalor , les Bases de Dades Tabulars , ... En aquest tema ens centrarem en: \ud83d\udd39 Bases de Dades Clau-Valor , per la seva senzillesa. \ud83d\udd39 MongoDB , una base de dades documental \u00e0mpliament utilitzada. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"1 - Introducci\u00f3"},{"location":"1__introducci/#1-introduccio","text":"Qu\u00e8 \u00e9s NoSQL? El terme NoSQL ( Not Only SQL ) fa refer\u00e8ncia a bases de dades que no segueixen el model relacional. En alguns casos, poden ser m\u00e9s eficients perqu\u00e8 permeten una estructura de dades m\u00e9s flexible. \u2705 Avantatge: M\u00e9s adaptabilitat en escenaris on la informaci\u00f3 no encaixa b\u00e9 en taules relacionals. \u274c Consideraci\u00f3: NoSQL no sempre \u00e9s la millor opci\u00f3; la seva efic\u00e0cia dep\u00e8n del tipus d'informaci\u00f3 que es vulga gestionar. Tipus de Bases de Dades NoSQL Segons la forma en qu\u00e8 s'emmagatzemen les dades, podem trobar diferents categories: Bases de Dades Orientades a Objectes , per a poder guardar objectes, com per exemple DB4O Bases de Dades Orientades a Documents (o simplement Bases de Dades Documentals), per a guardar documents de determinats tipus: XML, JSON, ... Per exemple eXist que guarda documents XML, o MongoDB que guarda la informaci\u00f3 en un format similar a JSON. O Firebase , una Base de Dades que utilitza tamb\u00e9 el format JSON i que en temps real permet sincronitzar amb el n\u00favol les dades locals. Bases de Dades Clau-Valor , per a guardar informaci\u00f3 de forma molt senzilla, guardant \u00fanicament la clau (el nom de la propietat) i el seu valor Bases de Dades Orientades a Grafs , per a guardar estructures com els grafs, on hi ha una s\u00e8rie de nodes i arestes que comunicarien (relacionarien) els nodes Bases de Dades Orientades a Columna , que t\u00e9 una estructura pareguda a les taules del Model Relacional, per\u00f2 orientat a les columnes (o fam\u00edlies de columnes, de manera que un grup de columnes es guarda en el mateix lloc). Un exemple \u00e9s Cassandra Altres tipus com les Bases de Dades Multivalor , les Bases de Dades Tabulars , ... En aquest tema ens centrarem en: \ud83d\udd39 Bases de Dades Clau-Valor , per la seva senzillesa. \ud83d\udd39 MongoDB , una base de dades documental \u00e0mpliament utilitzada. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"1 - Introducci\u00f3"},{"location":"2__bases_de_dades_clauvalor/","text":"2 - Bases de Dades Clau-Valor Dins dels diferents tipus de Bases de Dades NoSQL , les Bases de Dades Clau-Valor s\u00f3n les m\u00e9s f\u00e0cils de comprendre. Aquest model es basa en parelles clau-valor , on cada clau representa un identificador \u00fanic i el seu valor associat. \ud83d\udd11 Caracter\u00edstica principal: La clau ha de ser \u00fanica , ja que en cas contrari no es podria recuperar correctament la informaci\u00f3. \u2705 Avantatge: No requereix definici\u00f3 de taules ni estructures complexes. Simplement es guarden parelles clau-valor i es recupera la informaci\u00f3 mitjan\u00e7ant la clau corresponent. \ud83d\udd25 Redis: Un exemple de Base de Dades Clau-Valor L'exemple m\u00e9s conegut d'aquest tipus de bases de dades \u00e9s Redis , famosa per la seva pot\u00e8ncia i efici\u00e8ncia . En Redis, les claus sempre s\u00f3n de tipus String , mentre que els valors poden ser de diferents tipus: \ud83d\udccc Tipus de valors en Redis: Cadenes de car\u00e0cters (String) Exemple: nom_1 \u2192 \"Albert\" Mapes (Hashes) (semblants a un registre amb subcamps) Exemple: empleat_1 \u2192 { nom=\"Albert\", departament=\"10\", sou=\"1000.0\" } Llistes (Lists) (conjunts ordenats de valors) Exemple: llista_1 \u2192 [\"Primer\", \"Segon\", \"Tercer\"] Conjunts (Sets) (conjunts desordenats de valors, l'ordre \u00e9s imprevisible) Exemple: colors \u2192 {\"Blau\", \"Verd\", \"Roig\"} Conjunts ordenats (Sorted Sets) (semblants als Sets, per\u00f2 amb ordre definit) Es diferencia de les llistes per la forma en qu\u00e8 Redis gestiona l'ordenaci\u00f3 interna. \u2699\ufe0f Caracter\u00edstiques principals de Redis \ud83d\udd39 Arquitectura Client-Servidor Redis segueix un model client-servidor , on m\u00faltiples clients poden connectar-se a un servidor Redis per llegir i escriure dades. \ud83d\udd39 Alta efici\u00e8ncia i velocitat Redis \u00e9s extraordin\u00e0riament r\u00e0pid, especialment quan pot carregar tota la base de dades a mem\u00f2ria . - Tot i que prioritza la velocitat en mem\u00f2ria, tamb\u00e9 permet sincronitzaci\u00f3 constant a disc per garantir la persist\u00e8ncia de les dades. \ud83d\udd39 Replicaci\u00f3 Master-Slave per alta disponibilitat - Per suportar alts volums de lectura, Redis permet replicaci\u00f3 ( master/slave ). - Un servidor actua com a master i els altres com a slaves (r\u00e8pliques del master). - Els esclaus poden gestionar consultes de lectura per reduir la c\u00e0rrega sobre el master . 2.1 - Instal\u00b7laci\u00f3 de Redis Redis est\u00e0 constru\u00eft per a Linux. Tamb\u00e9 funciona, per\u00f2, des de Windows com veurem una miqueta m\u00e9s avant. \ud83d\udc27Instal\u00b7laci\u00f3 en Linux El lloc des d'on baixar-lo \u00e9s la p\u00e0gina oficial: https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-from-source/ En el moment de fer aquestos apunts, l'\u00faltima versi\u00f3 estable \u00e9s la 7.4.1 . Per obtenir els fitxers font de la darrera versi\u00f3 estable de Redis des del lloc de desc\u00e0rregues de Redis, executeu: wget https://download.redis.io/redis-stable.tar.gz Compilando Redis Suposarem que el fitxer est\u00e0 col\u00b7locat en el lloc on volem que estiga instal\u00b7lat de forma definitiva. Per compilar Redis, primer extrae el fitxer tar, canvia al directori arrel i despr\u00e9s executa make: tar -xzvf redis-stable.tar.gz cd redis-stable make Amb a\u00e7\u00f2 s'haurien d'haver generat els executables, i ja hauria de funcionar. Executar Servidor i Client Redis Per a posar en marxa el servidor, quasi que el m\u00e9s c\u00f2mode ser\u00e0 obrir un terminal, situar-nos en el directori redis-stable/src i des d'ahi executar redis-server . Hauria d'eixir una finestra similar a la seg\u00fcent, amb m\u00e9s o menys avisos (observeu que al principi de la imatge est\u00e0n les ordres donades per a executar el servidor). Entre altres coses diu que el servidor est\u00e0 en marxa esperant connexions al port 6379, que \u00e9s el port per defecte de Redis. Aquesta finestra del terminal l'haurem de deixar en marxa. Quan vulguem detenir Redis, senzillament fem ctrl-c , i detindrem l'execuci\u00f3 de forma ordenada (guardant-se les dades no guardades) Podr\u00edem haver executat directament redis-server fent-li doble-clic des d'un explorador d'arxius, per exemple, per\u00f2 aleshores no podr\u00edem parar-lo i en definitiva controlar-lo tan c\u00f2modament. Per a fer una connexi\u00f3 des d'un client, tamb\u00e9 des d'un terminal (un altre) executem redis-cli : Ja ha fet la connexi\u00f3, concretament a localhost (127.0.0.1) i al port 6379, que hav\u00edem quedat que \u00e9s el port per defecte. Comprovem que s\u00ed que funciona. Encara no hi ha dades, perqu\u00e8 l'acabem d'instal\u00b7lar. I recordeu que \u00e9s una Base de Dades clau-valor. Per crear una entrada posarem set clau valor . Per a obtenir-la posarem get clau . En la imatge es pot comprovar: Hem creat una clau anomenada clau_1 amb el valor primera , com es pot comprovar en el moment d'obtenir-la amb get . Conexi\u00f3 a un servidor Redis extern Si al programa redis-cli no li posem par\u00e0metres, intentar\u00e0 fer una connexi\u00f3 local (localhost). Si volem connectar a un servidor situat en una altra adre\u00e7a, li la posem amb el par\u00e0metre -h adre\u00e7a , per exemple: redis-cli -h 192.168.1.26 Connexi\u00f3 al servidor de l'Institut En el servidor de dades de l'Institut tamb\u00e9 tenim instal\u00b7lat redis. Per\u00f2 per a no tenir accessos no desitjats, cal una autenticaci\u00f3. Senzillament \u00e9s posar el comando auth amb la contrasenya que ja hem utilitzat en altres ocasions: auth ieselcaminas.ad En la seg\u00fcent imatge es veu com s\u00ed que hem pogut connectar \ud83d\udda5\ufe0fInstal\u00b7laci\u00f3 en Windows Encara que Redis est\u00e0 constru\u00eft per a Linux, hi ha versions per a Windows, preferiblement de 64 bits. El lloc on poder baixar els fitxers de Redis per a Windows de 64 bits \u00e9s: https://github.com/MSOpenTech/redis/releases Redis Insight est\u00e0 disponible per a altres sistemes operatius. Ens baixem el zip, el descomprimim, i ja ho tindrem disponible (sense fer make ni res). Observeu com en la carpeta resultat de descomprimir ja tenim els executables redis-server i redis-cli que s\u00f3n els que ens interessen: Executem redis-server directament i ja el tindrem en marxa: Executem tamb\u00e9 el redis-cli i el resultat ser\u00e0 el mateix que en Linux. 2.2 - Entorn gr\u00e0fic: Redis Insight Com hem comprovat en el punt anterior, la connexi\u00f3 que fem des del client \u00e9s a trav\u00e9s de consola. Per tant haurem de posar comandos i ens contestar\u00e0 la seua execuci\u00f3. Podem instal\u00b7lar-nos una aplicaci\u00f3 gr\u00e0fica que fa\u00e7a un poc m\u00e9s atractiva la presentaci\u00f3. La instal\u00b7laci\u00f3 d'aquesta eina \u00e9s totalment optativa , no cal que la feu. De fet, ens els exemples que es mostraran en tot el tema nom\u00e9s s'utilitzar\u00e0 el mode consola. \u00c9s completament independent del servidor, i podem instal\u00b7lar-la perfectament sense tenir el servidor, utilitzant-la aleshores per a connectar a un servidor remot. El podem baixar lliurement de la p\u00e0gina oficial redis.io/insight on podrem comprovar que tenim per a totes les plataformes: \ud83d\udda5\ufe0fInstal\u00b7laci\u00f3 en Windows de 64 bits En Windows el que ens baixarem \u00e9s un exe. L'executem (permetent l'execuci\u00f3 quan ho pregunta Windows) i li podem donar a totes les opcions per defecte. Quan l'executem, ens eixir\u00e0 la seg\u00fcent pantalla: Podem comprovar que tenim el bot\u00f3 per a afegir una BD Redis (+ Add Redis database). Per a connectar al servidor local la conexi\u00f3 ser\u00e0 redis://default@127.0.0.1:6379 . En la imatge s'ha fet el test de connexi\u00f3. Per a connectar a un remot, posarem la seua adre\u00e7a. En aquesta imatge es veu com hem connectat perfectament als dos servidors. 2.3 - Utilitzaci\u00f3 de Redis Anam a veure la utilitzaci\u00f3 de Redis, Ens connectarem com a clients i intentarem fer operacions. Les primeres seran les m\u00e9s senzilles, utilitzant \u00fanicament el tipus de dades String . Posteriorment mirarem com treballar amb les claus: buscar-ne una, veure si existeix, buscar unes quantes, ... Despr\u00e9s ja anirem a pels tipus de dades m\u00e9s complicats: Hash List Set Sorted Set 2.3.1 - Strings \u00c9s el tipus de dades m\u00e9s senzill, m\u00e9s b\u00e0sic. Ser\u00e0 una cadena de car\u00e0cters de tipus binary safe en la qual normalment guardarem les habituals cadenes de car\u00e0cters, per\u00f2 que tamb\u00e9 podr\u00edem guardar imatges o objectes serialitzats. La grand\u00e0ria m\u00e0xima \u00e9s de 512Mb. Ara veurem els comandos m\u00e9s habituals que afecten a aquest tipus. Com a norma general, hem de ser conscients que els comandos no s\u00f3n sensibles a maj\u00fascules o min\u00fascules, per\u00f2 les claus i els valors s\u00ed que ho s\u00f3n. \u00c9s a dir, el comando get tamb\u00e9 es pot escriure GET o Get . Per\u00f2 la clau Hola \u00e9s diferent de la clau hola . GET Sintaxi get clau Torna el valor de la clau especificada, sempre que siga de tipus String . Si la clau \u00e9s d'un altre tipus, donar\u00e0 error. I si la clau no existeix, tornar\u00e0 el valor especial nil . Exemples 127.0.0.1:6379> get clau_1 \"primera\" 127.0.0.1:6379> get clau_2 (nil) SET Sintaxi set clau valor Assigna a la clau especificada com a primer par\u00e0metre el valor especificat com a segon par\u00e0metre. Si el valor consta de m\u00e9s d'una paraula, haur\u00e0 d'anar entre cometes dobles. Redis sempre guardar\u00e0 el valor com a string, encara que nosaltres pensem que li passem un valor enter o real. I una altra caracter\u00edstica \u00e9s que si la clau existeix ja, matxacar\u00e0 el seu contingut, com era de esperar. Exemples 127.0.0.1:6379> set clau_2 segona OK 127.0.0.1:6379> set text \"Un text amb m\u00e9s d'una paraula\" OK 127.0.0.1:6379> set quatre 4 OK 127.0.0.1:6379> get quatre \"4\" 127.0.0.1:6379> set pi 3.14159265359 OK 127.0.0.1:6379> get pi \"3.14159265359\" Nota Si poseu algun accent, en tornar el valor (fent get) us semblar\u00e0 que no s'ha guardat b\u00e9. S\u00ed que s'haur\u00e0 guardat b\u00e9, el que passa \u00e9s que posteriorment no es visualitza b\u00e9 en fer el get. Es pot comprovar entrant en el client amb l'opci\u00f3 raw , \u00e9s a dir redis-cli --raw El comando SET t\u00e9 una opci\u00f3 molt interessant, que servir\u00e0 per a donar un temps de vida a la clau, transcorregut el qual desapareix la clau (amb el seu valor clar). A\u00e7\u00f2 s'anomena temps d'expiraci\u00f3 i s'aconsegueix amb el par\u00e0metre EX del comando SET seguit del n\u00famero de segons que volem que dure la clau. Exemples 127.0.0.1:6379> set clau_3 tercera ex 10 OK 127.0.0.1:6379> get clau_3 \"tercera\" 127.0.0.1:6379> get clau_3 (nil) Primer s\u00ed que existeix, per\u00f2 al cap de 10 segons ha deixat d'existir. De forma equivalent es pot expressar el temps en milisegons, amb el par\u00e0metre PX en compte de EX . Hav\u00edem comentat al principi, que si en el moment de fer el SET la clau ja existia, es reempla\u00e7ar\u00e0 el seu contingut. Podem modificar aquest comportament amb el par\u00e0metre NX (Not eXists): si no existia la clau, la crear\u00e0 amb el valor, per\u00f2 si ja existia, la deixar\u00e0 com estava. Ens ho indicar\u00e0 dient OK en cas de crear-la i NIL en cas de no crear-la perqu\u00e0 ja existia. 127.0.0.1:6379> set clau_4 quarta nx OK 127.0.0.1:6379> set clau_1 quarta nx (nil) 127.0.0.1:6379> get clau_4 \"quarta\" 127.0.0.1:6379> get clau_1 \"primera\" I de forma inversa, si posem el par\u00e0metre XX , si ja existeix la clau, reempla\u00e7ar\u00e0 el valor, per\u00f2 si no existia, no far\u00e0 res. SETEX Sintaxi setex clau segons valor Funciona igual que el SET amb el par\u00e0metre EX : crear\u00e0 la clau amb el valor, per\u00f2 tindr\u00e0 una exist\u00e8ncia dels segons indicats. PSETEX Sintaxi psetex clau milisegons valor Funciona igual que l'anterior, per\u00f2 el que especifiquem s\u00f3n els milisegons d'exist\u00e8ncia. MGET Sintaxi mget clau1 clau2 clauN Torna una llista de valors, els de les claus indicades. Exemples 127.0.0.1:6379> set mes1 gener OK 127.0.0.1:6379> set mes2 febrer OK 127.0.0.1:6379> set mes3 mar\u00e7 OK 127.0.0.1:6379> mget mes1 mes2 mes3 1) \"gener\" 2) \"febrer\" 3) \"mar\\xc3\\xa7\" Nota Recordeu que els car\u00e0cters com vocals accentuades, \u00e7, \u00f1, ... s'han introdu\u00eft b\u00e9, per\u00f2 potser no es visualiten b\u00e9. Es pot evitar entrant en el client d'aquesta manera redis-cli --raw Si alguna de les claus no exiteix, tornar\u00e0 nil en el seu lloc MSET Sintaxi mset clau1 valor1 clau2 valor2 clauN valorN Assigna els valors corresponents a les claus. \u00c9s una operaci\u00f3 at\u00f2mica: es posen (o canvien) tots els valors a l'hora. 127.0.0.1:6379> mset mes4 abril mes5 maig mes6 juny mes7 juliol OK 127.0.0.1:6379> mget mes1 mes2 mes3 mes4 mes5 mes6 mes7 1) \"gener\" 2) \"febrer\" 3) \"mar\\xc3\\xa7\" 4) \"abril\" 5) \"maig\" 6) \"juny\" 7) \"juliol\" Si no vulgu\u00e9rem reempla\u00e7ar valors, podr\u00edem utilitzar el comando MSETNX , totalment equivalent, per\u00f2 haur\u00edem de tenir en compte que si alguna ja existeix i per tant no pot canviar el valor, no faria l'operaci\u00f3, \u00e9s a dir, tampoc crearia les altres. APPEND Sintaxi append clau1 valor1 Si la clau no existeix la crea assignant-li el valor (com el SET ), per\u00f2 si ja existeix, concatena el valor al final de la cadena que ja hi havia. 127.0.0.1:6379> append salutacio Hola (integer) 4 127.0.0.1:6379> get salutacio \"Hola\" 127.0.0.1:6379> append salutacio \", com va?\" (integer) 13 127.0.0.1:6379> get salutacio \"Hola, com va?\" STRLEN Sintaxi strlen clau1 Torna el n\u00famero de car\u00e0cters que hi ha en el valor de la clau. Si la clau no existeix, tornar\u00e0 0. Si la clau \u00e9s d'un altre tipus, tornar\u00e0 error. 127.0.0.1:6379> strlen salutacio (integer) 13 127.0.0.1:6379> strlen sal (integer) 0 GETRANGE Sintaxi getrange clau1 inici final Extrau una subcadena del valor de la clau (ha de ser de tipus String ) des del n\u00famero de car\u00e0cter d'inici fins al n\u00famero del final (ambd\u00f3s inclosos). El primer car\u00e0cter \u00e9s el 0. Si posem de final un n\u00famero major que l'\u00faltim, igual ho traur\u00e0 fins el final. Es poden posar tamb\u00e9 valor negatius que ens ajuden a agafar la cadena des del final. El -1 \u00e9s l'\u00faltim car\u00e0cter, el -2 el pen\u00faltim, ... I es poden barrejar n\u00fameros positius i negatius. Aix\u00ed el rang 0 -1 \u00e9s tota la cadena. 127.0.0.1:6379> getrange salutacio 1 3 \"ola\" 127.0.0.1:6379> getrange salutacio 6 50 \"com va?\" 127.0.0.1:6379> getrange salutacio 6 -1 \"com va?\" 127.0.0.1:6379> getrange salutacio -7 -5 \"com\" SETRANGE Sintaxi setrange clau1 despla\u00e7ament valor Substitueix part del valor de la cadena, a partir del despla\u00e7ament, amb el vaolr proporcionat. No s'admenten en despla\u00e7ament valors negatius. 127.0.0.1:6379> get salutacio \"Hola, com va?\" 127.0.0.1:6379> setrange salutacio 4 \". C\" (integer) 13 127.0.0.1:6379> get salutacio \"Hola. Com va?\" INCR Sintaxi incr clau1 A pesar de que Redis guarda els strings com a tals, com a cadenes de car\u00e0cters, en algunes ocasions \u00e9s capa\u00e7 de transformar la cadena a un n\u00famero. \u00c9s el cas del comando INCR , que converteix la cadena en un enter (si pot) i incrementa aquest valor en una unitat. Si la clau no existeix la crea assumint que valia 0, i per tant despr\u00e9s valdr\u00e0 1. Si el valor de la clau no era un n\u00famero enter, donar\u00e0 un error. 127.0.0.1:6379> set compt1 20 OK 127.0.0.1:6379> get compt1 \"20\" 127.0.0.1:6379> incr compt1 (integer) 21 127.0.0.1:6379> get compt1 \"21\" 127.0.0.1:6379> incr compt2 (integer) 1 127.0.0.1:6379> get compt2 \"1\" 127.0.0.1:6379> incr clau_1 (error) ERR value is not an integer or out of range 127.0.0.1:6379> set compt3 4.25 OK 127.0.0.1:6379> incr compt3 (error) ERR value is not an integer or out of range DECR Sintaxi decr clau1 Decrementa en una unitat el valor de la clau (senpre que siga un enter). Pot agafar valors negatius. Si la clau no existeix la crea assumint que valia 0, i per tant despr\u00e9s valdr\u00e0 -1. 127.0.0.1:6379> decr compt2 (integer) 0 127.0.0.1:6379> decr compt2 (integer) -1 127.0.0.1:6379> get compt2 \"-1\" INCRBY Sintaxi incrby clau1 increment Incrementa el valor de la clau en el n\u00famero d'unitats indicat en increment (el valor ha de ser enter). L'increment pot ser negatiu. 127.0.0.1:6379> incrby compt1 10 (integer) 31 127.0.0.1:6379> incrby compt1 -20 (integer) 11 DECRBY Sintaxi decrby clau1 decrement Decrementa el valor de la clau el n\u00famero d'unitat indicat en decrement . 127.0.0.1:6379> decrby compt1 5 (integer) 6 2.3.2 - Keys Ara anem a veure comandos que ens permeten treballar amb les claus, per a buscar-les, veure si existeixen, etc. No importar\u00e0 el tipus de les claus (de moment nom\u00e9s hem treballat amb claus de tipus String , per\u00f2 si ja en tingu\u00e9rem dels altres tipus tamb\u00e9 es veurien afectades). En cap cas d'aquestos comandos accedirem al valor de les claus. KEYS Sintaxi keys patr\u00f3 Torna totes les claus que coincideixen amb el patr\u00f3. En el patr\u00f3 podem posar car\u00e0cters comod\u00ed: * : equival a 0 o m\u00e9s car\u00e0cters. Per exemple \"Mar*a\" podria tornar \"Mara\", \"Maria\", \"Marta\", \"Margarita\", ... ? : equival exactament a un car\u00e0cter. Per exemple \"Mar?a\" podria tornar \"Maria\" o \"Marta\", per\u00f2 no \"Mara\", \"Margarita\", ... [ab] : ser\u00e0 cert si en el lloc corresponent hi ha un dels car\u00e0cters especificats entre els claud\u00e0tors. Per exemple \"Mar[it]a\" podria tornar \"Maria\" o \"Marta\", per\u00f2 no \"Marga\" Per a tornar totes les claus utilitzarem **keys *** 127.0.0.1:6379> keys * 1) \"compt3\" 2) \"mes5\" 3) \"mes3\" 4) \"comp3\" 5) \"mes7\" 6) \"mes2\" 1) \"mes6\" 2) \"salutacio\" 3) \"mes4\" 4) \"mes1\" 5) \"clau_1\" 6) \"compt1\" 7) \"compt2\" 127.0.0.1:6379> keys mes? 1) \"mes5\" 2) \"mes3\" 3) \"mes7\" 4) \"mes2\" 5) \"mes6\" 6) \"mes4\" 7) \"mes1\" 127.0.0.1:6379> keys c* 1) \"compt3\" 2) \"comp3\" 3) \"clau_1\" 4) \"compt1\" 5) \"compt2\" 127.0.0.1:6379> keys mes[125] 1) \"mes5\" 2) \"mes2\" 3) \"mes1\" EXISTS Sintaxi exists clau Torna 1 si la clau existeix, i 0 si no existeix. No importa de quin tipus siga la clau. 127.0.0.1:6379> exists clau_1 (integer) 1 127.0.0.1:6379> exists clau_25 (integer) 0 DEL Sintaxi del clau1 clau2 clauN Elimina la clau o claus especificades. Si posem m\u00e9s d'una clau i alguna no existeix, la ignorar\u00e0 i s\u00ed que esborrar\u00e0 les altres. 127.0.0.1:6379> del compt2 (integer) 1 127.0.0.1:6379> del mes6 mes7 mes8 mes9 (integer) 2 Observeu que ens indica quantes claus ha esborrat. En el primer exemple ha esborrat la clau especificada, i en el segon diu que ha esborrat 2, que seran mes6 i mes7 , ja que mes8 i mes9 no existien. TYPE Sintaxi type clau Torna el tipus de la clau especificada. Els valors possibles s\u00f3n: string hash list set zset (conjunt ordenat) Exemples 127.0.0.1:6379> type clau_1 string RENAME Sintaxi rename clau novaclau Canvia el nom de la clau a la clau nova, conservant el valor. D\u00f3na error si la clau antiga no existeix. Si la clau nova ja existia reempla\u00e7ar\u00e0 el seu valor. Exemples 127.0.0.1:6379> get salutacio \"Hola. Com va?\" 127.0.0.1:6379> rename salutacio saludar OK 127.0.0.1:6379> get salutacio (nil) 127.0.0.1:6379> get saludar \"Hola. Com va?\" 127.0.0.1:6379> rename clau_22 clau_23 (error) ERR no such key RENAMENX Sintaxi renamenx clau novaclau Igual que l'anterior per\u00f2 \u00fanicament si la clau nova no existia. Si ja existia no fa res (tornant 0 per a indicar-h0). Exemples 127.0.0.1:6379> renamenx compt1 compt3 (integer) 0 127.0.0.1:6379> get compt1 \"9\" Estem suposant que la clau compt3 ja existeix EXPIRE Sintaxi expire clau segons Assigna com a temps d'expiraci\u00f3 de la clau els segons especificats. Si ja tenia temps d'expiraci\u00f3, el modifica posant-li aquest valor especificat. En cas que a una clau amb temps d'expiraci\u00f3 li canviem el nom amb RENAME , continuar\u00e0 amb temps d'expiraci\u00f3 que li quedava. PEXPIRE Sintaxi pexpire clau milisegons El mateix per\u00f2 en milisegons TTL Sintaxi ttl clau Torna el temps de vida (fins l'expiraci\u00f3) d'una clau. Si la clau no t\u00e9 temps d'expiraci\u00f3, torna -1. Exemples 127.0.0.1:6379> expire compt3 10 (integer) 1 127.0.0.1:6379> ttl compt3 (integer) 6 127.0.0.1:6379> ttl compt3 (integer) 3 127.0.0.1:6379> ttl compt3 (integer) 0 127.0.0.1:6379> get compt3 (nil) PTTL Sintaxi pttl clau Igual que l'anterior, per\u00f2 ens torna el temps en milisegons. PERSIST Sintaxi persist clau Elimina el temps d'expiraci\u00f3 d'una clau, si \u00e9s que en tenia. Ara la clau no expirar\u00e0 mai. Exemples 127.0.0.1:6379> expire compt1 20 (integer) 1 127.0.0.1:6379> ttl compt1 (integer) 12 127.0.0.1:6379> ttl compt1 (integer) 7 127.0.0.1:6379> persist compt1 (integer) 1 127.0.0.1:6379> ttl compt1 (integer) -1 127.0.0.1:6379> get compt1 \"9\" 2.3.3 - Hash Ja hav\u00edem comentat que el tipus Hash \u00e9s una esp\u00e8cie de registre, amb subcamps (en realitat haur\u00edem de dir sub-claus). Pot tenir qualsevol n\u00famero de subcamps que s\u00f3n de tipus String. Redis \u00e9s molt eficient en quant a l'espai que ocupen els Hash , i sobretot en el temps de recuperaci\u00f3 de les dades. Els comandos que vam veure per al String no es poden aplicar al Hash . Tanmateix els comandos del Hash s\u00f3n molt similars a aquells, comen\u00e7ant sempre per H . HSET Sintaxi hset clau camp valor Assigna al camp especificat de la clau especificada el valor especificat. Si el valor consta de m\u00e9s d'una paraula, haur\u00e0 d'anar entre cometes dobles. Si la clau no existia, la crear\u00e0, i si ja existia, senzillament afegir\u00e0 el camp. I si d'aquesta clau ja existia el camp, modificar\u00e0 el seu valor. Evidentment, en claus diferents poden haver camps amb els mateixos noms. Exemples 127.0.0.1:6379> hset empleat_1 nom Andreu (integer) 1 127.0.0.1:6379> hset empleat_1 departament 10 (integer) 1 127.0.0.1:6379> hset empleat_1 sou 1000.0 (integer) 1 127.0.0.1:6379> hset empleat_2 nom Berta (integer) 1 127.0.0.1:6379> hset empleat_2 sou 1500.0 (integer) 1 HGET Sintaxi hget clau camp Torna el valor del camp de la clau. Si no existia (el camp o la clau) torna nil . Nom\u00e9s podem especificar un camp. Exemples 127.0.0.1:6379> hget empleat_1 nom \"Andreu\" 127.0.0.1:6379> hget empleat_1 departament \"10\" 127.0.0.1:6379> hget empleat_2 nom \"Berta\" 127.0.0.1:6379> hget empleat_2 departament (nil) HGETALL Sintaxi hgetall clau Torna una llista amb tots els camps i els seus valors de la clau. La seq\u00fc\u00e8ncia \u00e9s: camp1 valor1 camp2 valor2 ... Per\u00f2 no ens podem fiar que l'ordre siga el mateix ordre que quan el vam definir. Exemples 127.0.0.1:6379> hgetall empleat_1 1) \"nom\" 2) \"Andreu\" 3) \"departament\" 4) \"10\" 5) \"sou\" 6) \"1000.0\" HDEL Sintaxi hdel clau camp1 camp2 campN Elimina el o els camps especificats. Si no existeixen algun d'ells, senzillament l'ignora i si que elimina els altres. Exemples 127.0.0.1:6379> hdel empleat_1 departament (integer) 1 127.0.0.1:6379> hgetall empleat_1 1) \"nom\" 2) \"Andreu\" 3) \"sou\" 4) \"1000.0\" HKEYS Sintaxi hkeys clau Torna una llista amb els camps de la clau. Si la clau no existia, torna una llista buida Exemples 127.0.0.1:6379> hkeys empleat_1 1) \"nom\" 2) \"sou\" HVALS Sintaxi hvals clau Torna una llista amb els valors (\u00fanicament els valors) de tots els camps de la clau. Si la clau no existia, torna una llista buida Exemples 127.0.0.1:6379> hvals empleat_1 1) \"Andreu\" 2) \"1000.0\" Altres Comandos Tamb\u00e9 existeixen altres comandos, de funcionament com cabria esperar (els hem vist tots en el cas de String ): hmget : Torna m\u00e9s d'un camp de la clau hmset : assigna m\u00e9s d'un camp a una clau hexists : indica si existeix el subcamp de la clau hsetnx : assigna \u00fanicament en cas de que no existisca el camp. hincrby : incrementa el camp de la clau 2.3.4 - List Les Llistes en Redis s\u00f3n llistes de Strings ordenades, on cada element est\u00e0 associat a un \u00edndex de la llista. Es poden recuperar els elements tant de forma ordenada (per l'\u00edndex) com accedint directament a una posici\u00f3. Els elements es poden afegir al principi, al final o tamb\u00e9 en una posici\u00f3 determinada. La llista es crea en el moment en qu\u00e8 s'insereix el primer element, i desapareix quan llevem l'\u00faltim element que quede. Estan molt ben optimitzades per a la inserci\u00f3 i per a la consulta. Els comandos que afecten a les llistes comencen quasi tots per L , excepte alguns que comencen per R indicant que fan l'operaci\u00f3 per la dreta. Els valors dels elements es poden repetir. LPUSH Sintaxi lpush clau valor1 valor2 valorN Introdueix els valors a la llista (creant la clau si \u00e9s necessari). Les insereix en la primera posici\u00f3, o tamb\u00e9 podr\u00edem dir que per l'esquerra ( Left PUSH ), imaginant que els elements estan ordenats d'esquerra a dreta. Si posem m\u00e9s d'un valor, s'aniran introduint sempre en la primera posici\u00f3. El comando tornar\u00e0 el n\u00famero d'elements (strings) de la llista despr\u00e9s de la inserci\u00f3. Exemples 127.0.0.1:6379> lpush llista1 primera segona tercera (integer) 3 127.0.0.1:6379> lrange llista1 0 -1 1) \"tercera\" 2) \"segona\" 3) \"primera\" 127.0.0.1:6379> lpush llista1 quarta cinquena (integer) 5 127.0.0.1:6379> lrange llista1 0 -1 1) \"cinquena\" 2) \"quarta\" 3) \"tercera\" 4) \"segona\" 5) \"primera\" Nota Per a veure el contingut de la llista utilitzarem el comando lrange llista 0 -1 , que torna la llista sencera. Veurem de forma m\u00e9s completa aquest comando amb posterioritat. RPUSH Sintaxi rpush clau valor1 valor2 valorN Introdueix els valors a la llista (creant la clau si \u00e9s necessari). Les insereix en l'\u00faltima posici\u00f3, o tamb\u00e9 podr\u00edem dir que per la dreta ( Right PUSH ), imaginant que els elements estan ordenats d'esquerra a dreta. El comando tornar\u00e0 el n\u00famero d'elements (strings) de la llista despr\u00e9s de la inserci\u00f3. Exemples 127.0.0.1:6379> rpush llista1 sisena setena (integer) 7 127.0.0.1:6379> lrange llista1 0 -1 1) \"cinquena\" 2) \"quarta\" 3) \"tercera\" 4) \"segona\" 5) \"primera\" 6) \"sisena\" 7) \"setena\" LPOP Sintaxi lpop clau Torna i elimina el primer element (el de m\u00e9s a l'esquerra). Exemples 127.0.0.1:6379> lpop llista1 \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"segona\" 4) \"primera\" 5) \"sisena\" 6) \"setena\" RPOP Sintaxi rpop clau Torna i elimina l'\u00faltim element (el de m\u00e9s a la dreta). Exemples 127.0.0.1:6379> rpop llista1 \"setena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"segona\" 4) \"primera\" 5) \"sisena\" LSET Sintaxi lset clau index valor Substitueix el valor de la posici\u00f3 indicada per l'\u00edndex. Tant la clau com l'element de la posici\u00f3 indicada han d'existir, sin\u00f3 donar\u00e0 error. Ara la L no significa Left sin\u00f3 List . La primera posici\u00f3 \u00e9s la 0. I tamb\u00e9 es poden posar n\u00fameros negatius: -1 \u00e9s l'\u00faltim, -2 el pen\u00faltim, ... Exemples 127.0.0.1:6379> lset llista1 2 quarta OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"sisena\" 127.0.0.1:6379> lset llista1 -1 cinquena OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" Observeu com es poden repetir els valors LINDEX Sintaxi lindex clau index Torna l'element situat en la posici\u00f3 indicada per l'\u00edndex, per\u00f2 sense eliminar-lo de la llista . Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" 127.0.0.1:6379> lindex llista1 0 \"quarta\" 127.0.0.1:6379> lindex llista1 3 \"primera\" 127.0.0.1:6379> lindex llista1 -1 \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" LINSERT Sintaxi linsert clau BEFORE | AFTER valor1 valor2 Insereix el valor2 abans o despr\u00e9s (segons el que triem) de la primera vegada que troba el valor1. No substitueix, sin\u00f3 que insereix en una determinada posici\u00f3. Els elements que van despr\u00e9s de l'element introdu\u00eft veuran actualitzat el seu \u00edndex. Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" 127.0.0.1:6379> linsert llista1 AFTER quarta segona (integer) 6 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"cinquena\" 127.0.0.1:6379> linsert llista1 BEFORE cinquena sisena (integer) 7 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 Si intentem inserir abans o despr\u00e9s un element que no existeix, tornar\u00e0 -1 indicant que no l'ha trobat i no far\u00e0 la inserci\u00f3. 127.0.0.1:6379> linsert llista1 BEFORE desena setena (integer) -1 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" LRANGE Sintaxi lrange clau inici final Torna els elements de la llista inclosos entre els index inici i final, ambd\u00f3s inclosos. El primer element \u00e9s el 0. Es poden posar valors negatius, sent -1 l'\u00faltim, -2 el pen\u00faltim, ... Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 127.0.0.1:6379> lrange llista1 2 4 1) \"tercera\" 2) \"quarta\" 3) \"primera\" 127.0.0.1:6379> lrange llista1 1 -2 4) \"segona\" 5) \"tercera\" 6) \"quarta\" 7) \"primera\" 8) \"sisena\" 127.0.0.1:6379> lrange llista1 4 4 1) \"primera\" LLEN Sintaxi llen clau Torna el n\u00famero d'elements de la llista Exemples 127.0.0.1:6379> llen llista1 (integer) 7 LREM Sintaxi lrem clau n\u00famero valor Elimina elements de la llista que coincidisquen amb el valor proporcionat. Ja sabem que els valors es poden repetir. Amb el n\u00famero indiquem quants elements volem que s'esborrencomen\u00e7ant per l'esquerra: si posem 1 s'esborrar\u00e0 el primer element amb aquest valor, si posem 2 s'esborraran els dos primers elements (els de m\u00e9s a l'esquerra) que tingen aquest valor. Si posem 0 s'esborraran tots els elements amb aquest valor Exemples 127.0.0.1:6379> rpush llista1 segona (integer) 8 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 8) \"segona\" 127.0.0.1:6379> lrem llista1 1 segona (integer) 1 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"sisena\" 6) \"cinquena\" 7) \"segona\" 127.0.0.1:6379> lrem llista1 0 quarta (integer) 2 127.0.0.1:6379> lrange llista1 0 -1 8) \"tercera\" 9) \"primera\" 10) \"sisena\" 11) \"cinquena\" 12) \"segona\" LTRIM Sintaxi ltrim clau inici final Elimina els elements que queden fora dels \u00edndex inici i final, \u00e9s a dir elimina els que estiguen a l'esquerra d'inici, i els que estiguen a la dreta de final. Exemples 127.0.0.1:6379> ltrim llista1 1 -2 OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"primera\" 2) \"sisena\" 3) \"cinquena\" 2.3.5 - Set Els Sets de Redis s\u00f3n conjunts de valors de tipus String no ordenats. Podrem afegir, actualitzar i esborrar aquestos elements de forma c\u00f2moda i eficient. No es permetran els valors duplicats. A m\u00e9s Redis ens ofereix operacions interessants com la uni\u00f3, intersecci\u00f3 i difer\u00e8ncia de conjunts. Com sempre, els comandos s\u00f3n espec\u00edfics, \u00e9s a dir no ens valen els de Strings, List o Hash. Tots els comandos comencen per S . SADD Sintaxi sadd clau valor1 valor2 valorN Afegeix els valors al conjunt (creant la clau si \u00e9s necessari). Recordem que l'ordre no \u00e9s important, i que no es poden repetir els valors; si intentem introduir un repetit, no donar\u00e0 error, per\u00f2 no l'introduir\u00e0. El comando tornar\u00e0 el n\u00famero d'elements que realment s'han afegit. Exemples 127.0.0.1:6379> sadd colors roig verd blau (integer) 3 127.0.0.1:6379> sadd colors verd groc (integer) 1 SMEMBERS Sintaxi smembers clau Torna tots els valors del conjunt. Si la clau no existeix tornar\u00e0 un conjunt buit. Recordeu que l'ordre dels elements no \u00e9s predecible Exemples 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"verd\" 3) \"roig\" 4) \"blau\" SISMEMBER Sintaxi sismember clau valor Comprova si el valor est\u00e0 en el conjunt, tornant 1 en cas afirmatiu i 0 en cas negatiu. Exemples 127.0.0.1:6379> sismember colors verd (integer) 1 127.0.0.1:6379> sismember colors negre (integer) 0 SCARD Sintaxi sard clau Torna la cardinalitat, \u00e9s a dir, el n\u00famero d'elements del conjunt en l'actualitat. Exemples 127.0.0.1:6379> scard colors (integer) 4 SREM Sintaxi srem clau valor1 valor2 valorN Elimina els valors del conjunt. Si el conjunt es queda buit, eliminar\u00e0 la clau tamb\u00e9. Si algun dels valor no \u00e9s cap element del conjunt, senzillament s'ignorar\u00e0. El comando torna el n\u00famero d'elements realment eliminat. Exemples 127.0.0.1:6379> srem colors verd negre (integer) 1 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"roig\" 3) \"blau\" SPOP Sintaxi spop clau Torna i elimina un valor aleatori del conjunt. Recordeu que a m\u00e9s de tornar- lo, l'elimina del conjunt. Exemples 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"roig\" 3) \"blau\" 127.0.0.1:6379> spop colors \"groc\" 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" SRANDMEMBER Sintaxi srandmember clau Molt paregut a l'anterior. Torna un valor aleatori del conjunt, per\u00f2 en aquesta ocasi\u00f3 no l'elimina del conjunt. Exemples 127.0.0.1:6379> srandmember colors \"blau\" 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" SUNION Sintaxi sunion clau1 clau2 clauN Torna la uni\u00f3 dels elements dels conjunts especificats. \u00c9s una uni\u00f3 correcta, \u00e9s a dir, no es repetir\u00e0 cap valor. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> sadd colors1 verd roig groc (integer) 3 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sunion colors colors1 1) \"verd\" 2) \"groc\" 3) \"roig\" 4) \"blau\" SUNIONSTORE Sintaxi sunionstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la uni\u00f3 en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sunionstore colors2 colors colors1 (integer) 4 127.0.0.1:6379> smembers colors2 1) \"verd\" 2) \"groc\" 3) \"roig\" 4) \"blau\" SDIFF Sintaxi sdiff clau1 clau2 clauN Torna la difer\u00e8ncia dels elements del primer conjunt respecte de la uni\u00f3 de tots els altres. \u00c9s a dir, torna els elements del primer conjunt que no pertanyen acap dels altres. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sdiff colors1 colors 1) \"verd\" 2) \"groc\" SDIFFSTORE Sintaxi sdiffstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la difer\u00e8ncia en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sdiffstore colors3 colors1 colors (integer) 2 127.0.0.1:6379> smembers colors3 1) \"verd\" 2) \"groc\" SINTER Sintaxi sinter clau1 clau2 clauN Torna la intersecci\u00f3 dels elements dels conjunts. \u00c9s a dir, torna els elements que pertanyen a tots els conjunts especificats. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sinter colors colors1 1) \"roig\" SINTERSTORE Sintaxi sinterstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la intersecci\u00f3 en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 3) \"groc\" 4) \"roig\" 5) \"verd\" 127.0.0.1:6379> sinterstore colors4 colors colors1 (integer) 1 127.0.0.1:6379> smembers colors4 6) \"roig\" SMOVE Sintaxi smove clau_font clau_dest\u00ed valor Meneja el valor del conjunt or\u00edgen (el primer conjunt) al conjunt dest\u00ed (el segon). Aix\u00f2 suposar\u00e0 eliminar-lo del primer i afegir-lo al segon. Tornar\u00e0 1 si l'ha menejat, i 0 si no l'ha menejat. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> smove colors1 colors verd (integer) 1 127.0.0.1:6379> smembers colors 1) \"verd\" 2) \"roig\" 3) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 2.3.6 - Set ordenat Els Sets Ordenats ( Sorted Set ) de Redis s\u00f3n Sets que a m\u00e9s de guardar els valors, guarden tamb\u00e9 una puntuaci\u00f3 ( score ) per a cada valor, i Redis mantindr\u00e0 el conjunt ordenat per aquesta puntuaci\u00f3. Els valors no es podran repetir, per\u00f2 s\u00ed les puntuacions. Molts dels comandos seran iguals que els del Set , ja que un conjunt ordenat no deixa de ser un conjunt, per\u00f2 amb la informaci\u00f3 de la puntuaci\u00f3. En aquesta ocasi\u00f3 comen\u00e7aran per Z ZADD Sintaxi zadd clau puntuaci\u00f31 valor1 puntuaci\u00f32 valor2 puntuaci\u00f3N valorN Afegeix els valors al conjunt (creant la clau si \u00e9s necessari) amb les puntuacions corresponents. Les puntuacions seran Strings de valors reals (float). No es poden repetir els valors, per\u00f2 s\u00ed les puntuacions. Si intentem introduir un valor repetit, el que far\u00e0 ser\u00e0 actualitzar la puntuaci\u00f3. El comando tornar\u00e0 el n\u00famero d'elements que realment s'han afegit. Exemples 127.0.0.1:6379> zadd puntuacions 1 Nom1 2 Nom2 5 Nom3 4 Nom4 (integer) 4 127.0.0.1:6379> zrange puntuacions 0 -1 1) \"Nom1\" 2) \"Nom2\" 3) \"Nom4\" 4) \"Nom3\" ZCARD Sintaxi zcard clau Torna la cardinalitat, \u00e9s a dir, el n\u00famero d'elements del conjunt ordenat en l'actualitat. Exemples 127.0.0.1:6379> zcard puntuacions (integer) 4 ZSCORE Sintaxi zscore clau valor Torna la puntuaci\u00f3 (score) del valor especificat del conjunt ordenat. Si no existeix el valor o no existaix la clao, torna nil. Exemples 127.0.0.1:6379> zscore puntuacions Nom3 \"5\" 127.0.0.1:6379> zscore puntuacions Nom7 (nil) ZCOUNT Sintaxi zcount clau min max Torna el n\u00famero de valors que estan entre les puntuacions especificades (ambdues incloses). Exemples 127.0.0.1:6379> zcount puntuacions 2 5 (integer) 3 ZRANGE Sintaxi zrange clau inici final [withscores] Torna els elements del conjunt ordenat inclosos entre els index inici i final, ambd\u00f3s inclosos. I es trauen per ordre ascentent de puntuaci\u00f3. El primer element \u00e9s el 0. Es poden posar valors negatius, sent -1 l'\u00faltim, -2 el pen\u00faltim, ... Opcionalment podem posar WITHSCORES per a que ens torne tamb\u00e9 la puntuaci\u00f3 de cada element Exemples 127.0.0.1:6379> zrange puntuacions 0 -1 1) \"Nom1\" 2) \"Nom2\" 3) \"Nom4\" 4) \"Nom3\" 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom1\" 2) \"1\" 3) \"Nom2\" 4) \"2\" 5) \"Nom4\" 6) \"4\" 7) \"Nom3\" 8) \"5\" Si vulgu\u00e9rem traure el conjunt en ordre invers de puntuaci\u00f3, utilitzar\u00edem el comando ZREVRANGE ( reverse range ). 127.0.0.1:6379> zrevrange puntuacions 0 -1 withscores 1) \"Nom3\" 2) \"5\" 3) \"Nom4\" 4) \"4\" 5) \"Nom2\" 6) \"2\" 7) \"Nom1\" 8) \"1\" ZRANGEBYSCORE Sintaxi zrangebyscore clau min max [withscores] Torna els elements del conjunt ordenat que tenen una puntuaci\u00f3 compresa entre min i max (ambdues incloses). I es trauen per ordre ascentent de puntuaci\u00f3. Opcionalment podem posar WITHSCORES per a que ens torne tamb\u00e9 la puntuaci\u00f3 de cada element. **** Exemples 127.0.0.1:6379> zrangebyscore puntuacions 2 5 1) \"Nom2\" 2) \"Nom4\" 3) \"Nom3\" 127.0.0.1:6379> zrangebyscore puntuacions 2 5 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" 5) \"Nom3\" 6) \"5\" Si vulgu\u00e9rem que les puntuacions foren estrictament majors que la puntiuaci\u00f3 m\u00ednima i/o estrictament menor que la puntuaci\u00f3 m\u00e0xima, posar\u00edem un par\u00e8ntesi davany de min i/o max : 127.0.0.1:6379> zrangebyscore puntuacions 2 (5 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" I si vulgu\u00e9rem traure el conjunt en ordre invers de puntuaci\u00f3, utilitzar\u00edem el comando ZREVRANGEBYSCORE ( reverse range ). Cuideu que com va en ordre invers, ara el valor m\u00e0xim ha de ser el primer, i el m\u00ednim el segon. 127.0.0.1:6379> zrevrangebyscore puntuacions 5 2 withscores 1) \"Nom3\" 2) \"5\" 3) \"Nom4\" 4) \"4\" 5) \"Nom2\" 6) \"2\" ZRANK Sintaxi zrank clau valor Torna el n\u00famero d'ordre de l'element amb el valor especificat. El primer valor \u00e9s el 0. Si no existeix, torna nil . Exemples 127.0.0.1:6379> zrank puntuacions Nom1 (integer) 0 127.0.0.1:6379> zrank puntuacions Nom4 (integer) 2 127.0.0.1:6379> zrank puntuacions Nom7 (nil) Si volem saber el n\u00famero d'ordre per\u00f2 des del final de la llista (en ordre invers), hem d'utilitzar ZREVRANK : 127.0.0.1:6379> zrevrank puntuacions Nom1 (integer) 3 127.0.0.1:6379> zrevrank puntuacions Nom4 (integer) 1 ZREM Sintaxi zrem clau valor1 valor2 valorN Elimina els elements amb els valors especificats. Si algun valor no existeix, senzillament l'ignora. Torna el n\u00famero d'elements realment eliminats. Exemples 127.0.0.1:6379> zrem puntuacions Nom1 (integer) 1 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" 5) \"Nom3\" 6) \"5\" ZREMRANGEBYSCORE Sintaxi zremrangebyscore clau min max Elimina els elements amb puntuaci\u00f3 compresa entre el m\u00ednim i el m\u00e0xim de forma inclusiva.els valors especificats. Si volem fer-ho de forma excusiva (sense incloure les puntuacions dels extrems) posarem un par\u00e8ntesi avant del m\u00ednim i/o el m\u00e0xim. Torna el n\u00famero d'elements realment eliminats. Exemples 127.0.0.1:6379> zremrangebyscore puntuacions (2 4 (integer) 1 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom3\" 4) \"5\" ZINCRBY Sintaxi zincrby clau increment valor Incrementa la puntuaci\u00f3 de l'element especificat. El valor de la puntuaci\u00f3 a incrementar \u00e9s un n\u00famero real. Torna el valor la puntuaci\u00f3 final de l'element. Si l'element no existia, l'inserir\u00e0, assumint una puntuaci\u00f3 inicial de 0. Exemples 127.0.0.1:6379> zincrby puntuacions 1.5 Nom2 \"3.5\" 127.0.0.1:6379> zincrby puntuacions 2.75 Nom5 \"2.75\" 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom5\" 2) \"2.75\" 3) \"Nom2\" 4) \"3.5\" 5) \"Nom3\" 6) \"5\" 2.4 - Resum de comandos (PDF) Al seg\u00fcent enlla\u00e7 disposeu d'un document pdf amb un resum de les comandes de Redis classificades per l'operaci\u00f3 CRUD que realitzen. Resum comandos Redis Exercici 1 Sobre la Base de Dades REDIS del Servidor de l'Institut (adre\u00e7a 89.36.214.106 ) fer les seg\u00fcents operacions, tant per a guardar una s\u00e8rie de dades, com per a recuperar-les. Sempre posarem a les claus el prefix 9999x_ , on com sempre heu de substituir 9999 per les 4 \u00faltimes xifres del vostre DNI, i la x per la letra del NIF. Copia-les en un \u00fanic fitxer de text, de forma numerada. \u00c9s aquest fitxer el que haur\u00e0s de pujar. Crea la clau 9999x_Nom amb el teu nom Crea la clau 9999x_Cognoms amb els teus cognoms. Una de les dues almenys, nom o cognoms, ha de constar de m\u00e9s d'una paraula. Mostra totes les claus teues, i \u00fanicament les teues. D\u00f3na un temps de vida a la clau 9999x_Nom de 200 segons . Comprova el temps de vida que li queda. Posteriorment fes-la permanent . Crea la clau 9999x_Adreca , de tipus Hash, amb els subcamps carrer , numero i cp . No importa que les dades siguen falses. Pots fer-lo en una sent\u00e8ncia o en m\u00e9s d'una. Afegeix a l'anterior el subcamp poblacio Mostra tota la informaci\u00f3 de la teua adre\u00e7a (nom\u00e9s la informaci\u00f3, no les subclaus)**** Crea la clau 9999x_Moduls_ASIX o 9999x_Moduls_DAM o 9999x_Moduls_DAW , depenent del teu cicle. Ha de ser de tipus Set, amb tots els m\u00f2duls del teu cicle, que es detallen a continuaci\u00f3. Pots fer-lo en una o en m\u00e9s d'una sent\u00e8ncia. ASIX : ISO, PAX, FH, GBD, LM, FOL, ASO, SXI, IAW, ASGBD, SAD, EIE, PROJ i FCT DAW : SI, BD, PR, LM, ED, FOL, DWEC, DWES, DAW, DIW, EIE, PROJ i FCT DAM : SI, BD, PR, LM, ED, FOL, AD, PMDM, DI, PSP, SGE, EIE, PROJ i FCT. Crea la clau 9999x_Moduls_meus , de tipus Set, amb tots els m\u00f2duls als quals est\u00e0s matriculat. Pots fer-lo en una o en m\u00e9s d'una sent\u00e8ncia. Guarda en la clau 9999x_Moduls_altres els m\u00f2duls en els quals no est\u00e0s matriculat actualment. Ha de ser per mig d'operacions de conjunts. Pots comprovar que el resultat \u00e9s correcte amb smembers Crea una llista amb el nom 9999x_Notes_BD amb la nota de 4 exercicis de BD. Les notes seran: 7, 9, 6, 10. Han de quedar en aquest ordre (no en ordre invers) Modifica la tercera nota, que passa de ser 6 a 8. Crea un Set Ordenat ( zset ) anomenat 9999x_Carrera amb els seg\u00fcents valors. Pots fer-lo en una o en m\u00e9s d'una sent\u00e8ncia. I ves amb compte perqu\u00e8 els temps han de ser num\u00e8rics Sandra 12'52 Isabel 12'25 Marta 12'10 Maria 12'07 Rosa 11'95 Bea 11'97 Balma 11'90 Anna 12'74 Trau les participants de la carrera ordenades pel temps Penalitza el temps de Bea amb 2 d\u00e8cimes (0'2), i torna a traure les participants ordenades (Bea ha d'haver perdut 2 posicions, passant de tercera a cinquena posici\u00f3) Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"2 - Bases de Dades Clau-Valor (Redis)"},{"location":"2__bases_de_dades_clauvalor/#2-bases-de-dades-clau-valor","text":"Dins dels diferents tipus de Bases de Dades NoSQL , les Bases de Dades Clau-Valor s\u00f3n les m\u00e9s f\u00e0cils de comprendre. Aquest model es basa en parelles clau-valor , on cada clau representa un identificador \u00fanic i el seu valor associat. \ud83d\udd11 Caracter\u00edstica principal: La clau ha de ser \u00fanica , ja que en cas contrari no es podria recuperar correctament la informaci\u00f3. \u2705 Avantatge: No requereix definici\u00f3 de taules ni estructures complexes. Simplement es guarden parelles clau-valor i es recupera la informaci\u00f3 mitjan\u00e7ant la clau corresponent. \ud83d\udd25 Redis: Un exemple de Base de Dades Clau-Valor L'exemple m\u00e9s conegut d'aquest tipus de bases de dades \u00e9s Redis , famosa per la seva pot\u00e8ncia i efici\u00e8ncia . En Redis, les claus sempre s\u00f3n de tipus String , mentre que els valors poden ser de diferents tipus: \ud83d\udccc Tipus de valors en Redis: Cadenes de car\u00e0cters (String) Exemple: nom_1 \u2192 \"Albert\" Mapes (Hashes) (semblants a un registre amb subcamps) Exemple: empleat_1 \u2192 { nom=\"Albert\", departament=\"10\", sou=\"1000.0\" } Llistes (Lists) (conjunts ordenats de valors) Exemple: llista_1 \u2192 [\"Primer\", \"Segon\", \"Tercer\"] Conjunts (Sets) (conjunts desordenats de valors, l'ordre \u00e9s imprevisible) Exemple: colors \u2192 {\"Blau\", \"Verd\", \"Roig\"} Conjunts ordenats (Sorted Sets) (semblants als Sets, per\u00f2 amb ordre definit) Es diferencia de les llistes per la forma en qu\u00e8 Redis gestiona l'ordenaci\u00f3 interna. \u2699\ufe0f Caracter\u00edstiques principals de Redis \ud83d\udd39 Arquitectura Client-Servidor Redis segueix un model client-servidor , on m\u00faltiples clients poden connectar-se a un servidor Redis per llegir i escriure dades. \ud83d\udd39 Alta efici\u00e8ncia i velocitat Redis \u00e9s extraordin\u00e0riament r\u00e0pid, especialment quan pot carregar tota la base de dades a mem\u00f2ria . - Tot i que prioritza la velocitat en mem\u00f2ria, tamb\u00e9 permet sincronitzaci\u00f3 constant a disc per garantir la persist\u00e8ncia de les dades. \ud83d\udd39 Replicaci\u00f3 Master-Slave per alta disponibilitat - Per suportar alts volums de lectura, Redis permet replicaci\u00f3 ( master/slave ). - Un servidor actua com a master i els altres com a slaves (r\u00e8pliques del master). - Els esclaus poden gestionar consultes de lectura per reduir la c\u00e0rrega sobre el master .","title":"2 - Bases de Dades Clau-Valor"},{"location":"2__bases_de_dades_clauvalor/#21-installacio-de-redis","text":"Redis est\u00e0 constru\u00eft per a Linux. Tamb\u00e9 funciona, per\u00f2, des de Windows com veurem una miqueta m\u00e9s avant.","title":"2.1 - Instal\u00b7laci\u00f3 de Redis"},{"location":"2__bases_de_dades_clauvalor/#installacio-en-linux","text":"El lloc des d'on baixar-lo \u00e9s la p\u00e0gina oficial: https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-from-source/ En el moment de fer aquestos apunts, l'\u00faltima versi\u00f3 estable \u00e9s la 7.4.1 . Per obtenir els fitxers font de la darrera versi\u00f3 estable de Redis des del lloc de desc\u00e0rregues de Redis, executeu: wget https://download.redis.io/redis-stable.tar.gz Compilando Redis Suposarem que el fitxer est\u00e0 col\u00b7locat en el lloc on volem que estiga instal\u00b7lat de forma definitiva. Per compilar Redis, primer extrae el fitxer tar, canvia al directori arrel i despr\u00e9s executa make: tar -xzvf redis-stable.tar.gz cd redis-stable make Amb a\u00e7\u00f2 s'haurien d'haver generat els executables, i ja hauria de funcionar. Executar Servidor i Client Redis Per a posar en marxa el servidor, quasi que el m\u00e9s c\u00f2mode ser\u00e0 obrir un terminal, situar-nos en el directori redis-stable/src i des d'ahi executar redis-server . Hauria d'eixir una finestra similar a la seg\u00fcent, amb m\u00e9s o menys avisos (observeu que al principi de la imatge est\u00e0n les ordres donades per a executar el servidor). Entre altres coses diu que el servidor est\u00e0 en marxa esperant connexions al port 6379, que \u00e9s el port per defecte de Redis. Aquesta finestra del terminal l'haurem de deixar en marxa. Quan vulguem detenir Redis, senzillament fem ctrl-c , i detindrem l'execuci\u00f3 de forma ordenada (guardant-se les dades no guardades) Podr\u00edem haver executat directament redis-server fent-li doble-clic des d'un explorador d'arxius, per exemple, per\u00f2 aleshores no podr\u00edem parar-lo i en definitiva controlar-lo tan c\u00f2modament. Per a fer una connexi\u00f3 des d'un client, tamb\u00e9 des d'un terminal (un altre) executem redis-cli : Ja ha fet la connexi\u00f3, concretament a localhost (127.0.0.1) i al port 6379, que hav\u00edem quedat que \u00e9s el port per defecte. Comprovem que s\u00ed que funciona. Encara no hi ha dades, perqu\u00e8 l'acabem d'instal\u00b7lar. I recordeu que \u00e9s una Base de Dades clau-valor. Per crear una entrada posarem set clau valor . Per a obtenir-la posarem get clau . En la imatge es pot comprovar: Hem creat una clau anomenada clau_1 amb el valor primera , com es pot comprovar en el moment d'obtenir-la amb get . Conexi\u00f3 a un servidor Redis extern Si al programa redis-cli no li posem par\u00e0metres, intentar\u00e0 fer una connexi\u00f3 local (localhost). Si volem connectar a un servidor situat en una altra adre\u00e7a, li la posem amb el par\u00e0metre -h adre\u00e7a , per exemple: redis-cli -h 192.168.1.26 Connexi\u00f3 al servidor de l'Institut En el servidor de dades de l'Institut tamb\u00e9 tenim instal\u00b7lat redis. Per\u00f2 per a no tenir accessos no desitjats, cal una autenticaci\u00f3. Senzillament \u00e9s posar el comando auth amb la contrasenya que ja hem utilitzat en altres ocasions: auth ieselcaminas.ad En la seg\u00fcent imatge es veu com s\u00ed que hem pogut connectar","title":"\ud83d\udc27Instal\u00b7laci\u00f3 en Linux"},{"location":"2__bases_de_dades_clauvalor/#installacio-en-windows","text":"Encara que Redis est\u00e0 constru\u00eft per a Linux, hi ha versions per a Windows, preferiblement de 64 bits. El lloc on poder baixar els fitxers de Redis per a Windows de 64 bits \u00e9s: https://github.com/MSOpenTech/redis/releases Redis Insight est\u00e0 disponible per a altres sistemes operatius. Ens baixem el zip, el descomprimim, i ja ho tindrem disponible (sense fer make ni res). Observeu com en la carpeta resultat de descomprimir ja tenim els executables redis-server i redis-cli que s\u00f3n els que ens interessen: Executem redis-server directament i ja el tindrem en marxa: Executem tamb\u00e9 el redis-cli i el resultat ser\u00e0 el mateix que en Linux.","title":"\ud83d\udda5\ufe0fInstal\u00b7laci\u00f3 en Windows"},{"location":"2__bases_de_dades_clauvalor/#22-entorn-grafic-redis-insight","text":"Com hem comprovat en el punt anterior, la connexi\u00f3 que fem des del client \u00e9s a trav\u00e9s de consola. Per tant haurem de posar comandos i ens contestar\u00e0 la seua execuci\u00f3. Podem instal\u00b7lar-nos una aplicaci\u00f3 gr\u00e0fica que fa\u00e7a un poc m\u00e9s atractiva la presentaci\u00f3. La instal\u00b7laci\u00f3 d'aquesta eina \u00e9s totalment optativa , no cal que la feu. De fet, ens els exemples que es mostraran en tot el tema nom\u00e9s s'utilitzar\u00e0 el mode consola. \u00c9s completament independent del servidor, i podem instal\u00b7lar-la perfectament sense tenir el servidor, utilitzant-la aleshores per a connectar a un servidor remot. El podem baixar lliurement de la p\u00e0gina oficial redis.io/insight on podrem comprovar que tenim per a totes les plataformes: \ud83d\udda5\ufe0fInstal\u00b7laci\u00f3 en Windows de 64 bits En Windows el que ens baixarem \u00e9s un exe. L'executem (permetent l'execuci\u00f3 quan ho pregunta Windows) i li podem donar a totes les opcions per defecte. Quan l'executem, ens eixir\u00e0 la seg\u00fcent pantalla: Podem comprovar que tenim el bot\u00f3 per a afegir una BD Redis (+ Add Redis database). Per a connectar al servidor local la conexi\u00f3 ser\u00e0 redis://default@127.0.0.1:6379 . En la imatge s'ha fet el test de connexi\u00f3. Per a connectar a un remot, posarem la seua adre\u00e7a. En aquesta imatge es veu com hem connectat perfectament als dos servidors.","title":"2.2 - Entorn gr\u00e0fic: Redis Insight"},{"location":"2__bases_de_dades_clauvalor/#23-utilitzacio-de-redis","text":"Anam a veure la utilitzaci\u00f3 de Redis, Ens connectarem com a clients i intentarem fer operacions. Les primeres seran les m\u00e9s senzilles, utilitzant \u00fanicament el tipus de dades String . Posteriorment mirarem com treballar amb les claus: buscar-ne una, veure si existeix, buscar unes quantes, ... Despr\u00e9s ja anirem a pels tipus de dades m\u00e9s complicats: Hash List Set Sorted Set","title":"2.3 - Utilitzaci\u00f3 de Redis"},{"location":"2__bases_de_dades_clauvalor/#231-strings","text":"\u00c9s el tipus de dades m\u00e9s senzill, m\u00e9s b\u00e0sic. Ser\u00e0 una cadena de car\u00e0cters de tipus binary safe en la qual normalment guardarem les habituals cadenes de car\u00e0cters, per\u00f2 que tamb\u00e9 podr\u00edem guardar imatges o objectes serialitzats. La grand\u00e0ria m\u00e0xima \u00e9s de 512Mb. Ara veurem els comandos m\u00e9s habituals que afecten a aquest tipus. Com a norma general, hem de ser conscients que els comandos no s\u00f3n sensibles a maj\u00fascules o min\u00fascules, per\u00f2 les claus i els valors s\u00ed que ho s\u00f3n. \u00c9s a dir, el comando get tamb\u00e9 es pot escriure GET o Get . Per\u00f2 la clau Hola \u00e9s diferent de la clau hola .","title":"2.3.1 - Strings"},{"location":"2__bases_de_dades_clauvalor/#get","text":"Sintaxi get clau Torna el valor de la clau especificada, sempre que siga de tipus String . Si la clau \u00e9s d'un altre tipus, donar\u00e0 error. I si la clau no existeix, tornar\u00e0 el valor especial nil . Exemples 127.0.0.1:6379> get clau_1 \"primera\" 127.0.0.1:6379> get clau_2 (nil)","title":"GET"},{"location":"2__bases_de_dades_clauvalor/#set","text":"Sintaxi set clau valor Assigna a la clau especificada com a primer par\u00e0metre el valor especificat com a segon par\u00e0metre. Si el valor consta de m\u00e9s d'una paraula, haur\u00e0 d'anar entre cometes dobles. Redis sempre guardar\u00e0 el valor com a string, encara que nosaltres pensem que li passem un valor enter o real. I una altra caracter\u00edstica \u00e9s que si la clau existeix ja, matxacar\u00e0 el seu contingut, com era de esperar. Exemples 127.0.0.1:6379> set clau_2 segona OK 127.0.0.1:6379> set text \"Un text amb m\u00e9s d'una paraula\" OK 127.0.0.1:6379> set quatre 4 OK 127.0.0.1:6379> get quatre \"4\" 127.0.0.1:6379> set pi 3.14159265359 OK 127.0.0.1:6379> get pi \"3.14159265359\" Nota Si poseu algun accent, en tornar el valor (fent get) us semblar\u00e0 que no s'ha guardat b\u00e9. S\u00ed que s'haur\u00e0 guardat b\u00e9, el que passa \u00e9s que posteriorment no es visualitza b\u00e9 en fer el get. Es pot comprovar entrant en el client amb l'opci\u00f3 raw , \u00e9s a dir redis-cli --raw El comando SET t\u00e9 una opci\u00f3 molt interessant, que servir\u00e0 per a donar un temps de vida a la clau, transcorregut el qual desapareix la clau (amb el seu valor clar). A\u00e7\u00f2 s'anomena temps d'expiraci\u00f3 i s'aconsegueix amb el par\u00e0metre EX del comando SET seguit del n\u00famero de segons que volem que dure la clau. Exemples 127.0.0.1:6379> set clau_3 tercera ex 10 OK 127.0.0.1:6379> get clau_3 \"tercera\" 127.0.0.1:6379> get clau_3 (nil) Primer s\u00ed que existeix, per\u00f2 al cap de 10 segons ha deixat d'existir. De forma equivalent es pot expressar el temps en milisegons, amb el par\u00e0metre PX en compte de EX . Hav\u00edem comentat al principi, que si en el moment de fer el SET la clau ja existia, es reempla\u00e7ar\u00e0 el seu contingut. Podem modificar aquest comportament amb el par\u00e0metre NX (Not eXists): si no existia la clau, la crear\u00e0 amb el valor, per\u00f2 si ja existia, la deixar\u00e0 com estava. Ens ho indicar\u00e0 dient OK en cas de crear-la i NIL en cas de no crear-la perqu\u00e0 ja existia. 127.0.0.1:6379> set clau_4 quarta nx OK 127.0.0.1:6379> set clau_1 quarta nx (nil) 127.0.0.1:6379> get clau_4 \"quarta\" 127.0.0.1:6379> get clau_1 \"primera\" I de forma inversa, si posem el par\u00e0metre XX , si ja existeix la clau, reempla\u00e7ar\u00e0 el valor, per\u00f2 si no existia, no far\u00e0 res.","title":"SET"},{"location":"2__bases_de_dades_clauvalor/#setex","text":"Sintaxi setex clau segons valor Funciona igual que el SET amb el par\u00e0metre EX : crear\u00e0 la clau amb el valor, per\u00f2 tindr\u00e0 una exist\u00e8ncia dels segons indicats.","title":"SETEX"},{"location":"2__bases_de_dades_clauvalor/#psetex","text":"Sintaxi psetex clau milisegons valor Funciona igual que l'anterior, per\u00f2 el que especifiquem s\u00f3n els milisegons d'exist\u00e8ncia.","title":"PSETEX"},{"location":"2__bases_de_dades_clauvalor/#mget","text":"Sintaxi mget clau1 clau2 clauN Torna una llista de valors, els de les claus indicades. Exemples 127.0.0.1:6379> set mes1 gener OK 127.0.0.1:6379> set mes2 febrer OK 127.0.0.1:6379> set mes3 mar\u00e7 OK 127.0.0.1:6379> mget mes1 mes2 mes3 1) \"gener\" 2) \"febrer\" 3) \"mar\\xc3\\xa7\" Nota Recordeu que els car\u00e0cters com vocals accentuades, \u00e7, \u00f1, ... s'han introdu\u00eft b\u00e9, per\u00f2 potser no es visualiten b\u00e9. Es pot evitar entrant en el client d'aquesta manera redis-cli --raw Si alguna de les claus no exiteix, tornar\u00e0 nil en el seu lloc","title":"MGET"},{"location":"2__bases_de_dades_clauvalor/#mset","text":"Sintaxi mset clau1 valor1 clau2 valor2 clauN valorN Assigna els valors corresponents a les claus. \u00c9s una operaci\u00f3 at\u00f2mica: es posen (o canvien) tots els valors a l'hora. 127.0.0.1:6379> mset mes4 abril mes5 maig mes6 juny mes7 juliol OK 127.0.0.1:6379> mget mes1 mes2 mes3 mes4 mes5 mes6 mes7 1) \"gener\" 2) \"febrer\" 3) \"mar\\xc3\\xa7\" 4) \"abril\" 5) \"maig\" 6) \"juny\" 7) \"juliol\" Si no vulgu\u00e9rem reempla\u00e7ar valors, podr\u00edem utilitzar el comando MSETNX , totalment equivalent, per\u00f2 haur\u00edem de tenir en compte que si alguna ja existeix i per tant no pot canviar el valor, no faria l'operaci\u00f3, \u00e9s a dir, tampoc crearia les altres.","title":"MSET"},{"location":"2__bases_de_dades_clauvalor/#append","text":"Sintaxi append clau1 valor1 Si la clau no existeix la crea assignant-li el valor (com el SET ), per\u00f2 si ja existeix, concatena el valor al final de la cadena que ja hi havia. 127.0.0.1:6379> append salutacio Hola (integer) 4 127.0.0.1:6379> get salutacio \"Hola\" 127.0.0.1:6379> append salutacio \", com va?\" (integer) 13 127.0.0.1:6379> get salutacio \"Hola, com va?\"","title":"APPEND"},{"location":"2__bases_de_dades_clauvalor/#strlen","text":"Sintaxi strlen clau1 Torna el n\u00famero de car\u00e0cters que hi ha en el valor de la clau. Si la clau no existeix, tornar\u00e0 0. Si la clau \u00e9s d'un altre tipus, tornar\u00e0 error. 127.0.0.1:6379> strlen salutacio (integer) 13 127.0.0.1:6379> strlen sal (integer) 0","title":"STRLEN"},{"location":"2__bases_de_dades_clauvalor/#getrange","text":"Sintaxi getrange clau1 inici final Extrau una subcadena del valor de la clau (ha de ser de tipus String ) des del n\u00famero de car\u00e0cter d'inici fins al n\u00famero del final (ambd\u00f3s inclosos). El primer car\u00e0cter \u00e9s el 0. Si posem de final un n\u00famero major que l'\u00faltim, igual ho traur\u00e0 fins el final. Es poden posar tamb\u00e9 valor negatius que ens ajuden a agafar la cadena des del final. El -1 \u00e9s l'\u00faltim car\u00e0cter, el -2 el pen\u00faltim, ... I es poden barrejar n\u00fameros positius i negatius. Aix\u00ed el rang 0 -1 \u00e9s tota la cadena. 127.0.0.1:6379> getrange salutacio 1 3 \"ola\" 127.0.0.1:6379> getrange salutacio 6 50 \"com va?\" 127.0.0.1:6379> getrange salutacio 6 -1 \"com va?\" 127.0.0.1:6379> getrange salutacio -7 -5 \"com\"","title":"GETRANGE"},{"location":"2__bases_de_dades_clauvalor/#setrange","text":"Sintaxi setrange clau1 despla\u00e7ament valor Substitueix part del valor de la cadena, a partir del despla\u00e7ament, amb el vaolr proporcionat. No s'admenten en despla\u00e7ament valors negatius. 127.0.0.1:6379> get salutacio \"Hola, com va?\" 127.0.0.1:6379> setrange salutacio 4 \". C\" (integer) 13 127.0.0.1:6379> get salutacio \"Hola. Com va?\"","title":"SETRANGE"},{"location":"2__bases_de_dades_clauvalor/#incr","text":"Sintaxi incr clau1 A pesar de que Redis guarda els strings com a tals, com a cadenes de car\u00e0cters, en algunes ocasions \u00e9s capa\u00e7 de transformar la cadena a un n\u00famero. \u00c9s el cas del comando INCR , que converteix la cadena en un enter (si pot) i incrementa aquest valor en una unitat. Si la clau no existeix la crea assumint que valia 0, i per tant despr\u00e9s valdr\u00e0 1. Si el valor de la clau no era un n\u00famero enter, donar\u00e0 un error. 127.0.0.1:6379> set compt1 20 OK 127.0.0.1:6379> get compt1 \"20\" 127.0.0.1:6379> incr compt1 (integer) 21 127.0.0.1:6379> get compt1 \"21\" 127.0.0.1:6379> incr compt2 (integer) 1 127.0.0.1:6379> get compt2 \"1\" 127.0.0.1:6379> incr clau_1 (error) ERR value is not an integer or out of range 127.0.0.1:6379> set compt3 4.25 OK 127.0.0.1:6379> incr compt3 (error) ERR value is not an integer or out of range","title":"INCR"},{"location":"2__bases_de_dades_clauvalor/#decr","text":"Sintaxi decr clau1 Decrementa en una unitat el valor de la clau (senpre que siga un enter). Pot agafar valors negatius. Si la clau no existeix la crea assumint que valia 0, i per tant despr\u00e9s valdr\u00e0 -1. 127.0.0.1:6379> decr compt2 (integer) 0 127.0.0.1:6379> decr compt2 (integer) -1 127.0.0.1:6379> get compt2 \"-1\"","title":"DECR"},{"location":"2__bases_de_dades_clauvalor/#incrby","text":"Sintaxi incrby clau1 increment Incrementa el valor de la clau en el n\u00famero d'unitats indicat en increment (el valor ha de ser enter). L'increment pot ser negatiu. 127.0.0.1:6379> incrby compt1 10 (integer) 31 127.0.0.1:6379> incrby compt1 -20 (integer) 11","title":"INCRBY"},{"location":"2__bases_de_dades_clauvalor/#decrby","text":"Sintaxi decrby clau1 decrement Decrementa el valor de la clau el n\u00famero d'unitat indicat en decrement . 127.0.0.1:6379> decrby compt1 5 (integer) 6","title":"DECRBY"},{"location":"2__bases_de_dades_clauvalor/#232-keys","text":"Ara anem a veure comandos que ens permeten treballar amb les claus, per a buscar-les, veure si existeixen, etc. No importar\u00e0 el tipus de les claus (de moment nom\u00e9s hem treballat amb claus de tipus String , per\u00f2 si ja en tingu\u00e9rem dels altres tipus tamb\u00e9 es veurien afectades). En cap cas d'aquestos comandos accedirem al valor de les claus.","title":"2.3.2 - Keys"},{"location":"2__bases_de_dades_clauvalor/#keys","text":"Sintaxi keys patr\u00f3 Torna totes les claus que coincideixen amb el patr\u00f3. En el patr\u00f3 podem posar car\u00e0cters comod\u00ed: * : equival a 0 o m\u00e9s car\u00e0cters. Per exemple \"Mar*a\" podria tornar \"Mara\", \"Maria\", \"Marta\", \"Margarita\", ... ? : equival exactament a un car\u00e0cter. Per exemple \"Mar?a\" podria tornar \"Maria\" o \"Marta\", per\u00f2 no \"Mara\", \"Margarita\", ... [ab] : ser\u00e0 cert si en el lloc corresponent hi ha un dels car\u00e0cters especificats entre els claud\u00e0tors. Per exemple \"Mar[it]a\" podria tornar \"Maria\" o \"Marta\", per\u00f2 no \"Marga\" Per a tornar totes les claus utilitzarem **keys *** 127.0.0.1:6379> keys * 1) \"compt3\" 2) \"mes5\" 3) \"mes3\" 4) \"comp3\" 5) \"mes7\" 6) \"mes2\" 1) \"mes6\" 2) \"salutacio\" 3) \"mes4\" 4) \"mes1\" 5) \"clau_1\" 6) \"compt1\" 7) \"compt2\" 127.0.0.1:6379> keys mes? 1) \"mes5\" 2) \"mes3\" 3) \"mes7\" 4) \"mes2\" 5) \"mes6\" 6) \"mes4\" 7) \"mes1\" 127.0.0.1:6379> keys c* 1) \"compt3\" 2) \"comp3\" 3) \"clau_1\" 4) \"compt1\" 5) \"compt2\" 127.0.0.1:6379> keys mes[125] 1) \"mes5\" 2) \"mes2\" 3) \"mes1\"","title":"KEYS"},{"location":"2__bases_de_dades_clauvalor/#exists","text":"Sintaxi exists clau Torna 1 si la clau existeix, i 0 si no existeix. No importa de quin tipus siga la clau. 127.0.0.1:6379> exists clau_1 (integer) 1 127.0.0.1:6379> exists clau_25 (integer) 0","title":"EXISTS"},{"location":"2__bases_de_dades_clauvalor/#del","text":"Sintaxi del clau1 clau2 clauN Elimina la clau o claus especificades. Si posem m\u00e9s d'una clau i alguna no existeix, la ignorar\u00e0 i s\u00ed que esborrar\u00e0 les altres. 127.0.0.1:6379> del compt2 (integer) 1 127.0.0.1:6379> del mes6 mes7 mes8 mes9 (integer) 2 Observeu que ens indica quantes claus ha esborrat. En el primer exemple ha esborrat la clau especificada, i en el segon diu que ha esborrat 2, que seran mes6 i mes7 , ja que mes8 i mes9 no existien.","title":"DEL"},{"location":"2__bases_de_dades_clauvalor/#type","text":"Sintaxi type clau Torna el tipus de la clau especificada. Els valors possibles s\u00f3n: string hash list set zset (conjunt ordenat) Exemples 127.0.0.1:6379> type clau_1 string","title":"TYPE"},{"location":"2__bases_de_dades_clauvalor/#rename","text":"Sintaxi rename clau novaclau Canvia el nom de la clau a la clau nova, conservant el valor. D\u00f3na error si la clau antiga no existeix. Si la clau nova ja existia reempla\u00e7ar\u00e0 el seu valor. Exemples 127.0.0.1:6379> get salutacio \"Hola. Com va?\" 127.0.0.1:6379> rename salutacio saludar OK 127.0.0.1:6379> get salutacio (nil) 127.0.0.1:6379> get saludar \"Hola. Com va?\" 127.0.0.1:6379> rename clau_22 clau_23 (error) ERR no such key","title":"RENAME"},{"location":"2__bases_de_dades_clauvalor/#renamenx","text":"Sintaxi renamenx clau novaclau Igual que l'anterior per\u00f2 \u00fanicament si la clau nova no existia. Si ja existia no fa res (tornant 0 per a indicar-h0). Exemples 127.0.0.1:6379> renamenx compt1 compt3 (integer) 0 127.0.0.1:6379> get compt1 \"9\" Estem suposant que la clau compt3 ja existeix","title":"RENAMENX"},{"location":"2__bases_de_dades_clauvalor/#expire","text":"Sintaxi expire clau segons Assigna com a temps d'expiraci\u00f3 de la clau els segons especificats. Si ja tenia temps d'expiraci\u00f3, el modifica posant-li aquest valor especificat. En cas que a una clau amb temps d'expiraci\u00f3 li canviem el nom amb RENAME , continuar\u00e0 amb temps d'expiraci\u00f3 que li quedava.","title":"EXPIRE"},{"location":"2__bases_de_dades_clauvalor/#pexpire","text":"Sintaxi pexpire clau milisegons El mateix per\u00f2 en milisegons","title":"PEXPIRE"},{"location":"2__bases_de_dades_clauvalor/#ttl","text":"Sintaxi ttl clau Torna el temps de vida (fins l'expiraci\u00f3) d'una clau. Si la clau no t\u00e9 temps d'expiraci\u00f3, torna -1. Exemples 127.0.0.1:6379> expire compt3 10 (integer) 1 127.0.0.1:6379> ttl compt3 (integer) 6 127.0.0.1:6379> ttl compt3 (integer) 3 127.0.0.1:6379> ttl compt3 (integer) 0 127.0.0.1:6379> get compt3 (nil)","title":"TTL"},{"location":"2__bases_de_dades_clauvalor/#pttl","text":"Sintaxi pttl clau Igual que l'anterior, per\u00f2 ens torna el temps en milisegons.","title":"PTTL"},{"location":"2__bases_de_dades_clauvalor/#persist","text":"Sintaxi persist clau Elimina el temps d'expiraci\u00f3 d'una clau, si \u00e9s que en tenia. Ara la clau no expirar\u00e0 mai. Exemples 127.0.0.1:6379> expire compt1 20 (integer) 1 127.0.0.1:6379> ttl compt1 (integer) 12 127.0.0.1:6379> ttl compt1 (integer) 7 127.0.0.1:6379> persist compt1 (integer) 1 127.0.0.1:6379> ttl compt1 (integer) -1 127.0.0.1:6379> get compt1 \"9\"","title":"PERSIST"},{"location":"2__bases_de_dades_clauvalor/#233-hash","text":"Ja hav\u00edem comentat que el tipus Hash \u00e9s una esp\u00e8cie de registre, amb subcamps (en realitat haur\u00edem de dir sub-claus). Pot tenir qualsevol n\u00famero de subcamps que s\u00f3n de tipus String. Redis \u00e9s molt eficient en quant a l'espai que ocupen els Hash , i sobretot en el temps de recuperaci\u00f3 de les dades. Els comandos que vam veure per al String no es poden aplicar al Hash . Tanmateix els comandos del Hash s\u00f3n molt similars a aquells, comen\u00e7ant sempre per H .","title":"2.3.3 - Hash"},{"location":"2__bases_de_dades_clauvalor/#hset","text":"Sintaxi hset clau camp valor Assigna al camp especificat de la clau especificada el valor especificat. Si el valor consta de m\u00e9s d'una paraula, haur\u00e0 d'anar entre cometes dobles. Si la clau no existia, la crear\u00e0, i si ja existia, senzillament afegir\u00e0 el camp. I si d'aquesta clau ja existia el camp, modificar\u00e0 el seu valor. Evidentment, en claus diferents poden haver camps amb els mateixos noms. Exemples 127.0.0.1:6379> hset empleat_1 nom Andreu (integer) 1 127.0.0.1:6379> hset empleat_1 departament 10 (integer) 1 127.0.0.1:6379> hset empleat_1 sou 1000.0 (integer) 1 127.0.0.1:6379> hset empleat_2 nom Berta (integer) 1 127.0.0.1:6379> hset empleat_2 sou 1500.0 (integer) 1","title":"HSET"},{"location":"2__bases_de_dades_clauvalor/#hget","text":"Sintaxi hget clau camp Torna el valor del camp de la clau. Si no existia (el camp o la clau) torna nil . Nom\u00e9s podem especificar un camp. Exemples 127.0.0.1:6379> hget empleat_1 nom \"Andreu\" 127.0.0.1:6379> hget empleat_1 departament \"10\" 127.0.0.1:6379> hget empleat_2 nom \"Berta\" 127.0.0.1:6379> hget empleat_2 departament (nil)","title":"HGET"},{"location":"2__bases_de_dades_clauvalor/#hgetall","text":"Sintaxi hgetall clau Torna una llista amb tots els camps i els seus valors de la clau. La seq\u00fc\u00e8ncia \u00e9s: camp1 valor1 camp2 valor2 ... Per\u00f2 no ens podem fiar que l'ordre siga el mateix ordre que quan el vam definir. Exemples 127.0.0.1:6379> hgetall empleat_1 1) \"nom\" 2) \"Andreu\" 3) \"departament\" 4) \"10\" 5) \"sou\" 6) \"1000.0\"","title":"HGETALL"},{"location":"2__bases_de_dades_clauvalor/#hdel","text":"Sintaxi hdel clau camp1 camp2 campN Elimina el o els camps especificats. Si no existeixen algun d'ells, senzillament l'ignora i si que elimina els altres. Exemples 127.0.0.1:6379> hdel empleat_1 departament (integer) 1 127.0.0.1:6379> hgetall empleat_1 1) \"nom\" 2) \"Andreu\" 3) \"sou\" 4) \"1000.0\"","title":"HDEL"},{"location":"2__bases_de_dades_clauvalor/#hkeys","text":"Sintaxi hkeys clau Torna una llista amb els camps de la clau. Si la clau no existia, torna una llista buida Exemples 127.0.0.1:6379> hkeys empleat_1 1) \"nom\" 2) \"sou\"","title":"HKEYS"},{"location":"2__bases_de_dades_clauvalor/#hvals","text":"Sintaxi hvals clau Torna una llista amb els valors (\u00fanicament els valors) de tots els camps de la clau. Si la clau no existia, torna una llista buida Exemples 127.0.0.1:6379> hvals empleat_1 1) \"Andreu\" 2) \"1000.0\"","title":"HVALS"},{"location":"2__bases_de_dades_clauvalor/#altres-comandos","text":"Tamb\u00e9 existeixen altres comandos, de funcionament com cabria esperar (els hem vist tots en el cas de String ): hmget : Torna m\u00e9s d'un camp de la clau hmset : assigna m\u00e9s d'un camp a una clau hexists : indica si existeix el subcamp de la clau hsetnx : assigna \u00fanicament en cas de que no existisca el camp. hincrby : incrementa el camp de la clau","title":"Altres Comandos"},{"location":"2__bases_de_dades_clauvalor/#234-list","text":"Les Llistes en Redis s\u00f3n llistes de Strings ordenades, on cada element est\u00e0 associat a un \u00edndex de la llista. Es poden recuperar els elements tant de forma ordenada (per l'\u00edndex) com accedint directament a una posici\u00f3. Els elements es poden afegir al principi, al final o tamb\u00e9 en una posici\u00f3 determinada. La llista es crea en el moment en qu\u00e8 s'insereix el primer element, i desapareix quan llevem l'\u00faltim element que quede. Estan molt ben optimitzades per a la inserci\u00f3 i per a la consulta. Els comandos que afecten a les llistes comencen quasi tots per L , excepte alguns que comencen per R indicant que fan l'operaci\u00f3 per la dreta. Els valors dels elements es poden repetir.","title":"2.3.4 - List"},{"location":"2__bases_de_dades_clauvalor/#lpush","text":"Sintaxi lpush clau valor1 valor2 valorN Introdueix els valors a la llista (creant la clau si \u00e9s necessari). Les insereix en la primera posici\u00f3, o tamb\u00e9 podr\u00edem dir que per l'esquerra ( Left PUSH ), imaginant que els elements estan ordenats d'esquerra a dreta. Si posem m\u00e9s d'un valor, s'aniran introduint sempre en la primera posici\u00f3. El comando tornar\u00e0 el n\u00famero d'elements (strings) de la llista despr\u00e9s de la inserci\u00f3. Exemples 127.0.0.1:6379> lpush llista1 primera segona tercera (integer) 3 127.0.0.1:6379> lrange llista1 0 -1 1) \"tercera\" 2) \"segona\" 3) \"primera\" 127.0.0.1:6379> lpush llista1 quarta cinquena (integer) 5 127.0.0.1:6379> lrange llista1 0 -1 1) \"cinquena\" 2) \"quarta\" 3) \"tercera\" 4) \"segona\" 5) \"primera\" Nota Per a veure el contingut de la llista utilitzarem el comando lrange llista 0 -1 , que torna la llista sencera. Veurem de forma m\u00e9s completa aquest comando amb posterioritat.","title":"LPUSH"},{"location":"2__bases_de_dades_clauvalor/#rpush","text":"Sintaxi rpush clau valor1 valor2 valorN Introdueix els valors a la llista (creant la clau si \u00e9s necessari). Les insereix en l'\u00faltima posici\u00f3, o tamb\u00e9 podr\u00edem dir que per la dreta ( Right PUSH ), imaginant que els elements estan ordenats d'esquerra a dreta. El comando tornar\u00e0 el n\u00famero d'elements (strings) de la llista despr\u00e9s de la inserci\u00f3. Exemples 127.0.0.1:6379> rpush llista1 sisena setena (integer) 7 127.0.0.1:6379> lrange llista1 0 -1 1) \"cinquena\" 2) \"quarta\" 3) \"tercera\" 4) \"segona\" 5) \"primera\" 6) \"sisena\" 7) \"setena\"","title":"RPUSH"},{"location":"2__bases_de_dades_clauvalor/#lpop","text":"Sintaxi lpop clau Torna i elimina el primer element (el de m\u00e9s a l'esquerra). Exemples 127.0.0.1:6379> lpop llista1 \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"segona\" 4) \"primera\" 5) \"sisena\" 6) \"setena\"","title":"LPOP"},{"location":"2__bases_de_dades_clauvalor/#rpop","text":"Sintaxi rpop clau Torna i elimina l'\u00faltim element (el de m\u00e9s a la dreta). Exemples 127.0.0.1:6379> rpop llista1 \"setena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"segona\" 4) \"primera\" 5) \"sisena\"","title":"RPOP"},{"location":"2__bases_de_dades_clauvalor/#lset","text":"Sintaxi lset clau index valor Substitueix el valor de la posici\u00f3 indicada per l'\u00edndex. Tant la clau com l'element de la posici\u00f3 indicada han d'existir, sin\u00f3 donar\u00e0 error. Ara la L no significa Left sin\u00f3 List . La primera posici\u00f3 \u00e9s la 0. I tamb\u00e9 es poden posar n\u00fameros negatius: -1 \u00e9s l'\u00faltim, -2 el pen\u00faltim, ... Exemples 127.0.0.1:6379> lset llista1 2 quarta OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"sisena\" 127.0.0.1:6379> lset llista1 -1 cinquena OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" Observeu com es poden repetir els valors","title":"LSET"},{"location":"2__bases_de_dades_clauvalor/#lindex","text":"Sintaxi lindex clau index Torna l'element situat en la posici\u00f3 indicada per l'\u00edndex, per\u00f2 sense eliminar-lo de la llista . Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" 127.0.0.1:6379> lindex llista1 0 \"quarta\" 127.0.0.1:6379> lindex llista1 3 \"primera\" 127.0.0.1:6379> lindex llista1 -1 \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\"","title":"LINDEX"},{"location":"2__bases_de_dades_clauvalor/#linsert","text":"Sintaxi linsert clau BEFORE | AFTER valor1 valor2 Insereix el valor2 abans o despr\u00e9s (segons el que triem) de la primera vegada que troba el valor1. No substitueix, sin\u00f3 que insereix en una determinada posici\u00f3. Els elements que van despr\u00e9s de l'element introdu\u00eft veuran actualitzat el seu \u00edndex. Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"cinquena\" 127.0.0.1:6379> linsert llista1 AFTER quarta segona (integer) 6 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"cinquena\" 127.0.0.1:6379> linsert llista1 BEFORE cinquena sisena (integer) 7 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 127.0.0.1:6379> lrange llista1 0 -1 Si intentem inserir abans o despr\u00e9s un element que no existeix, tornar\u00e0 -1 indicant que no l'ha trobat i no far\u00e0 la inserci\u00f3. 127.0.0.1:6379> linsert llista1 BEFORE desena setena (integer) -1 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\"","title":"LINSERT"},{"location":"2__bases_de_dades_clauvalor/#lrange","text":"Sintaxi lrange clau inici final Torna els elements de la llista inclosos entre els index inici i final, ambd\u00f3s inclosos. El primer element \u00e9s el 0. Es poden posar valors negatius, sent -1 l'\u00faltim, -2 el pen\u00faltim, ... Exemples 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 127.0.0.1:6379> lrange llista1 2 4 1) \"tercera\" 2) \"quarta\" 3) \"primera\" 127.0.0.1:6379> lrange llista1 1 -2 4) \"segona\" 5) \"tercera\" 6) \"quarta\" 7) \"primera\" 8) \"sisena\" 127.0.0.1:6379> lrange llista1 4 4 1) \"primera\"","title":"LRANGE"},{"location":"2__bases_de_dades_clauvalor/#llen","text":"Sintaxi llen clau Torna el n\u00famero d'elements de la llista Exemples 127.0.0.1:6379> llen llista1 (integer) 7","title":"LLEN"},{"location":"2__bases_de_dades_clauvalor/#lrem","text":"Sintaxi lrem clau n\u00famero valor Elimina elements de la llista que coincidisquen amb el valor proporcionat. Ja sabem que els valors es poden repetir. Amb el n\u00famero indiquem quants elements volem que s'esborrencomen\u00e7ant per l'esquerra: si posem 1 s'esborrar\u00e0 el primer element amb aquest valor, si posem 2 s'esborraran els dos primers elements (els de m\u00e9s a l'esquerra) que tingen aquest valor. Si posem 0 s'esborraran tots els elements amb aquest valor Exemples 127.0.0.1:6379> rpush llista1 segona (integer) 8 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"segona\" 3) \"tercera\" 4) \"quarta\" 5) \"primera\" 6) \"sisena\" 7) \"cinquena\" 8) \"segona\" 127.0.0.1:6379> lrem llista1 1 segona (integer) 1 127.0.0.1:6379> lrange llista1 0 -1 1) \"quarta\" 2) \"tercera\" 3) \"quarta\" 4) \"primera\" 5) \"sisena\" 6) \"cinquena\" 7) \"segona\" 127.0.0.1:6379> lrem llista1 0 quarta (integer) 2 127.0.0.1:6379> lrange llista1 0 -1 8) \"tercera\" 9) \"primera\" 10) \"sisena\" 11) \"cinquena\" 12) \"segona\"","title":"LREM"},{"location":"2__bases_de_dades_clauvalor/#ltrim","text":"Sintaxi ltrim clau inici final Elimina els elements que queden fora dels \u00edndex inici i final, \u00e9s a dir elimina els que estiguen a l'esquerra d'inici, i els que estiguen a la dreta de final. Exemples 127.0.0.1:6379> ltrim llista1 1 -2 OK 127.0.0.1:6379> lrange llista1 0 -1 1) \"primera\" 2) \"sisena\" 3) \"cinquena\"","title":"LTRIM"},{"location":"2__bases_de_dades_clauvalor/#235-set","text":"Els Sets de Redis s\u00f3n conjunts de valors de tipus String no ordenats. Podrem afegir, actualitzar i esborrar aquestos elements de forma c\u00f2moda i eficient. No es permetran els valors duplicats. A m\u00e9s Redis ens ofereix operacions interessants com la uni\u00f3, intersecci\u00f3 i difer\u00e8ncia de conjunts. Com sempre, els comandos s\u00f3n espec\u00edfics, \u00e9s a dir no ens valen els de Strings, List o Hash. Tots els comandos comencen per S .","title":"2.3.5 - Set"},{"location":"2__bases_de_dades_clauvalor/#sadd","text":"Sintaxi sadd clau valor1 valor2 valorN Afegeix els valors al conjunt (creant la clau si \u00e9s necessari). Recordem que l'ordre no \u00e9s important, i que no es poden repetir els valors; si intentem introduir un repetit, no donar\u00e0 error, per\u00f2 no l'introduir\u00e0. El comando tornar\u00e0 el n\u00famero d'elements que realment s'han afegit. Exemples 127.0.0.1:6379> sadd colors roig verd blau (integer) 3 127.0.0.1:6379> sadd colors verd groc (integer) 1","title":"SADD"},{"location":"2__bases_de_dades_clauvalor/#smembers","text":"Sintaxi smembers clau Torna tots els valors del conjunt. Si la clau no existeix tornar\u00e0 un conjunt buit. Recordeu que l'ordre dels elements no \u00e9s predecible Exemples 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"verd\" 3) \"roig\" 4) \"blau\"","title":"SMEMBERS"},{"location":"2__bases_de_dades_clauvalor/#sismember","text":"Sintaxi sismember clau valor Comprova si el valor est\u00e0 en el conjunt, tornant 1 en cas afirmatiu i 0 en cas negatiu. Exemples 127.0.0.1:6379> sismember colors verd (integer) 1 127.0.0.1:6379> sismember colors negre (integer) 0","title":"SISMEMBER"},{"location":"2__bases_de_dades_clauvalor/#scard","text":"Sintaxi sard clau Torna la cardinalitat, \u00e9s a dir, el n\u00famero d'elements del conjunt en l'actualitat. Exemples 127.0.0.1:6379> scard colors (integer) 4","title":"SCARD"},{"location":"2__bases_de_dades_clauvalor/#srem","text":"Sintaxi srem clau valor1 valor2 valorN Elimina els valors del conjunt. Si el conjunt es queda buit, eliminar\u00e0 la clau tamb\u00e9. Si algun dels valor no \u00e9s cap element del conjunt, senzillament s'ignorar\u00e0. El comando torna el n\u00famero d'elements realment eliminat. Exemples 127.0.0.1:6379> srem colors verd negre (integer) 1 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"roig\" 3) \"blau\"","title":"SREM"},{"location":"2__bases_de_dades_clauvalor/#spop","text":"Sintaxi spop clau Torna i elimina un valor aleatori del conjunt. Recordeu que a m\u00e9s de tornar- lo, l'elimina del conjunt. Exemples 127.0.0.1:6379> smembers colors 1) \"groc\" 2) \"roig\" 3) \"blau\" 127.0.0.1:6379> spop colors \"groc\" 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\"","title":"SPOP"},{"location":"2__bases_de_dades_clauvalor/#srandmember","text":"Sintaxi srandmember clau Molt paregut a l'anterior. Torna un valor aleatori del conjunt, per\u00f2 en aquesta ocasi\u00f3 no l'elimina del conjunt. Exemples 127.0.0.1:6379> srandmember colors \"blau\" 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\"","title":"SRANDMEMBER"},{"location":"2__bases_de_dades_clauvalor/#sunion","text":"Sintaxi sunion clau1 clau2 clauN Torna la uni\u00f3 dels elements dels conjunts especificats. \u00c9s una uni\u00f3 correcta, \u00e9s a dir, no es repetir\u00e0 cap valor. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> sadd colors1 verd roig groc (integer) 3 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sunion colors colors1 1) \"verd\" 2) \"groc\" 3) \"roig\" 4) \"blau\"","title":"SUNION"},{"location":"2__bases_de_dades_clauvalor/#sunionstore","text":"Sintaxi sunionstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la uni\u00f3 en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sunionstore colors2 colors colors1 (integer) 4 127.0.0.1:6379> smembers colors2 1) \"verd\" 2) \"groc\" 3) \"roig\" 4) \"blau\"","title":"SUNIONSTORE"},{"location":"2__bases_de_dades_clauvalor/#sdiff","text":"Sintaxi sdiff clau1 clau2 clauN Torna la difer\u00e8ncia dels elements del primer conjunt respecte de la uni\u00f3 de tots els altres. \u00c9s a dir, torna els elements del primer conjunt que no pertanyen acap dels altres. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sdiff colors1 colors 1) \"verd\" 2) \"groc\"","title":"SDIFF"},{"location":"2__bases_de_dades_clauvalor/#sdiffstore","text":"Sintaxi sdiffstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la difer\u00e8ncia en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sdiffstore colors3 colors1 colors (integer) 2 127.0.0.1:6379> smembers colors3 1) \"verd\" 2) \"groc\"","title":"SDIFFSTORE"},{"location":"2__bases_de_dades_clauvalor/#sinter","text":"Sintaxi sinter clau1 clau2 clauN Torna la intersecci\u00f3 dels elements dels conjunts. \u00c9s a dir, torna els elements que pertanyen a tots els conjunts especificats. No modifica cap conjunt, i el resultat \u00fanicament es torna, no es guarda en cap lloc de forma permanent. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> sinter colors colors1 1) \"roig\"","title":"SINTER"},{"location":"2__bases_de_dades_clauvalor/#sinterstore","text":"Sintaxi sinterstore clau_dest\u00ed clau1 clau2 clauN Igual que l'anterior, per\u00f2 ara s\u00ed que es guarda el resultat de la intersecci\u00f3 en un conjunt, clau_dest\u00ed (el primer especificat). Si la clau_dest\u00ed ja existia, substituir\u00e0 el contingut. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 3) \"groc\" 4) \"roig\" 5) \"verd\" 127.0.0.1:6379> sinterstore colors4 colors colors1 (integer) 1 127.0.0.1:6379> smembers colors4 6) \"roig\"","title":"SINTERSTORE"},{"location":"2__bases_de_dades_clauvalor/#smove","text":"Sintaxi smove clau_font clau_dest\u00ed valor Meneja el valor del conjunt or\u00edgen (el primer conjunt) al conjunt dest\u00ed (el segon). Aix\u00f2 suposar\u00e0 eliminar-lo del primer i afegir-lo al segon. Tornar\u00e0 1 si l'ha menejat, i 0 si no l'ha menejat. Exemples 127.0.0.1:6379> smembers colors 1) \"roig\" 2) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\" 3) \"verd\" 127.0.0.1:6379> smove colors1 colors verd (integer) 1 127.0.0.1:6379> smembers colors 1) \"verd\" 2) \"roig\" 3) \"blau\" 127.0.0.1:6379> smembers colors1 1) \"groc\" 2) \"roig\"","title":"SMOVE"},{"location":"2__bases_de_dades_clauvalor/#236-set-ordenat","text":"Els Sets Ordenats ( Sorted Set ) de Redis s\u00f3n Sets que a m\u00e9s de guardar els valors, guarden tamb\u00e9 una puntuaci\u00f3 ( score ) per a cada valor, i Redis mantindr\u00e0 el conjunt ordenat per aquesta puntuaci\u00f3. Els valors no es podran repetir, per\u00f2 s\u00ed les puntuacions. Molts dels comandos seran iguals que els del Set , ja que un conjunt ordenat no deixa de ser un conjunt, per\u00f2 amb la informaci\u00f3 de la puntuaci\u00f3. En aquesta ocasi\u00f3 comen\u00e7aran per Z","title":"2.3.6 - Set ordenat"},{"location":"2__bases_de_dades_clauvalor/#zadd","text":"Sintaxi zadd clau puntuaci\u00f31 valor1 puntuaci\u00f32 valor2 puntuaci\u00f3N valorN Afegeix els valors al conjunt (creant la clau si \u00e9s necessari) amb les puntuacions corresponents. Les puntuacions seran Strings de valors reals (float). No es poden repetir els valors, per\u00f2 s\u00ed les puntuacions. Si intentem introduir un valor repetit, el que far\u00e0 ser\u00e0 actualitzar la puntuaci\u00f3. El comando tornar\u00e0 el n\u00famero d'elements que realment s'han afegit. Exemples 127.0.0.1:6379> zadd puntuacions 1 Nom1 2 Nom2 5 Nom3 4 Nom4 (integer) 4 127.0.0.1:6379> zrange puntuacions 0 -1 1) \"Nom1\" 2) \"Nom2\" 3) \"Nom4\" 4) \"Nom3\"","title":"ZADD"},{"location":"2__bases_de_dades_clauvalor/#zcard","text":"Sintaxi zcard clau Torna la cardinalitat, \u00e9s a dir, el n\u00famero d'elements del conjunt ordenat en l'actualitat. Exemples 127.0.0.1:6379> zcard puntuacions (integer) 4","title":"ZCARD"},{"location":"2__bases_de_dades_clauvalor/#zscore","text":"Sintaxi zscore clau valor Torna la puntuaci\u00f3 (score) del valor especificat del conjunt ordenat. Si no existeix el valor o no existaix la clao, torna nil. Exemples 127.0.0.1:6379> zscore puntuacions Nom3 \"5\" 127.0.0.1:6379> zscore puntuacions Nom7 (nil)","title":"ZSCORE"},{"location":"2__bases_de_dades_clauvalor/#zcount","text":"Sintaxi zcount clau min max Torna el n\u00famero de valors que estan entre les puntuacions especificades (ambdues incloses). Exemples 127.0.0.1:6379> zcount puntuacions 2 5 (integer) 3","title":"ZCOUNT"},{"location":"2__bases_de_dades_clauvalor/#zrange","text":"Sintaxi zrange clau inici final [withscores] Torna els elements del conjunt ordenat inclosos entre els index inici i final, ambd\u00f3s inclosos. I es trauen per ordre ascentent de puntuaci\u00f3. El primer element \u00e9s el 0. Es poden posar valors negatius, sent -1 l'\u00faltim, -2 el pen\u00faltim, ... Opcionalment podem posar WITHSCORES per a que ens torne tamb\u00e9 la puntuaci\u00f3 de cada element Exemples 127.0.0.1:6379> zrange puntuacions 0 -1 1) \"Nom1\" 2) \"Nom2\" 3) \"Nom4\" 4) \"Nom3\" 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom1\" 2) \"1\" 3) \"Nom2\" 4) \"2\" 5) \"Nom4\" 6) \"4\" 7) \"Nom3\" 8) \"5\" Si vulgu\u00e9rem traure el conjunt en ordre invers de puntuaci\u00f3, utilitzar\u00edem el comando ZREVRANGE ( reverse range ). 127.0.0.1:6379> zrevrange puntuacions 0 -1 withscores 1) \"Nom3\" 2) \"5\" 3) \"Nom4\" 4) \"4\" 5) \"Nom2\" 6) \"2\" 7) \"Nom1\" 8) \"1\"","title":"ZRANGE"},{"location":"2__bases_de_dades_clauvalor/#zrangebyscore","text":"Sintaxi zrangebyscore clau min max [withscores] Torna els elements del conjunt ordenat que tenen una puntuaci\u00f3 compresa entre min i max (ambdues incloses). I es trauen per ordre ascentent de puntuaci\u00f3. Opcionalment podem posar WITHSCORES per a que ens torne tamb\u00e9 la puntuaci\u00f3 de cada element. **** Exemples 127.0.0.1:6379> zrangebyscore puntuacions 2 5 1) \"Nom2\" 2) \"Nom4\" 3) \"Nom3\" 127.0.0.1:6379> zrangebyscore puntuacions 2 5 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" 5) \"Nom3\" 6) \"5\" Si vulgu\u00e9rem que les puntuacions foren estrictament majors que la puntiuaci\u00f3 m\u00ednima i/o estrictament menor que la puntuaci\u00f3 m\u00e0xima, posar\u00edem un par\u00e8ntesi davany de min i/o max : 127.0.0.1:6379> zrangebyscore puntuacions 2 (5 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" I si vulgu\u00e9rem traure el conjunt en ordre invers de puntuaci\u00f3, utilitzar\u00edem el comando ZREVRANGEBYSCORE ( reverse range ). Cuideu que com va en ordre invers, ara el valor m\u00e0xim ha de ser el primer, i el m\u00ednim el segon. 127.0.0.1:6379> zrevrangebyscore puntuacions 5 2 withscores 1) \"Nom3\" 2) \"5\" 3) \"Nom4\" 4) \"4\" 5) \"Nom2\" 6) \"2\"","title":"ZRANGEBYSCORE"},{"location":"2__bases_de_dades_clauvalor/#zrank","text":"Sintaxi zrank clau valor Torna el n\u00famero d'ordre de l'element amb el valor especificat. El primer valor \u00e9s el 0. Si no existeix, torna nil . Exemples 127.0.0.1:6379> zrank puntuacions Nom1 (integer) 0 127.0.0.1:6379> zrank puntuacions Nom4 (integer) 2 127.0.0.1:6379> zrank puntuacions Nom7 (nil) Si volem saber el n\u00famero d'ordre per\u00f2 des del final de la llista (en ordre invers), hem d'utilitzar ZREVRANK : 127.0.0.1:6379> zrevrank puntuacions Nom1 (integer) 3 127.0.0.1:6379> zrevrank puntuacions Nom4 (integer) 1","title":"ZRANK"},{"location":"2__bases_de_dades_clauvalor/#zrem","text":"Sintaxi zrem clau valor1 valor2 valorN Elimina els elements amb els valors especificats. Si algun valor no existeix, senzillament l'ignora. Torna el n\u00famero d'elements realment eliminats. Exemples 127.0.0.1:6379> zrem puntuacions Nom1 (integer) 1 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom4\" 4) \"4\" 5) \"Nom3\" 6) \"5\"","title":"ZREM"},{"location":"2__bases_de_dades_clauvalor/#zremrangebyscore","text":"Sintaxi zremrangebyscore clau min max Elimina els elements amb puntuaci\u00f3 compresa entre el m\u00ednim i el m\u00e0xim de forma inclusiva.els valors especificats. Si volem fer-ho de forma excusiva (sense incloure les puntuacions dels extrems) posarem un par\u00e8ntesi avant del m\u00ednim i/o el m\u00e0xim. Torna el n\u00famero d'elements realment eliminats. Exemples 127.0.0.1:6379> zremrangebyscore puntuacions (2 4 (integer) 1 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom2\" 2) \"2\" 3) \"Nom3\" 4) \"5\"","title":"ZREMRANGEBYSCORE"},{"location":"2__bases_de_dades_clauvalor/#zincrby","text":"Sintaxi zincrby clau increment valor Incrementa la puntuaci\u00f3 de l'element especificat. El valor de la puntuaci\u00f3 a incrementar \u00e9s un n\u00famero real. Torna el valor la puntuaci\u00f3 final de l'element. Si l'element no existia, l'inserir\u00e0, assumint una puntuaci\u00f3 inicial de 0. Exemples 127.0.0.1:6379> zincrby puntuacions 1.5 Nom2 \"3.5\" 127.0.0.1:6379> zincrby puntuacions 2.75 Nom5 \"2.75\" 127.0.0.1:6379> zrange puntuacions 0 -1 withscores 1) \"Nom5\" 2) \"2.75\" 3) \"Nom2\" 4) \"3.5\" 5) \"Nom3\" 6) \"5\"","title":"ZINCRBY"},{"location":"2__bases_de_dades_clauvalor/#24-resum-de-comandos-pdf","text":"Al seg\u00fcent enlla\u00e7 disposeu d'un document pdf amb un resum de les comandes de Redis classificades per l'operaci\u00f3 CRUD que realitzen. Resum comandos Redis","title":"2.4 - Resum de comandos (PDF)"},{"location":"2__bases_de_dades_clauvalor/#exercici-1","text":"Sobre la Base de Dades REDIS del Servidor de l'Institut (adre\u00e7a 89.36.214.106 ) fer les seg\u00fcents operacions, tant per a guardar una s\u00e8rie de dades, com per a recuperar-les. Sempre posarem a les claus el prefix 9999x_ , on com sempre heu de substituir 9999 per les 4 \u00faltimes xifres del vostre DNI, i la x per la letra del NIF. Copia-les en un \u00fanic fitxer de text, de forma numerada. \u00c9s aquest fitxer el que haur\u00e0s de pujar. Crea la clau 9999x_Nom amb el teu nom Crea la clau 9999x_Cognoms amb els teus cognoms. Una de les dues almenys, nom o cognoms, ha de constar de m\u00e9s d'una paraula. Mostra totes les claus teues, i \u00fanicament les teues. D\u00f3na un temps de vida a la clau 9999x_Nom de 200 segons . Comprova el temps de vida que li queda. Posteriorment fes-la permanent . Crea la clau 9999x_Adreca , de tipus Hash, amb els subcamps carrer , numero i cp . No importa que les dades siguen falses. Pots fer-lo en una sent\u00e8ncia o en m\u00e9s d'una. Afegeix a l'anterior el subcamp poblacio Mostra tota la informaci\u00f3 de la teua adre\u00e7a (nom\u00e9s la informaci\u00f3, no les subclaus)**** Crea la clau 9999x_Moduls_ASIX o 9999x_Moduls_DAM o 9999x_Moduls_DAW , depenent del teu cicle. Ha de ser de tipus Set, amb tots els m\u00f2duls del teu cicle, que es detallen a continuaci\u00f3. Pots fer-lo en una o en m\u00e9s d'una sent\u00e8ncia. ASIX : ISO, PAX, FH, GBD, LM, FOL, ASO, SXI, IAW, ASGBD, SAD, EIE, PROJ i FCT DAW : SI, BD, PR, LM, ED, FOL, DWEC, DWES, DAW, DIW, EIE, PROJ i FCT DAM : SI, BD, PR, LM, ED, FOL, AD, PMDM, DI, PSP, SGE, EIE, PROJ i FCT. Crea la clau 9999x_Moduls_meus , de tipus Set, amb tots els m\u00f2duls als quals est\u00e0s matriculat. Pots fer-lo en una o en m\u00e9s d'una sent\u00e8ncia. Guarda en la clau 9999x_Moduls_altres els m\u00f2duls en els quals no est\u00e0s matriculat actualment. Ha de ser per mig d'operacions de conjunts. Pots comprovar que el resultat \u00e9s correcte amb smembers Crea una llista amb el nom 9999x_Notes_BD amb la nota de 4 exercicis de BD. Les notes seran: 7, 9, 6, 10. Han de quedar en aquest ordre (no en ordre invers) Modifica la tercera nota, que passa de ser 6 a 8. Crea un Set Ordenat ( zset ) anomenat 9999x_Carrera amb els seg\u00fcents valors. Pots fer-lo en una o en m\u00e9s d'una sent\u00e8ncia. I ves amb compte perqu\u00e8 els temps han de ser num\u00e8rics Sandra 12'52 Isabel 12'25 Marta 12'10 Maria 12'07 Rosa 11'95 Bea 11'97 Balma 11'90 Anna 12'74 Trau les participants de la carrera ordenades pel temps Penalitza el temps de Bea amb 2 d\u00e8cimes (0'2), i torna a traure les participants ordenades (Bea ha d'haver perdut 2 posicions, passant de tercera a cinquena posici\u00f3) Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercici 1"},{"location":"3__mongodb/","text":"3 - MongoDB Segurament MongoDB \u00e9s el m\u00e9s fam\u00f3s dels Sistemes Gestors de Bases de Dades NoSQL . El nom de MongoDB prov\u00e9 de la paraula anglesa hu mongo us , que significa enorme, que \u00e9s el prop\u00f2sit d'aquesta Base de Dades: guardar grans quantitats d'informaci\u00f3. \u00c9s de codi obert i est\u00e0 programada en C++. El va crear l'empresa 10gen (actualment MongoDB Inc. ) \u00c9s un SGBD Documental , \u00e9s a dir, que servir\u00e0 per a guardar documents. La manera interna de guardar-los \u00e9s en format BSON (Binary JSON) que en ess\u00e8ncia \u00e9s una variant del JSON per a poder guardar f\u00edsicament les dades d'una manera m\u00e9s eficient. En un servidor Mongo poden haver m\u00e9s d'una Base de Dades, encara que nosaltres nom\u00e9s en gastarem una: test . En cada Base de Dades la informaci\u00f3 es guardar\u00e0 en col\u00b7leccions . Cada col\u00b7lecci\u00f3 constar\u00e0 d'uns quants documents . I cada document seran una s\u00e8rie de dades guardades en forma de clau-valor , dels tipus suportats per MongoDB, i amb el format JSON (en realitat BSON) Per tant, en Mongo no hi ha taules. Mirem uns exemples de documents JSON per a guardar la informaci\u00f3 de llibres i autors. Depenen de com s'haja d'accedir a la informaci\u00f3 ens podem plantejar guardar els llibres amb els seus autors, o guardar els autors, amb els seus llibres. Fins i tot ens podr\u00edem guardar els dos, per a poder accedir de totes les maneres, encara que \u00e9s a costa de doblar la informaci\u00f3. De la primera manera, guardant els llibres amb el seu autor, podr\u00edem tenir documents amb aquesta estructura, que es podrien guardar en una col\u00b7lecci\u00f3 anomenada Llibres : { _id:101, titol:\"El secret de Khadrell\", autor: { nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960 }, isbn:\"84-95620-72-3\" }, { _id:102, titol:\"L'Ombra del Vent\", autor: { nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\" }, pagines:490, editorial:\"Planeta\" } Observeu com els objectes no tenen per qu\u00e8 tenir la mateixa estructura. La manera d'accedir al nom d'un autor seria aquesta: objecte.autor.nom Una manera alternativa de guardar la informaci\u00f3, com hav\u00edem comentat abans seria organitzar per autors, amb els seus llibres. D'aquesta manera podr\u00edem anar omplint la col\u00b7lecci\u00f3 Autors amb un o m\u00e9s documents d'aquest estil: { _id: 201, nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960, llibres: [ { titol:\"El secret de Khadrell\", isbn:\"84-95620-72-3\" }, { titol:\"Habitaci\u00f3 502\", editorial:\"Tabarca\" } ] }, { _id:202, nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\", llibres: [ { titol:\"L'Ombra del Vent\", pagines:490, editorial:\"Planeta\" } ] } Observeu com per a un autor, ara tenim un array ( els claud\u00e0tors: [ ] ) amb els seus llibres. Quina de les dues maneres \u00e9s millor per a guardar la informaci\u00f3? Doncs dep\u00e9n de l'acc\u00e9s que s'haja de fer a les dades. La millor ser\u00e0 segurament aquella que depenent dels accessos que s'hagen de fer, torne la informaci\u00f3 de forma m\u00e9s r\u00e0pida. 3.1 - Estructura JSON Amb JSON podrem representar: Valors , de tipus car\u00e0cter (entre cometes dobles), num\u00e8ric (sense cometes) , boole\u00e0 (true o false) o null . Parelles clau valor , \u00e9s a dir un nom simb\u00f2lic acompanyat d'un valor associat.. Es representen aix\u00ed: \"nom\" : valor Objectes , que \u00e9s una col\u00b7lecci\u00f3 de membres, cadasc\u00fa dels quals pot ser una parella clau valor, o altres objectes (fins i tot arrays): es representen entre claus, i amb els elements separats per comes: { \"nom1\" : \"valor1\" , \"nom2\": valor2 , valor 3 , ... } Arrays , que s\u00f3n llistes d'elements. Els elements no tenen per qu\u00e8 tenir la mateixa estructura, per\u00f2 nosaltres intentarem que s\u00ed que la tinguen per coher\u00e8ncia. Cada element pot ser un valor , una parella clau valor, un objecte o un array. Veje'm algun exemples: { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } en aquest cas tenim un objecte, l'arrel, que t\u00e9 5 membres, tots ells parelles clau-valor. { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } ara un objecte, l'arrel, tamb\u00e9 amb 5 membres que s\u00f3n parelles clau-valor. Observeu com la clau sempre la posem entre cometes, i el valor quan \u00e9s un string tamb\u00e9, per\u00f2 quan \u00e9s num\u00e8ric, no. { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } en aquest cas tenim un objecte, l'arrel que consta d'un \u00fanic objecte, empleat , el qual consta de 5 membres clau-valor. Mirem ara un exemple amb un array: { \"notes\" : [ 5 , 7 , 8 , 7 ] } on tenim l'element arrel que consta d'un \u00fanic membre, notes , que \u00e9s un array. Tamb\u00e9 seria correcte d'aquesta manera, per veure que l'element arrel no t\u00e9 perqu\u00e8 ser un objecte, sin\u00f3 tamb\u00e9 un array [ 5 , 7 , 8 , 7 ] I ara un m\u00e9s complet amb la mateixa estructura que el fitxer XML que hav\u00edem vist en la pregunta 4. Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic element empleat que \u00e9s un array amb 4 elements, cadascun dels empleats: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Anem a veure un parell de casos m\u00e9s reals. Aquesta \u00e9s la contestaci\u00f3 que fa el WebService de Bicicas en sol\u00b7licitar l'estat actual de bicicletes en els diferents punts (en el moment de fer els apunts es consulta en l'adre\u00e7a http://gestiona.bicicas.es/apps/apps.php ): [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":27,\"ocupados\":12,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":24,\"ocupados\":7,\"latitud\":\"39.98765\",\"longitud\":\"-0.05281\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":4,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podeu comprovar, l'arrel no \u00e9s un objecte, sin\u00f3 un Array . En l'array nom\u00e9s ens interessa el primer element que \u00e9s un objecte amb un \u00fanic membre, ocupacion (en l'exemple no hi ha m\u00e9s elements, per\u00f2 en poden haver m\u00e9s en un moment determinat, quan volen fer avisos). I ocupacion \u00e9s un array , amb un objecte per cada estaci\u00f3 de bicicas , amb les parelles clau valor id , punto , puestos (les bicicletes que caben), ocupados (quantes bicicletes hi ha col\u00b7locades en aquest moment), latitud i longitud (les coordenades), ... Nota En realitat ens apareixer\u00e0 tota la informaci\u00f3 molt m\u00e9s apegada, perqu\u00e8 realment est\u00e0 en una \u00fanica l\u00ednia. Per a poder observar millor l'estructura podem utilitzar un visor de json. Normalment el navegador Firefox els visualitza b\u00e9, encara que tamb\u00e9 dep\u00e9n de la versi\u00f3. Si tenim instal\u00b7lada una versi\u00f3 que admet la visualitzaci\u00f3 de JSON, ho intentar\u00e0 interpretar, encara que segurament la millor manera de veure el format JSON \u00e9s,tiar les opcions Dades sense processar -- > Format d'impressi\u00f3 , que \u00e9s la que veiem a la dreta: Si la versi\u00f3 nostra de Firefox no visualitza el format JSON, podem buscar un visor dels molts que hi ha per internet. En la figura n'hem utilitzat un, i es pot observar com facilita molt la lectura. Un altre exemple. Un WebService de GeoNames (una Base de Dade geogr\u00e0fica gratu\u00efta i accessible a trav\u00e9s d'Internet) ens proporciona informaci\u00f3 dels llocs que troba dins d'un rectangle delimitat per un latitud al nord i al sud, i una longitud a l'esti a l'oest (en l'exemple: nord 40.01, sud 39.9, est 0.1 i oest -0.1). Per exemple, http://api.geonames.org/citiesJSON?north=40.01&south=39.99&east=0.01&west=-0.01&lang=ES&username=demo torna el seg\u00fcent: { \"geonames\": [ { \"lng\": -0.04935, \"geonameId\": 2519752, \"countrycode\": \"ES\", \"name\": \"Castell\u00f3 de la Plana\", \"fclName\": \"city, village,...\", \"toponymName\": \"Castell\u00f3 de la Plana\", \"fcodeName\": \"seat of a second-order administrative division\", \"wikipedia\": \"en.wikipedia.org/wiki/Castell%C3%B3n_de_la_Plana\", \"lat\": 39.98567, \"fcl\": \"P\", \"population\": 180005, \"fcode\": \"PPLA2\" }, { \"lng\": -0.06313, \"geonameId\": 2521909, \"countrycode\": \"ES\", \"name\": \"Almazora\", \"fclName\": \"city, village,...\", \"toponymName\": \"Almassora\", \"fcodeName\": \"populated place\", \"wikipedia\": \"en.wikipedia.org/wiki/Almassora\", \"lat\": 39.94729, \"fcl\": \"P\", \"population\": 24963, \"fcode\": \"PPL\" }, ... ] } A partir de l'arrel (que ara s\u00ed que \u00e9s un objecte), tenim un membre: geonames , que \u00e9s un array (un element per cada \"lloc\" trobat), on cada element t\u00e9 informaci\u00f3 diversa, com el nom del lloc, les coordenades, la poblaci\u00f3, ... Nota De fa uns mesos que Google limita el servei anterior, i ha de ser amb un usuari validat. No valdr\u00e0 la pena, per al poc profit que li traur\u00edem. Mostrem en qu\u00e8 consisteix el servei \u00fanicament a nivell il\u00b7lustratiu 3.2 - Instal\u00b7laci\u00f3 de MongoDB Podrem instal\u00b7lar MongoDB en qualsevol plataforma. I fins i tot sense tenir permisos d'administrador, com veurem en el cas d'Ubuntu. Tamb\u00e9 est\u00e0 la possibilitat de crear un servidor en el n\u00favol, fins i tot gratu\u00eft. \u00c9s l'opci\u00f3 que ens suggereix Mongo per defecte, per\u00f2 nosaltres no la utilitzarem. \ud83d\udc27Instal\u00b7laci\u00f3 en Linux Per a poder fer la instal\u00b7laci\u00f3 m\u00e9s b\u00e0sica, podrem fer-lo sense permisos d'administrador. Si els tenim tot \u00e9s m\u00e9s c\u00f2mode, per\u00f2 si no en tenim tamb\u00e9 ho podem fer, com veurem i remarcarem a continuaci\u00f3. Pas 1. Instal\u00b7laci\u00f3 del servidor (Linux) 1- De la p\u00e0gina de MongoDB ( https://www.mongodb.com/try/download/community ) anem al men\u00fa Products - > Comunity Edition ->Comunity Server i ens baixem la versi\u00f3 apropiada per al nostre Sistema Operatiu. Observeu com en el cas de Linux hi ha moltes versions, per a moltes distribucions. I millor triar el paquet tgz , ja que amb descomprimir el fitxer ser\u00e0 suficient. En el cas d' Ubuntu 22.04 de 64 bits , aquest fitxer \u00e9s: https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu2204-8.0.5.tgz . Per\u00f2 recordeu que us heu d'assegurar de la versi\u00f3. 2- Descomprimirem aquest fitxer on vulguem, i ja estar\u00e0 feta la instal\u00b7laci\u00f3 b\u00e0sica. 3- Es necessari tindre un directori de dades per emmagatzemar la base de dades. Creem el directori de dades en el directori arrel (carpeta d'instal\u00b7laci\u00f3). mkdir data mkdir data/db 4- Arranquem el servidor: <directori arrel Mongo> /bin/mongod ./bin/mongod --dbpath ./data/db La seg\u00fcent imatge il\u00b7lustra aquesta segona opci\u00f3. Est\u00e0 per a una versi\u00f3 anterior de MongoDB, per\u00f2 \u00e9s totalment equivalent: Nota Una vegada en marxa el servidor, no hem de tancar aquesta terminal, ja que parar\u00edem el servidor. Pas 2. Instal\u00b7laci\u00f3 del client MongoShell (Linux) 1- De la p\u00e0gina de MongoDB ( https://www.mongodb.com/try/download/shell ) anem al men\u00fa Products - > Tools ->MongoDB Shell i ens baixem la versi\u00f3 apropiada per al nostre Sistema Operatiu. Observeu com en el cas de Linux hi ha moltes versions, per a moltes distribucions, i millor triar el paquet tgz , ja que amb descomprimir el fitxer ser\u00e0 suficient. En el cas d' Ubuntu 22.04 de 64 bits , triarem l'opi\u00f3 gen\u00e8rica Linux 64 ja que \u00e9s la opci\u00f3 que t\u00e9 el paquet tgz , i aquest fitxer \u00e9s: https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz . Per\u00f2 recordeu que us heu d'assegurar de la versi\u00f3. 2- Descomprimirem aquest fitxer on vulguem, i ja estar\u00e0 feta la instal\u00b7laci\u00f3 b\u00e0sica. 3- Per a connectar un client, obrim una segona terminal i executem el client mongosh : <directori arrel Mongosh>/bin/mongosh ./bin/mongosh \ud83d\udda5\ufe0fInstal\u00b7laci\u00f3 en Windows Pas 1. Instal\u00b7laci\u00f3 del servidor (Windows) 1- Ens baixem la versi\u00f3 apropiada de MongoDB per a Windows, que resultar\u00e0 ser un .msi directament executable. En el moment de fer aquestos apunts, la versi\u00f3 de 64 bits \u00e9s la 8.0.5: https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-8.0.5-signed.msi 2- Com en el cas de Linux, abans d'executar el servidor haurem de tenir el directori creat. Per defecte el directori ser\u00e0 \\data\\db 3- Aqueste serien les ordres per a crear el directori i despr\u00e9s arrancar el servidor. mkdir \\data\\db C:\\Program Files\\MongoDB\\Server\\8.0\\bin\\mongod.exe Hauria d'apar\u00e8ixer la imatge seg\u00fcent Nota Si vas instal\u00b7lar MongoDB amb el MongoDB MSI Installer, normalment el servei ja estar\u00e0 instal\u00b7lat i no caldr\u00e0 executar-lo. Pas 2. Instal\u00b7laci\u00f3 del client MongoShell (Windows) 1- Per a connectar-nos com a clients, ho haurem de fer des d'una altra terminal, amb mongosh.exe , que \u00e9s la interf\u00edcie de l\u00ednia d'ordres (CLI) oficial de MongoDB, utilitzada per interactuar amb la base de dades mitjan\u00e7ant ordres en JavaScript: Ens baixem la versi\u00f3 apropiada de MongoDB per a Windows https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz Mongo Compass Tamb\u00e9 us podeu descarregar la versi\u00f3 MongoDB Compass , que \u00e9s l'eina gr\u00e0fica oficial de MongoDB que permet visualitzar, explorar i administrar bases de dades de MongoDB sense necessitat d'utilitzar la l\u00ednia de comandos. https://downloads.mongodb.com/compass/mongodb-compass-1.45.3-win32-x64.exe 3.3 - Funcionament de MongoDB Recordeu que tindrem dues teminals: Una amb el servidor en marxa (i que no hem de tancar): mongod Una altra amb el client que es connecta al servidor: mongosh Probar el funcionament Per a provar el seu funcionament, anem a fer alguns comandos: Mostrar la versi\u00f3 del servidor MongoDB => db.version() Mostrar totes les bases de dades en el teu servidor MongoDB => show dbs Mostrar el nom de la BD del servidor MongoDB => db.getName() Mostrar totes les col\u00b7leccions en la base de dades seleccionada => show collections 3.4 - Utilitzaci\u00f3 de variables Com coment\u00e0vem el que m\u00e9s utilitzarem del llenguatge Javascript \u00e9s la utilitzaci\u00f3 de variables, que ens pot ser molt \u00fatil en algunes ocasions. Podrem utilitzar-les durant la sessi\u00f3, per\u00f2 evidentment no perduraran d'una sessi\u00f3 a l'altra. Per a definir una variable podem posar opcionalment davant la paraula reservada var , per\u00f2 no \u00e9s necessari. Posarem el nom de la variable, el signe igual, i a continuaci\u00f3 el valor de la variable, que pot ser una constant, o una expressi\u00f3 utilitzant constants, operadors, altres variables, funcions de Javascript, ... Especialment interessant s\u00f3n les variables que poden contenir un document JSON. Per exemple: > a = 30 30 > b = a/4 7.5 > Math.sqrt(b) 2.7386127875258306 > doc = {camp1: \"Hola\", camp2: 45, camp3: new Date()} { \"camp1\" : \"Hola\", \"camp2\" : 45, \"camp3\" : ISODate(\"2022-01-16T18:07:51.118Z\") } > Una variable de tipus JSON es podr\u00e0 modificar molt f\u00e0cilment, tota ella, o algun dels elements. Per a arribar als elements posarem nom_variable.nom_camp : > doc.camp4 = 3.141592 3.141592 > doc.camp5 = [ 2 , 4 , 6 , 8] [ 2, 4, 6, 8 ] I si ara intentem traure el contingut de la variable: > doc { \"camp1\" : \"Hola\", \"camp2\" : 45, \"camp3\" : ISODate(\"2022-01-16T18:07:51.118Z\"), \"camp4\" : 3.141592, \"camp5\" : [ 2, 4, 6, 8 ] } > Tamb\u00e9 hem de fer constar que en un document, que ser\u00e0 de tipus JSON (pr\u00e0cticament), ser\u00e0 un conjunt de parelles clau-valor, amb algunes restriccions: El document (que moltes vegades l'associarem a objecte de JSON) va entre claus ( { } ) Els elements d'un objecte van separats per comes, i s\u00f3n parelles clau-valor. La clau no pot ser nula, ni repetir-se en el mateix objecte (s\u00ed en diferents objectes, clar) Els valors s\u00f3n dels tipus que veurem en l'apartat seg\u00fcent. Un document guardat ha de contenir obligat\u00f2riament un camp anomenat _id , i que contindr\u00e0 un valor \u00fanic en la col\u00b7lecci\u00f3 i servir\u00e0 per a identificar-lo. Si en guardar un document no li hem posat camp _id , el generar\u00e0 autom\u00e0ticament MongoDB. 3.5 - Tipus de dades Els valors dels elements, \u00e9s a dir de les parelles clau valor, poden ser d'uns quants tipus. Fem un r\u00e0pid rep\u00e0s. En els exemples que van a continuaci\u00f3 definim senzillament parelles clau-valor dels diferents tipus, o en tot cas ens ho guardem en variables, per\u00f2 no guardarem encara en la Base de Dades (ho farem en la seg\u00fcent pregunta). Quan guardem en una variable es mostrar\u00e0 el prompt, la definici\u00f3 de la variable i despr\u00e9s el resultat d'haver guardat la variable. Utilitzarem requadres blancs. Els requadres grocs s\u00f3n \u00fanicament de la definici\u00f3 d'una clau-valor d'un determinat tipus NULL M\u00e9s que un tipus de dades \u00e9s un valor, millor dit, l'abs\u00e8ncia de valor { \"x\" : null } BOOLEAN El tipus boole\u00e0, que pot agafar els valors true o false. { \"x\" : true } { \"y\" : false } NUMBER Per defecte, el tiups de dades num\u00e8rics ser\u00e0 el de coma flotant ( float ), simple precisi\u00f3. Si volem un altre tiups (enter, doble precisi\u00f3, ...) ho haurem d'indicar expressament. Aix\u00ed els dos seg\u00fcents valors s\u00f3n float: { \"x\" : 3.14 } { \"y\" : 3 } Si volem que siga estrictament enter, per exemple, haurem d'utilitzar una funci\u00f3 de conversi\u00f3: { \"x\" : NumberDouble(\"3.14\") } { \"y\" : NumberInt(\"3\") } STRING Es pot guardar qualsevol cadena amb car\u00e0cters de la codificaci\u00f3 UTF-8 { x : \"Hola, qu\u00e8 tal?\"} DATE Es guarda data i hora, i internament es guarden en milisegons des de l'any inicial. No es guarda el Time zone , \u00e9s a dir, la desviaci\u00f3 respecte a l'hora internacional. { x : ISODate(\"2022-01-16T11:15:27.471Z\") } Normalment utilitzarem funcions de tractament de la data-hora. L'anterior era per a convertir el string en data-hora. La seg\u00fcent \u00e9s per a obtenir la data- hora actual: { x : new Date() } \u00c9s a dir, que si no posem par\u00e0metre, ens d\u00f3na la data-hora actual. Per\u00f2 li podem posar com a par\u00e0metre la data-hora que volem que genere. En aquest exemple, nom\u00e9s posem data, per tant l'hora ser\u00e0 les 00:00: > z = new Date(\"2022-01-16\") ISODate(\"2022-01-16T00:00:00Z\") En aquest s\u00ed que posem una determinada hora, i observeu com hem deposar la T (Time) entre el dia i l'hora: > z = new Date(\"2022-02-16T18:00\") ISODate(\"2022-01-16T18:00:00Z\") \u00c9s molt important que posem sempre New Date() per a generar una data-hora. Si posem \u00fanicament Date() , el que estem generant \u00e9s un string (segurament amb la data i hora actual, per\u00f2 un string): > z = Date(\"2022-01-16\") Sun Jan 16 2022 22:20:09 GMT+0100 (CET) ARRAY \u00c9s un conjunt d'elements, cadascun de qualsevol tipus, encara que el m\u00e9s habitual \u00e9s que siguen del mateix tipus. Van entre claud\u00e0tors ( [ ] ) i els elements separats per comes. { x : [ 2 , 4 , 6 , 8 ] } Com coment\u00e0vem, cada element de l'array pot ser de qualsevol tipus: { y : [ 2 , 3.14 , \"Hola\" , new Date() ] } En MongoDB podrem treballar molt b\u00e9 amb arrays, i tindrem operacions per a poder buscar dins de l'array, modificar un element, crear \u00edndex, ... DOCUMENTS (OBJECTES) Els documents poden contenir com a elements uns altres documents ( objectes en la terminologia JSON, per\u00f2 documents en la terminologia de MongoDB). Van entre claus ( { } ), i els elements que contindran van separats per comes i seran parelles clau-valor de qualsevol tipus (fins i tot altres documents). { x : { a : 1 , b : 2 } } Posar documents dins d'uns altres documents (el que s'anomena embedded document ) ens permet guardar la informaci\u00f3 d'una manera m\u00e9s real, no tan plana. Aix\u00ed per exemple, les dades d'una persona les podr\u00edem definir de la seg\u00fcent manera. Les posarem en una variable, per veure despr\u00e9s com podem accedir als diferents elements, encara que el m\u00e9s normal ser\u00e0 guardar-lo en la Base de Dades (amb insert() ). Si copiem el que va a continuaci\u00f3 al terminal de Mongo, ens apareixer\u00e0 amb un format estrany. \u00c9s perqu\u00e8 la sent\u00e8ncia d'assignaci\u00f3 a la variable ocupa m\u00e9s d'una l\u00ednia, i apareixeran 3 punts al principi per a indicar que continua la sent\u00e8ncia. Per\u00f2 funcionar\u00e0 perfectament : doc = { nom:\"Joan Mart\u00ed\", adre\u00e7a: { carrer:\"Major\", n\u00famero:1, poblaci\u00f3:\"Castell\u00f3\" } , tel\u00e8fons : [964223344,678345123] } Observeu com aquesta estructura que ha quedat tan clara, segurament en una Base de Dades Relacional ens hauria tocat guardar en 3 taules: la de persones, la d'adreces i la de tel\u00e8fons. Per a accedir als elements d'un document pos\u00e0vem el punt. Doncs el mateix per als elements d'un document dins d'un document. I tamb\u00e9 podem accedir als elements d'un array, posant l'\u00edndex entre claud\u00e0tors. > doc.nom Joan Mart\u00ed > doc.adre\u00e7a { \"carrer\" : \"Major\", \"n\u00famero\" : 1, \"poblaci\u00f3\" : \"Castell\u00f3\" } > doc.adre\u00e7a.carrer Major > doc.tel\u00e8fons [ 964223344, 678345123 ] > doc.tel\u00e8fons[0] 964223344 OBJECT ID \u00c9s un tipus que defineix MongoDB per a poder obtenir valors \u00fanics. \u00c9s el valor per defecte de l'element _id , necessari en tot document (atenci\u00f3: en un document, no en un element de tipus document que hem dit equivalent a l'objecte de JSON). \u00c9s un n\u00famero long, \u00e9s a dir que utilitza 24 bytes. Farem proves de la seua utilitzaci\u00f3 en la se\u00fcent pregunta, en el moment d'inserir diferents documents. 3.6 - Operacions CRUD B\u00e0siques En aquest punt anem a veure les operacions m\u00e9s b\u00e0siques, per a poder treballar sobre exemples pr\u00e0ctics, i aix\u00ed disposar ja d'unes dades inicials per a practicar. Creaci\u00f3: insert MongoDB proporciona els m\u00e8todes seg\u00fcents per inserir documents en una col\u00b7lecci\u00f3: db.collection. insertOne() db.collection. insertMany() La funci\u00f3 insert afegir\u00e0 documents a una col\u00b7lecci\u00f3. En el par\u00e0metre posem el document directament, o una variable que continga el document. Si la col\u00b7lecci\u00f3 no existia, la crear\u00e0 i despr\u00e9s afegir\u00e0 el document. En la seg\u00fcent sent\u00e8ncia estem treballant sobre la col\u00b7lecci\u00f3 exemple , que segurament ja existir\u00e0 de quan vam fer la pregunta 3.1 d'instal\u00b7laci\u00f3 de MongoDB, que per a provar vam inserir un document. Per\u00f2 si no existia, la crear\u00e0 sense problemes. > db.exemple.insertOne({ msg : \"Hola, qu\u00e8 tal?\"}) Acabem d'inserir un nou document, i aix\u00ed ens ho avisa ( { \"nInserted\" : 1 } , s'ha inserit un document). Autom\u00e0ticament haur\u00e0 creat un element _id de tipus ObjectId , ja que li fa falta per a identificar el document entre tots els altres de la col\u00b7lecci\u00f3. Insertem un altre document: > db.exemple.insertOne({ msg2 : \"Com va la cosa?\"}) I en aquest exemple ens guardem el document en la variable doc , i despr\u00e9s l'inserim > doc = { msg3 : \"Per ac\u00ed no ens podem queixar ...\"} > db.exemple.insertOne(doc) Tamb\u00e9 ens indica que ha inserit un document. I haur\u00e0 creat tamb\u00e9 el camp _id com veurem en el seg\u00fcent punt. Inserci\u00f3 especificant el id En els document que hem inserit fins el moment, no hem especificat el camp _id , i Mongo l'ha generat autom\u00e0ticament de tipus ObjectId . Per\u00f2 nosaltres podrem posar aquest camp _id amb el valor que vulguem. Aix\u00f2 s\u00ed, haurem d'estar segurs que aquest valor no l'agafa cap altre document de la col\u00b7lecci\u00f3, o ens donar\u00e0 un error. Aix\u00ed per exemple anem a inserir la informaci\u00f3 d'uns alumnes. Els posarem en una col\u00b7lecci\u00f3 nova anomenada alumnes , i els intentarem posar un _id personal. Per exemple posarem els n\u00fameros 51, 52, 53, ... > db.alumnes.insertOne ({_id: 51 , nom: \"Rebeca\" , cognoms: \"Mart\u00ed Peral\"}) Ha anat b\u00e9, i si mirem els documents que tenim en la col\u00b7lecci\u00f3, comprovarem que ens ha respectat el _id : > db.alumnes.find() { \"_id\" : 51, \"nom\" : \"Rebeca\", \"cognoms\" : \"Mart\u00ed Peral\" } Per\u00f2 si intentem inserir un altre document amb el mateix _id (51), ens donar\u00e0 error: > db.alumnes.insertOne ({_id: 51 , nom: \"Raquel\" , cognoms: \"Gomis Arnau\"}) WriteResult({ \"nInserted\" : 0, \"writeError\" : { \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error collection: test.alumnes index: _id_ dup key: { : 51.0 }\" } }) > Ens avisa que estem duplicant la clau principal , \u00e9s a dir l'identificador. Inserci\u00f3 m\u00faltiple Quan els documents que volem inserir s\u00f3n senzills, podem inserir m\u00e9s d'un a la vegada, posant dis del insertMany() un array amb tots els elements. En el seg\u00fcent exemple creem uns quants nombres primers en la col\u00b7lecci\u00f3 del mateix nom: > db.nombresprimers.insertMany( [ {_id:2} , {_id:3} , {_id:5} , {_id:7} , {_id:11} > , {_id:13} , {_id:17} , {_id:19} ] ) BulkWriteResult({ \"writeErrors\" : [ ], \"writeConcernErrors\" : [ ], \"nInserted\" : 8, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) > Ens avisa que ha fet 8 insercions, i ac\u00ed els tenim: > db.nombresprimers.find() { \"_id\" : 2 } { \"_id\" : 3 } { \"_id\" : 5 } { \"_id\" : 7 } { \"_id\" : 11 } { \"_id\" : 13 } { \"_id\" : 17 } { \"_id\" : 19 } > Lectura: find MongoDB ofereix els m\u00e8todes seg\u00fcents per llegir documents d'una col\u00b7lecci\u00f3: db.collection. find() recuperar\u00e0 tots els documents de la col\u00b7lecci\u00f3, encara que podrem posar criteris per a que ens torne tots els documents que acomplesquen aquestos criteris (ho veurem m\u00e9s avant). Exemple: > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Com va la cosa?\" } { \"_id\" : ObjectId(\"56ce3237c61e04ba81def50d\"), \"msg3\" : \"Per ac\u00ed no ens podem queixar ...\" } > En tots els casos podem comprovar que \u00e9s cert el que ven\u00edem afirmant, que ha creat autom\u00e0ticament l'element _id per a cada document guardat. Evidentment, cadasc\u00fa de nosaltres tindr\u00e0 una valors diferents. Eliminaci\u00f3: delete Per a esborrar un document d 'una col\u00b7lecci\u00f3 utilitzarem la funci\u00f3 deleteOne , passant-li com a par\u00e0metre la condici\u00f3 del document o documents a esborrar. MongoDB ofereix els m\u00e8todes seg\u00fcents per eliminar documents d'una col\u00b7lecci\u00f3: db.collection. deleteOne() db.collection. deleteMany() > db.nombresprimers.deleteOne( {\"_id\" : 19} ) Ens avisa que ha esborrat un document. La condici\u00f3 no cal que siga sobre el camp _id . Pot ser sobre qualsevol camp, i esborrar\u00e0 tots els que coincideixen . > db.exemple.deleteMany( {\"msg3\" : \"Per ac\u00ed no ens podem queixar ...\"} ) Tamb\u00e9 tenim la possibilitat d'esborrar tota una col\u00b7lecci\u00f3 amb la funci\u00f3 drop() . Pareu atenci\u00f3 perqu\u00e8 \u00e9s molt senzilla d'eliminar, i per tant, potencialment molt perillosa. > db.nombresprimers.drop() true > Actualitzaci\u00f3 - update La funci\u00f3 update servir\u00e0 per a actualitzar un document ja guardat. Tindr\u00e0 dos par\u00e0metres: El primer par\u00e0metre ser\u00e0 la condici\u00f3 per a trobar el document que s'ha d'actualitzar. El segon par\u00e0metre ser\u00e0 el nou document que substituir\u00e0 l'anterior MongoDB ofereix els m\u00e8todes seg\u00fcents per actualitzar els documents d'una col\u00b7lecci\u00f3: db.collection. updateOne() db.collection. updateMany() db.collection. replaceOne() Per exemple, si mirem les dades actuals: > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Com va la cosa?\" } Podem comprovar el contingut del segon document, el que te msg2 . Anem a modificar-lo: en el primer par\u00e0metre posem condici\u00f3 de recerca (nom\u00e9s hi haur\u00e0 un) i en el segon posem el nou document que substituir\u00e0 l'anterior amb el par\u00e0metre $set . > db.exemple.updateOne( {msg2:\"Com va la cosa?\"} , {$set: {msg2:\"Qu\u00e8? Com va la cosa?\"}}) Observeu que la contestaci\u00f3 del update () \u00e9s que ha fet match (hi ha hagut coincid\u00e8ncia) amb un document, i que ha modificat un. Si no en troba cap, no donar\u00e0 error, senzillament dir\u00e0 que ha fet match amb 0 documents, i que ha modificat 0 documents. Mirem com efectivament ha canviat el segon document > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Qu\u00e8? Com va la cosa?\" } Ens vindran molt b\u00e9 les variables per a les actualitzacions, ja que en moltes ocasions ser\u00e0 modificar lleugerament el document, canviant o afegint algun element. Ho podrem fer c\u00f2modament amb la variable: primer guardem el document a modificar en una variable; despr\u00e9s modifiquem la variable; i per \u00faltim fem l'operaci\u00f3 d'actualitzaci\u00f3. Evidentment si tenim alguna variable amb el contingut del document ens podr\u00edem estalviar el primer pas. > doc1 = db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } > doc1.titol = \"Missatge 1\" Missatge 1 > db.exemple.updateOne( {msg:\"Hola, qu\u00e8 tal?\"} , doc1) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.exemple.findOne() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\", \"titol\" : \"Missatge 1\" } > Reempla\u00e7ar un document Per reempla\u00e7ar tot el contingut d'un document excepte el _id, passeu un document completament nou com a segon argument a Collection. replaceOne() . En reempla\u00e7ar un document, aquest ha de constar \u00fanicament de parells camp-valor. No podeu incloure expressions d'operadors d'actualitzaci\u00f3. El document de substituci\u00f3 pot tenir camps diferents dels del document original. Al document de reempla\u00e7ament, podeu ometre el _id, ja que _id es immutable. No obstant aix\u00f2, si l'inclou _id, heu de tenir el mateix valor que l'actual. db.exemple.replaceOne( { \"msg\" : \"Hola, qu\u00e8 tal?\" }, { \"msg\" : \"Hola, qu\u00e8 tal?\" , \"titol2\" : \"Missatge 2\" } ) 3.7 - Operadors d'actualitzaci\u00f3 En el apartat anterior hem vist l'actualitzaci\u00f3 de documents ja existents a la Base de Dades. Aquesta actualitzaci\u00f3 la f\u00e9iem modificant tot el document, encara que tenim la variant de guardar el document en una variable, modificar aquesta variable i despr\u00e9s fer l'actualitzaci\u00f3 amb aquesta variable. Per\u00f2 observeu que continua sent una modificaci\u00f3 de tot el document, una substituci\u00f3 del document antic per un document nou. En aquest apartat veurem la utilitzaci\u00f3 d'uns modificadors ( modifiers ) de l'operaci\u00f3 update() , que ens permetran modificar documents de forma potent: creant i eliminant claus (elements) d'un document, o canviant-los, i fins i tot afegir o eliminar elements d'un array. $set El modificador $set assigna un valor a un camp del document seleccionat de la Base de Dades. Si el camp ja existia, modificar\u00e0 el valor, i si no existia el crear\u00e0. La sintaxi del modificador $set \u00e9s la seg\u00fcent: { $set : { clau : valor} } Per\u00f2 recordeu que \u00e9s un modificador, i l'hem d'utilitzar dins d'una operaci\u00f3 d'actualitzaci\u00f3. Anir\u00e0 en el segon par\u00e0metre del update() , i per tant amb aquestos modificadors ja no posem tot el document en el segon par\u00e0metre, sin\u00f3 \u00fanicament l'operador de modificaci\u00f3. Mirem-ho millor en un exemple: > db.alumnes.insertOne( {nom:\"Abel\", cognoms:\"Bernat Carrera\"} ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\" } > Suposem ara que li volem afegir l'edat. Abans ho far\u00edem guardant el document en una variable, i afegint el camp, per a guardar despr\u00e9s. Ara ho tenim m\u00e9s f\u00e0cil: > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {edat:21} } ) Ha trobat un, i l'ha modificat. Evidentment, si hi haguera m\u00e9s d'un alumne a mb el nom Abel, els modificaria tots. > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 21 } Es pot especificar m\u00e9s d'un camp amb els valor corresponents. Si no existien es crearan, i si ja existien es modificaran: > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {nota: 8.5 , edat:22} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : 8.5 } I fins i tot es pot canviar el tipus d'un camp determinat, i utilitzar arrays, i objectes, ... > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {nota: [8.5,7.5,9], adre\u00e7a:{carrer:\"Major\",numero:7,cp:\"12001\"} } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12001\" } } Podem fins i tot modificar ara nom\u00e9s el valor d'un camp d'un objecte del document. Per exemple, anem a modificar el codi postal de l'anterior alumne. La manera d'arribar al codi postal ser\u00e0 adre\u00e7a.cp , per\u00f2 haurem d'anar amb compte que vaja entre cometes per a que el trobe: > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {adre\u00e7a.cp:\"12502\"} } ) uncaught exception: SyntaxError: missing : after property id : @(shell):1:49 > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {\"adre\u00e7a.cp\":\"12502\"} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" } } $unset El modificador $unset servir\u00e0 per a eliminar elements (camps) d'un o uns documents. Si el camp existia, l'eliminar\u00e0, i si no existia, no donar\u00e0 error (avisar\u00e0 que s'han modificat 0 documents). La sintaxi \u00e9s: { $unset : {camp : 1 } } Haurem de posar un valor al camp que anem a esborrar per a mantenir la sintaxi correcta, i posem 1 que equival a true. Tamb\u00e9 podr\u00edem posar -1, que equival a false, per\u00f2 aleshores no l'esborraria, i per tant no far\u00edem res. Sempre posarem 1. Mirem el seg\u00fcent exemple. Afegim un camp, que ser\u00e0 el n\u00famero d'ordre, i despr\u00e9s el llevarem. > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {num_ordre:10} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"num_ordre\" : 10 } > db.alumnes.updateOne( {nom:\"Abel\"} , { $unset: {num_ordre:1} } ) > db.alumnes.updateOne( {nom:\"Abel\"} , { $unset: {puntuacio:1} } ) Hem afegit primer el camp num_ordre , i hem mostrat el document per comprovar que existeix. Despr\u00e9s esborrem el camp num_ordre (i ens confirma que ha modificat un document). Despr\u00e9s intentem esborrar un camp que no existeix, puntuacio . No d\u00f3na error, per\u00f2 ens avisa que ha modificat 0 documents. Podem comprovar al final com el document ha quedat com esper\u00e0vem. > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" } } $rename El modificador $rename canviar\u00e0 el nom d'un camp. Si no existia, no donar\u00e0 error i senzillament no el modificar\u00e0. Hem de cuidar de posar el nou nom del camp entre cometes, per a que no done error. La sintaxi \u00e9s: { $rename : { camp1 : \"nou_nom1\" , camp2 : \"nou_nom2\" , ... } } Per exemple, canviem el nom del camp nota a notes : > db.alumnes.updateOne( {nom:\"Abel\"} , { $rename: {nota:\"notes\"} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"notes\" : [ 8.5, 7.5, 9 ] } Observeu que l'ha canviat de lloc, cosa que ens fa pensar que en canviar de nom un camp, el que fa \u00e9s tornar a crear-lo amb el nou nom, i esborrar el camp antic. En aquest exemple tornem a canviar el nom a nota , i intentem canviar el nom a un camp inexistent, camp1 . No donar\u00e0 error. > db.alumnes.updateOne( {nom:\"Abel\"} , { $rename: {camp1: \"camp2\" , notes:\"nota\"} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 8.5, 7.5, 9 ] } $inc Com cabria esperar, el modificador $inc servir\u00e0 per a incrementar un camp num\u00e8ric. Si el camp existia, l'incrementar\u00e0 en la quantitat indicada. Si no existia, crear\u00e0 el camp amb un valor inicial de 0, i incrementar\u00e0 el valor amb la quantitat indicada. La quantitat pot ser positiva, negativa o fins i tot amb part fraccion\u00e0ria. Sempre funcionar\u00e0 b\u00e9, excepte quan el camp a incrementar no siga num\u00e8ric, que donar\u00e0 error. La sintaxi \u00e9s aquesta: { $inc : {camp : quantitat } } En els seg\u00fcents exemples, incrementem un camp nou (per tant el crear\u00e0 amb el valor especificat), i despr\u00e9s l'incrementem en quantitats positives, negatives i fraccion\u00e0ries, concretament l'inicialitzem amb un 2 , i desp\u00e9s l'incrementem en 5 , en -4 i en 2.25 , per tant el resultat final ser\u00e0 5.25 : > db.alumnes.updateOne( {nom:\"Abel\"} , { $inc: {puntuacio:2} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"puntuacio\" : 2 } > db.alumnes.updateOne( {nom:\"Abel\"} , { $inc: {puntuacio:5} } ) > db.alumnes.updateOne( {nom:\"Abel\"} , { $inc: {puntuacio:-4} } ) > db.alumnes.updateOne( {nom:\"Abel\"} , { $inc: {puntuacio:2.25} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"puntuacio\" : 5.25 } $min Actualitza el valor del camp a un valor especificat si aquest \u00e9s menor que el valor actual del camp. db.alumnes..updateOne( { nom:\"Abel\"}, { $min: { puntuacio: 1 } } ) El valor de puntuaci\u00f3 s'actualitza a 1 perqu\u00e8 \u00e9s menor que el valor actual de 5. $max Actualitza el valor del camp a un valor especificat si aquest \u00e9s major que el valor actual del camp. db.alumnes..updateOne( { nom:\"Abel\"}, { $max: { puntuacio: 7 } } ) El valor de puntuaci\u00f3 s'actualitza a 7 perqu\u00e8 \u00e9s menor que el valor actual de 1. $mul Multiplica el valor d'un camp per un n\u00famero., $currentDate db.alumnes.updateOne({ nom:\"Abel\"},{ $mul: {puntuacio: 2}}) L'operador $mul multiiplica el camp puntuaci\u00f3 per 2. Arrays Per a accedir directament a un element d'un array d'un determinat document es pot utilitzar la seg\u00fcent sintaxi: \"array.index\" Hem de tenir present que el primer element de l'array \u00e9s el de sub\u00edndex 0. I no us oblideu de tancar-ho tot entre comentes per a que ho puga trobar. Si no existeix l'element amb el sub\u00edndex indicat, donar\u00e0 error. Per exemple, anem a pujar un punt la primera nota de l'alumne que estem utilitzant en tots els exemples : >db.alumnes.updateOne( {nom:\"Abel\"} , { $inc : { \"nota.0\" : 1 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9 ] } Actualitzaci\u00f3: $ y $[] $ Identifica un element en un array per actualitzar sense especificar expl\u00edcitament la posici\u00f3 de l'element en un array. Ejemplo: Modificar la primera nota mayor a 8 en el array nota db.alumnes.updateOne( { \"_id\": ObjectId(\"56df11d778549bdfbf2125e3\"), \"nota\": { $gt: 8 } }, { $set: { \"nota.$\": 10 } } ) $[] L'operador $[] es fa servir per actualitzar tots els elements en un array. Ejemplo: Aumentar en 1 punto todas las notas en el array nota db.alumnes.updateOne( { \"_id\": ObjectId(\"56df11d778549bdfbf2125e3\") }, { $inc: { \"nota.$[]\": 1 } } ) Inserci\u00f3: $push La manera m\u00e9s senzilla d'introduir un element en un array \u00e9s utilitzar $push sense m\u00e9s. Si existia l'array, introduir\u00e0 el o els nous elements al final. Si no existia l'array, el crear\u00e0 amb aquest o aquestos elements. La sintaxi \u00e9s: { $push : { clau : element } } Per exemple anem a afegir una nota a l'alumne de sempre, i posem-la diferent per veure que s'introdueix al final: > db.alumnes.updateOne( {nom:\"Abel\"} , { $push : { nota : 7 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9, 7 ] } Tamb\u00e9 hi ha manera d'introduir un element en una determinada posici\u00f3 que no siga al final, per\u00f2 es complica prou la cosa, ja que hem d'utilitzar per una banda el modificador $position per a dir on s'ha d'inserir, i per una altra banda el modificador $each per a poder especificar el o els valors que es volen inserir. Es posa a continuaci\u00f3 \u00fanicament de forma il\u00b7lustrativa. Per a inserir en una determinada posici\u00f3 hem d'utilitzar obligat\u00f2riament 2 modificadors m\u00e9s: $position indicar\u00e0 a partir de quina posici\u00f3 es far\u00e0 l'acci\u00f3 (normalment d'inserir en l'array, \u00e9s a dir, $push ) $each ens permet especificar una s\u00e8rie de valors com un array, i vol dir que es far\u00e0 l'operaci\u00f3 per a cada valor de l'array Els dos modificadors seguiran la sintaxi de sempre, de clau valor, per tant el conjunt de la sintaxi \u00e9s: { $ push : { clau_del_array : { $position : _posici\u00f3_ , $each : [ _valors_ ] } } } Ac\u00ed tenim un exemple on introdu\u00efm una nota en la primera posici\u00f3: > db.alumnes.updateOne( {nom:\"Abel\"} , { $push : { nota : { $position : 0 , $each > : [5] } } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9, 7 ] } Eliminaci\u00f3: $pop i $pull Hi ha m\u00e9s d'una manera d'eliminar elements d'un array. $pop Si volem eliminar el primer element o l'\u00faltim, el modificador adequat \u00e9s $pop . La sintaxi \u00e9s { $pop : { clau : posicio } } On en posici\u00f3 podrem posar: -1 , i esborrar\u00e0 el primer element 1 , i esborrar\u00e0 l'\u00faltim En els seg\u00fcents exemples s'esborren primer l'\u00faltim element i despr\u00e9s el primer. > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9, 7 ] } > db.alumnes.updateOne( {nom:\"Abel\"} , { $pop : { nota : 1 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9 ] } > db.alumnes.updateOne( {nom:\"Abel\"} , { $pop : { nota : -1 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9 ] } $pull Amb aquest modificador esborrarem els elements de l'array que coincidesquen amb una condici\u00f3, estiguen en la posici\u00f3 que estiguem. Observeu com es pot eliminar m\u00e9s d'un element. Per a poder comprovar-lo b\u00e9, primer inserim un altre element al final de l'array, amb el valor 7.5 (si heu seguit els mateixos exemples que en aquestos apunts, aquest valor ja es troba en la segona posici\u00f3). > db.alumnes.updateOne( {nom:\"Abel\"} , { $push : { nota : 7.5 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9, 7.5 ] } Ara anem a esborrar amb $pull l'element de valor 7.5 > db.alumnes.update( {nom:\"Abel\"} , { $pull : { nota : 7.5 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } 3.8 - Operadors de consulta En la pregunta anterior hem vist com introduir, eliminar i modificar documents. Les consultes de documents han segut molt senzilles, per a comprovar \u00fanicament els resultats. En aquesta pregunta veurem en profunditat la consulta de documents. Funcion find() . Veurem en profunditat la seua sintaxi i pot\u00e8ncia. Limitarem i ordenarem tamb\u00e9 els resultats Fins i tot podrem elaborar m\u00e9s els resultats, agrupant els resultats, utilitzant funcions d'agregaci\u00f3 (o millor dir operadors d'agregaci\u00f3) i donant-los un aspecte diferent Par\u00e0metres de find() La funci\u00f3 find() s'ha comparat tradicionalment amb la sent\u00e8ncia SELECT de SQL. Sempre tornar\u00e0 un conjunt de documents, que poden variar des de no tornar cap document, a tornar-los tots els de la col\u00b7lecci\u00f3. La funci\u00f3 find() pot tenir uns quants par\u00e0metres. El primer indica una condici\u00f3 o criteri, i tornar\u00e0 aquells documents de la col\u00b7lecci\u00f3 que acomplisquen la condici\u00f3 o criteri. Aquesta condici\u00f3 ve donada en forma de document (o objecte) JSON, i \u00e9s com l'hav\u00edem vist en la funci\u00f3 update() : db.col_leccio1.find( { clau1 : valor1 } ) Tornar\u00e0 tots els documents de la col\u00b7lecci\u00f3 col_leccio1 que tinguen el camp clau1 i que en ell tinguen el valor valor1 . Aquest criteri pot ser el complicat que fa\u00e7a falta, formant-lo en JSON. Pot tenir m\u00e9s d'un membre. En definitiva, tornar\u00e0 aquells documents que facen matching amb el document del criteri, \u00e9s a dir, funcionaria com un and en cas que tinga m\u00e9s d'un membre en la condici\u00f3 db.col_leccio1.find( { clau1 : valor1 , clau2 : valor2 } ) que tornaria aquells documents de la col_lecci\u00f31 que tenen el camp clau1 amb el valor valor1 i que tenen el camp clau2 amb el valor valor2 Si no volem posar cap criteri, per a que els torne tots, no posem res com a par\u00e0metre, o encara millor, li passem un document (objecte) buit, de manera que tots els documents de la col\u00b7lecci\u00f3 faran matching amb ell. db.col_leccio1.find( { } ) El segon par\u00e0metre ens servir\u00e0 per a delimitar els camps dels documents que es tornaran. Tamb\u00e9 tindr\u00e0 el format JSON d'un objecte al qual li posarem com a claus els diferents camps que volem que apareguen o no, i com a valor 1 per a que s\u00ed que apareguen i 0 per a que no apareguen. Si posem algun camp a que s\u00ed que aparega (\u00e9s a dir, amb el valor 1), els \u00fanics que apareixeran seran aquestos, a m\u00e9s del _id que per defecte sempre apareix. > db.alumnes.find({},{nom:1}) { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\" } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\" } Per tant si no volem que aparega _id posarem: > db.alumnes.find({},{_id:0}) { \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : {\"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } I si volem traure \u00fanicament el nom: > db.alumnes.find({},{nom:1,_id:0}) { \"nom\" : \"Abel\" } { \"nom\" : \"Berta\" } Per \u00faltim, com que a partir d'ara utilitzarem documents m\u00e9s complicats, si volem que ens apareguen els camps que retornem d'una forma un poc m\u00e9s elegant o bonica ( pretty ), posarem aquesta funci\u00f3 al final: find().pretty() > db.alumnes.find().pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } Operadors Abans de comen\u00e7ar aquesta pregunta, anem a agafar unes dades de prova, que estan en el fitxer libros_ejemplo.json Nom\u00e9s heu de copiar el contingut del fitxer en la terminal del client de Mongo. Posem ac\u00ed el contingut per a que pugueu pegar-li una miradeta sense necessitat d'obrir-lo. Anir\u00e0 b\u00e9 per als exemples posteriors. db.libro.insertOne({ \"_id\":\"9788408117117\", \"titulo\":\"Circo M\u00e1ximo\", \"autor\":\"Santiago Posteguillo\", \"editorial\":\"Planeta\", \"enstock\":true, \"paginas\":1100, \"precio\":21.75, \"fecha\":new ISODate(\"2013-08-29T00:00:00Z\"), \"resumen\":\"Circo M\u00e1ximo, de Santiago Posteguillo, que ha escrito otras obras de narrativa hist\u00f3rica como Las Legiones Malditas o La traici\u00f3n de Roma, es la segunda parte de la trilog\u00eda de Trajano, que comenz\u00f3 con Los asesinos del emperador, un relato impactante, descomunal, descrito con un trepidante pulso narrativo destinado a trasla dar al lector a la Roma imperial de los c\u00e9sares. Santiago posteguillo se ha convertido en el autor espa\u00f1ol de referencia de la novela hist\u00f3rica sobre Roma y el mundo antiguo. Bienvenidos al mundo de Marco Ulpio Trajano. Circo M\u00e1ximo es la historia de Trajano y su gobierno, guerras y traiciones, lealtades insobornables e historias de amor imposibles. Hay una vestal, un juicio, inocentes acusados, un abogado especial, mensajes cifrados, c\u00f3digos secretos, batallas campales, fortalezas inexpugnables, asedios sin fin, dos aurigas rivales, el Anfiteatro, los gladiadores y tres carreras de cuadrigas. Hay tambi\u00e9n un caballo especial, diferente a todos, leyes antiguas olvidadas, sacrificios humanos, amargura y terror, pero tambi\u00e9n destellos de nobleza y esperanza, como la llama de Vesta, que mientras arde preserva a Roma. S\u00f3lo que hay noches en las que la llama del Templo de Vesta tiembla. La rueda de la Fortuna comienza entonces a girar. En esos momentos, todo puede pasar y hasta la vida del propio Trajano, aunque \u00e9l no lo sepa, corre peligro. Y, esto es lo mejor de todo, ocurri\u00f3: hubo un complot para asesinar a Marco Ulpio Trajano.\" }) db.libro.insertOne({ \"_id\":\"9788401342158\", \"titulo\":\"El juego de Ripper\", \"autor\":\"Isabel Allende\", \"editorial\":\"Plaza & Janes\", \"enstock\":true, \"paginas\":480, \"precio\":21.75, \"fecha\":new ISODate(\"2014-03-01T00:00:00Z\"), \"resumen\":\"Tal como predijo la astr\u00f3loga m\u00e1s reputada de San Francisco, una oleada de cr\u00edmenes comienza a sacudir la ciudad. En la investigaci\u00f3n sobre los asesinatos, el inspector Bob Mart\u00edn recibir\u00e1 la ayuda inesperada de un grupo de internautas especializados en juegos de rol, Ripper. 'Mi madre todav\u00eda est\u00e1 viva, pero la matar\u00e1 el Viernes Santo a medianoche', le advirti\u00f3 Amanda Mart\u00edn al inspector jefe y \u00e9ste no lo puso en duda, porque la chica hab\u00eda dado pruebas de saber m\u00e1s que \u00e9l y todos sus colegas del Departamento de Homicidios. La mujer estaba cautiva en alg\u00fan punto de los dieciocho mil kil\u00f3metros cuadrados de la bah\u00eda de San Francisco, ten\u00edan pocas horas para encontrarla con vida y \u00e9l no sab\u00eda por d\u00f3nde empezar a buscarla\", }) db.libro.insertOne({ \"_id\":\"9788496208919\", \"titulo\":\"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"autor\":\"George R.R. Martin\", \"editorial\":\"Gigamesh\", \"enstock\":true, \"paginas\":793, \"precio\":9.5, \"fecha\":new ISODate(\"2011-11-24T00:00:00Z\"), \"resumen\":\"Tras el largo verano, el invierno se acerca a los Siete Reinos. Lord Eddars Stark, se\u00f1or de Invernalia, deja sus dominios para unirse a la corte del rey Robert Baratheon el Usurpador, hombre d\u00edscolo y otrora guerrero audaz cuyas mayores aficiones son comer, beber y engendrar bastardos. Eddard Stark desempe\u00f1ar\u00e1 el cargo de M ano del Rey e intentar\u00e1 desentra\u00f1ar una mara\u00f1a de intrigas que pondr\u00e1 en peligro su vida... y la de los suyos. En un mundo cuyas estaciones duran d\u00e9cadas y en el que retazos de una magia inmemorial y olvidada surgen en los rincones m\u00e1s sombrios y maravillosos, la traici\u00f3n y la lealtad, la compasi\u00f3n y la sed de venganza, el amor y el poder hacen del juego de tronos una poderosa trampa que atrapa en sus fauces a los personajes... y al lector. 'El regreso triunfal de Martin a la fantas\u00eda de m\u00e1s alta calidad... con personajes desarrollados con maestr\u00eda, prosa h\u00e1bil y pura obstinaci\u00f3n.'\" }) db.libro.insertOne({ \"_id\":\"9788499088075\", \"titulo\":\"La ladrona de libros\", \"autor\":\"Markus Zusak\", \"editorial\":\"Debolsillo\", \"enstock\":false, \"paginas\":544, \"precio\":9.45, \"fecha\":new ISODate(\"2009-01-09T00:00:00Z\"), \"resumen\":\"En plena II Guerra Mundial, la peque\u00f1a Liesel hallar\u00e1 su salvaci\u00f3n en la lectura. Una novela preciosa, tremendamente humana y emocionante, que describe las peripecias de una ni\u00f1a alemana de nueve a\u00f1os desde que es dada en adopci\u00f3n por su madre hasta el final de la guerra. Su nueva familia, gente sencilla y nada afecta al na zismo, le ense\u00f1a a leer y a trav\u00e9s de los libros Rudy logra distraerse durante los bombardeos y combatir la tristeza. Pero es el libro que ella misma est\u00e1 escribiendo el que finalmente le salvar\u00e1 la vida.\", }) db.libro.insertOne({ \"_id\":\"9788415140054\", \"titulo\":\"La princesa de hielo\", \"autor\":\"Camilla Lackberg\", \"editorial\":\"Embolsillo\", \"enstock\":true, \"precio\":11, \"fecha\":new ISODate(\"2012-10-30T00:00:00Z\"), \"resumen\":\"Misterio y secretos familiares en una emocionante novela de suspense Erica vuelve a su pueblo natal tras el fallecimiento de sus padres, pero se va a encontrar con un nuevo drama. Aparentemente su amiga de la infancia, Alex, se ha suicidado. Pronto se descubre que no solamente fue asesinada sino que estaba embarazada. El primer sospechoso es Anders, un artista fracasado con quien Alex manten\u00eda una relaci\u00f3n especial. Pero poco despu\u00e9s de ser liberado por falta de pruebas, Anders aparece muerto en su domicilio. Con la ayuda del comisario Patrik, Erica investigar\u00e1 el pasado de su amiga Alex.\" }) db.libro.insertOne({ \"_id\":\"9788408113331\", \"titulo\":\"Las carreras de Escorpio\", \"autor\":\"Maggie Stiefvater\", \"editorial\":\"Planeta\", \"enstock\":false, \"paginas\":290, \"precio\":17.23, \"fecha\":new ISODate(\"2013-06-04T00:00:00Z\"), \"resumen\":\"En la peque\u00f1a isla de Thisby, cada noviembre los caballos de agua de la mitolog\u00eda celta emergen del mar. Y cada noviembre, los hombres los capturan para participar en una emocionante carrera mortal. En las carreras de Escorpio, algunos compiten para ganar. Otros para sobrevivir. Los jinetes intentan dominar a sus caballos de agua el tiempo suficiente para acabar la carrera. Algunos lo consiguen. El resto, muere en el intento. Sean Kendrick es el favorito, y necesita ganar la carrera para ganar, tambi\u00e9n, su libertad. Pero Puck Connolly est\u00e1 dispuesta a ser su m\u00e1s dura adversaria. Ella nunca quiso participar en las carreras. Pero no tiene elecci\u00f3n: o compite y gana o\u2026 lo pierde todo.\", }) db.libro.insertOne({ \"_id\":\"9788468738895\", \"titulo\":\"Las reglas del juego\", \"autor\":\"Anna Casanovas\", \"enstock\":true, \"paginas\":null, \"precio\":15.90, \"fecha\":new ISODate(\"2014-02-06T00:00:00Z\"), \"resumen\":\"Susana Lobato tiene la vida perfectamente planeada y est\u00e1 a punto de conseguir todo lo que quiere: va a tener su propio programa de noticias econ\u00f3micas y en dos meses va a casarse con un hombre maravilloso. Pero una noche Tim anula la boda y la abandona para perseguir un sue\u00f1o que no la incluye a ella.Kev MacMurray acaba de cumplir treinta y cinco a\u00f1os y siente que ha llegado el momento de dar un cambio a su vida. No sabe por qu\u00e9, pero \u00faltimamente se est\u00e1 asfixiando y est\u00e1 convencido de que no puede seguir donde est\u00e1. Lo \u00fanico que lo retiene es la boda de Tim, su mejor amigo.Pero Tim anula la boda y una noche Kev coincide con Susana y respira por primera vez en mucho tiempo.\u00bfPor qu\u00e9 no le hab\u00eda sucedido antes? Se supon\u00eda que \u00e9l y Susana no se soportaban \u00bfDesde cu\u00e1ndo siente que si no besa a la prometida de su mejor amigo no podr\u00e1 seguir respirando?Susana nunca hab\u00eda reaccionado as\u00ed con nadie. \u00bfPuede correr el riesgo de averiguar qu\u00e9 pasar\u00e1 si se entrega a Kev?Y qu\u00e9 pasar\u00e1 si vuelve Tim, \u00bfpodr\u00e1n dar un paso atr\u00e1s?.\", }) Podeu comprovar que hi ha 7 documents en la nova col\u00b7lecci\u00f3 libro : > db.libro.count() 7 I tamb\u00e9 podem consultar els t\u00edtols de forma c\u00f2moda: > db.libro.find( {} , {titulo:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\" } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } I un altre exemple, on consultem els llibres que estan en stock (hi ha un camp boole\u00e0 que ho diu: enstock ), mostrant t\u00edtol, editorial i preu > db.libro.find( {enstock: true} , {titulo:1 , editorial:1 , precio:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } I un \u00faltim exemple, on consultem els llibres que estan en stock i tenen un preu de 21.75 \u20ac, mostrant tot excepte el _id i el resum > db.libro.find( {enstock: true , precio: 21.75} , {titulo:1 , editorial:1 , > precio:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } Anem a mirar ara operadors que ens serviran per fer millor les consultes. Operadors de comparaci\u00f3 Fins ara en totes les condicions hem utilitzat la igualtat, si un determinat camp era igual a un determinat valor. Per\u00f2 hi ha infinitat de consultes en les quals voldrem altres operacions de comparaci\u00f3: major, major o igual, menor, ... Aquestos s\u00f3n els operadors de comparaci\u00f3: $lt ( less than ) menor $lte ( less than or equal ) menor o igual $gt ( gretaer than ) major $gte ( gretaer than or equal ) major o igual $ne ( not equal ) distint $eq ( equal ) igual (per\u00f2 aquest quasi que no caldria, perqu\u00e8 en no posar res es refereix a la igualtat com fins ara) La sintaxi per a la seua utilitzaci\u00f3 \u00e9s, com sempre, acoplar-se a la sintaxi JSON: clau : { $operador : valor [, ... ] } Aix\u00ed per exemple, per a buscar els llibres de m\u00e9s de 10 \u20ac: > db.libro.find( { precio : { $gt : 10 } } , { titulo:1 , precio:1 } ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"precio\" : 21.75 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } I per a buscar els llibres entre 10 i 20 \u20ac: > db.libro.find( { precio : { $gt : 10 , $lt:20 } } , { titulo:1 , precio:1 }) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9} \u00c9s especialment \u00fatil per a les dates, ja que dif\u00edcilment trobarem una data (i hora) exacta, i voldrem quasi sempre els documents anteriors a una data, o posteriors, o entre dues dates. Haurem d'anar amb compte pel tractament especial de les dates: hem de comparar coses del mateix tipus, i per tant la data amb la qual volem comparar l'haurem de tenir en forma de data: > var d = new ISODate(\"2013-01-01T00:00:00Z\") > db.libro.find( {fecha:{$gte:d} } , {fecha:1} ) { \"_id\" : \"9788408117117\", \"fecha\" : ISODate(\"2013-08-29T00:00:00Z\") } { \"_id\" : \"9788401342158\", \"fecha\" : ISODate(\"2014-03-01T00:00:00Z\") } { \"_id\" : \"9788408113331\", \"fecha\" : ISODate(\"2013-06-04T00:00:00Z\") } { \"_id\" : \"9788468738895\", \"fecha\" : ISODate(\"2014-02-06T00:00:00Z\") } $in Servir\u00e0 per a comprovar si el valor d'un camp est\u00e0 entre els d'una llista, proporcionada com un array. La sitaxi \u00e9s: clau : { $in : [valor1 , valor2 , ... , valorN] } I ac\u00ed tenim un exemple, els llibre de les editorials Planeta i Debolsillo: > db.libro.find( { editorial: {$in : [\"Planeta\" , \"Debolsillo\"]} } , {titulo: , editorial:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\"} { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\" } $nin \u00c9s el contrari, traura els que no estan en la llista. > db.libro.find( { editorial: {$nin : [\"Planeta\" , \"Debolsillo\"]} } , {titulo:1 , editorial:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Observeu com tamb\u00e9 trau els llibres que no tenen editorial, com \u00e9s el cas de l'\u00faltim llibre, Las reglas del juego $or L'operador anterior, $in , ja feia una esp\u00e8cie de OR, per\u00f2 sempre sobre el mateix camp. Si l'operaci\u00f3 OR la volem fer sobre camps distints, haurem d'utilitzar l'operador $or . La seua sintaxi ha de jugar amb la possibilitat de posar molts elements, i per tant conv\u00e9 l'array: $or : [ {clau1:valor1} , {clau2:valor2} , ... , {clauN:valorN} ] Ser\u00e0 cert si s'acompleix alguna de les condicions. Per exemple, traure els llibres que no estan en stock o que no tenen editorial: > db.libro.find( { $or : [ {enstock:false} , {editorial:null} ] } , {titulo:1 , enstock:1 , editorial:1} ) { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"enstock\" : false } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"enstock\" : false } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"enstock\" : true} $not Serveix per a negar una altra condici\u00f3. $not : { condici\u00f3 } Per exemple els llibres que no s\u00f3n de l'editorial Planeta (observeu que seria m\u00e9s senzill utilitzar l'operador $ne , per\u00f2 \u00e9s per a mostrar el seu funcionament: > db.libro.find( { editorial: {$not : {$eq:\"Planeta\"} } } , {titulo:1 , editorial:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } $exists Servir\u00e0 per a saber els documents que tenen un determinat camp clau : { $exists : _boolean_ } Depenet del valor boolean , el funcionament ser\u00e0: true : torna els documents en els quals existeix el camp, encara que el seu valor siga nul false : torna els documents que no tenen el camp. Anem a traure els llibres que tenen el camp paginas : > db.libro.find( { paginas: {$exists:true} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"paginas\" : 1100 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"paginas\" : 480 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"paginas\" : 793 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"paginas\" : 544 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"paginas\" : 290 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"paginas\" : null } Observeu com ens apareix tamb\u00e9 l'ultim llibre, que t\u00e9 el camp paginas amb el valor nul . En canvi si hagu\u00e9rem fet la consulta preguntant pels que s\u00f3n diferents de nul, no apareixeria aquest \u00faltim llibre: > db.libro.find( { paginas: {$ne:null} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"paginas\" : 1100 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"paginas\" : 480 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"paginas\" : 793 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"paginas\" : 544 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"paginas\" : 290 } I si posem false al valor en el $exists , \u00fanicament ens apareixer\u00e0 el llibre que no t\u00e9 el camp: > db.libro.find( { paginas: {$exists:false} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } I per la mateixa ra\u00f3 que abans, si traiem els que tenen paginas a null, ens eixir\u00e0 tant qui no t\u00e9 el camp, com qui el t\u00e9 per\u00f2 amb valor nul: > db.libro.find( { paginas: null } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"paginas\" : null} Per tant, per a segons quines coses, ens interessa l'operador $exists , en compte de jugar amb el nul. Expressions regulars Mongo accepta les expressions regulars de forma nativa, cosa que d\u00f3na molta pot\u00e8ncia per a poder buscar informaci\u00f3 diversa. Les expressions regulars en Mongo tenen la mateixa sintaxi que en Perl, i que \u00e9s molt molt pareguda a la major part de llenguatges de programaci\u00f3. Mirem alguns exemples. Els llibres dins dels quals est\u00e0 la paraula juego : > db.libro.find( { titulo: /juego/ } , {titulo:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Ara que tenen la paraula juego sense importar maj\u00fascules o min\u00fascules: > db.libro.find( { titulo: /juego/i } , {titulo:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } I ara que tenen la paraula juego nom\u00e9s al principi. > db.libro.find( { titulo: /^juego/i } , {titulo:1} ) { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } I ara els llibres que en el resum ( resumen ) tenen la paraula amiga o amigo , \u00e9s a dir amig seguit d'una a o una o : > db.libro.find( { resumen: /amig[ao]/i } , {titulo:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Arrays Les consultes dins d'arrays de Mongo s\u00f3n molt senzilles. La m\u00e9s senzilla \u00e9s quan busquem un valor d'un tipus senzill, i en aquest cas el que far\u00e0 Mongo \u00e9s buscar en tot l'array per si est\u00e0 aquest valor. \u00c9s a dir, exactament igual que el que hem fet fins ara. db.col_leccio1.find ( { clau_array : valor } ) Mirem-ho en un exemple. Anem a crear dos documents que tinguen un array cadascun, per exemple de colors. El creem en una col\u00b7lecci\u00f3 nova, anomenada colorins , en dos documents amb el mateix camp de tipus array, color , per\u00f2 amb dades diferents * *: > db.colorins.insert({color: [\"roig\",\"blau\",\"groc\"]}) > db.colorins.insert({color: [\"negre\",\"blanc\",\"roig\"]}) > db.colorins.find() { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Com es veu en la sintaxi, triar els documents que tenen un camp (en aquest cas d'array) que continga un valor, \u00e9s igual de senzill que quan es tracta d'un camp de tipus string, per exemple: > db.colorins.find({color:\"roig\"}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Tamb\u00e9 podem utilitzar qualsevol dels operadors vistos fins el moment, com per exemple l'operador $in , que mirar\u00e0 els documents que tenen algun dels colors que s'especifica a continuaci\u00f3: > db.colorins.find({color: {$in : [\"groc\",\"lila\"]} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } O per exemple tamb\u00e9 utilitzar expressions regulars : > db.colorins.find({color: /bl/ }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } $ all L'operador $all el podem utilitzar quan vulguem seleccionar els documents que en l'array tiguen tots els elements especificats. Per exemple, anem a buscar els document que tenen el color roig i blau. > db.colorins.find({color : { $all : [\"roig\",\"blau\"]} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } Sub\u00edndex Si volem mirar exactament una determinada posici\u00f3 de l'array, podem especificar la posici\u00f3 immediatament despr\u00e9s de la clau, separada per un punt . Recordeu que la primera posici\u00f3 \u00e9s la 0 . Hem de posar entre cometes la clau i la posici\u00f3, sin\u00f3 no sabr\u00e0 trobar-la. Per exemple, busquem els documents que tenen el roig en la primera posici\u00f3. > db.colorins.find({\"color.0\" : \"roig\"} ) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } Nota Accedir a una determinada posici\u00f3 \u00e9s f\u00e0cil, per\u00f2 no \u00e9s tan f\u00e0cil accedir a una posici\u00f3 calculada, per exemple a l'\u00faltima posici\u00f3. Ja fa falta coneixements un poc m\u00e9s avan\u00e7ats de JavaScript, per a posar dins del find() una funci\u00f3 en JavaScript, i actuar dins d'aquesta. \u00danicament de manera il\u00b7lustrativa, posem ac\u00ed la manera de traure els documents, l'\u00faltim color dels quals \u00e9s el roig. En ella ens creem una variable amb l'\u00faltim element de l'array (amb pop() ), i el comparem amb el color roig, tornant true en cas de que s\u00ed que siguen iguals: > db.colorins.find(function() { var a =this.color.pop(); return (a ==\"roig\")}) { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Tamb\u00e9 hi ha una forma alternativa de fer-ho, que \u00e9s utilitzant l'operador $where , que ens permet crear condicions amb sintaxi JavaScript: > db.colorins.find({$where:\"this.color[this.color.length - 1]=='roig'\"}) { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } $size L'operador $size ens servir\u00e0 per a fer condicions sobre el n\u00famero d'elements d'un array. Incorporem 2 documents nous, amb 2 i 4 elements respectivament, per a poder comprovar-lo: > db.colorins.insertOne({color: [\"negre\",\"blanc\"]}) > db.colorins.insertOne({color: [\"taronja\",\"gris\",\"lila\",\"verd\"]}) > db.colorins.find() { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\", \"lila\", \"verd\" ] } Ara anem a seleccionar els documents que tenen 4 colors > db.colorins.find({color:{$size:4}}) { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\", \"lila\", \"verd\" ] } Nota L'operador $size nom\u00e9s admet un valor num\u00e8ric, i no es poden concatenar expressions amb altres operadors, com per exemple intentar la condici\u00f3 que la grand\u00e0ria de l'array siga menor o igual a un determinat valor. Es pot tornar a esquivar la q\u00fcesti\u00f3 amb l'operador $where , i posar la condici\u00f3 en JavaScript. Aix\u00ed la consulta dels documents que tenen 3 o menys colors la podr\u00edem traure d'aquesta manera: db.colorins.find({$where:\"this.color.length<=3\"}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } $slice L'operador $slice no \u00e9s un operador que es puga posar en les condicions (criteris), sin\u00f3 que servir\u00e0 per a extraure determinats elements de l'array, pel n\u00famero d'ordre d'aquestos elements en l'array. Nom\u00e9s el podrem posar, per tant, en el segon par\u00e0metre del find() . La sintaxi \u00e9s: clau : {$slice : x } Els valors que pot agafar x s\u00f3n: N\u00fameros positius: ser\u00e0 el n\u00famero d'elements del principi (per l'esquerra) N\u00fameros negatius: ser\u00e0 el n\u00famero d'elements del final (per la dreta) Un array de 2 elements ( [x,y] ): traur\u00e0 a partir de la posici\u00f3 x (0 \u00e9s el primer), tants elements com indique y Per exemple, anem a traure els dos primers colors de cada document: > db.colorins.find({} , {color:{$slice:2} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\" ] } O traure l'\u00faltim color: > db.colorins.find({} , {color:{$slice:-1 }}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"verd\" ] } O traure el tercer element, tinguen els que tinguen. Recordeu que el segon element, \u00e9s el de la posici\u00f3 2, i en volem traure 1. > db.colorins.find({} , {color:{$slice:[2,1] }}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"lila\" ] } Recerques en objectes Per a fer recerques en camps que a la seua vegada s\u00f3n objectes (o documents dins de documents, en la terminologia de Mongo), nom\u00e9s hem de posar la ruta de les claus separant per mig de punts, i cuidar de posar-la entre cometes. Aix\u00ed, per exemple, anem a fer una consulta sobre la col\u00b7lecci\u00f3 d'alumnes, que eren uns documents en els quals hi havia algun camp de tipus objecte. > db.alumnes.find().pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } Es podrien traure els documents (els alumnes) que viuen en el codi postal 12502. Ens ha d'eixir l'\u00fanic alumne del qual tenim l'adre\u00e7a, que justament t\u00e9 aquest codi postal. Recordeu que en la clau (realment clau.subclau), ha d'anar entre cometes. Hem posat al final pretty() per a una millor lectura, per\u00f2 evidentment no \u00e9s necessari. > db.alumnes.find({\"adre\u00e7a.cp\": \"12502\"}).pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } I funcionaria igual amb qualsevol n\u00famero de subnivells, \u00e9s a dir, documents que tenen objectes, els quals tenen objectes, ... I tamb\u00e9 amb altres tipus d'operadors, o expressions regulars, ... Per exemple, tots els alumnes de Castell\u00f3 (el codi postal ha de comen\u00e7ar per 12 i contenir 3 xifres m\u00e9s, \u00e9s a dir, car\u00e0cter del 0 al 9, i 3 vegades. > db.alumnes.find({\"adre\u00e7a.cp\": /^12[0-9]{3}/}).pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } Limit, Skip i Sort Una vegada tenim feta una consulta, podem limitar el nombre de documents que ens ha de tornar, o ordenar-los. Per a aix\u00f2 hi ha uns m\u00e8todes que apliqiuem al final del find() , \u00e9s a dir, a continuaci\u00f3 del find() , separats per un punt. Ho aplicarem als llibres, que \u00e9s on tenim m\u00e9s documents. I no mostrem tots els camps, per a una millor lectura: > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } limit( n ) Limita el n\u00famero de documents tornats a n documents. > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).limit(3) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } Si el n\u00famero de documents que fa la consulta \u00e9s menor que n , doncs se'n tornaran menys. Aix\u00ed per exemple, de l'editorial Planeta nom\u00e9s hi ha dos llibres. Encara que posem limit(3), se'n tornaran 2. > db.libro.find({editorial:\"Planeta\"} , {titulo:1 , precio:1 , > editorial:1}).limit(3) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\": \"Planeta\", \"precio\" : 17.23 } skip( n ) Se saltaran els primers n documents. Si hi haguera menys documents dels que se salten, doncs no se'n mostraria cap. > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).skip(2) { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } sort() Serveix per a ordenar. Com a par\u00e0metre se li passar\u00e0 un objecte JSON amb les claus per a ordenar, i els valors seran: 1: ordre ascendent -1: ordre descendent Si posem m\u00e9s d'una clau, s'ordenar\u00e0 pel primer, en cas d'empat pel segon, ... En aquest exemple ordenem pel preu > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).sort({precio:1}) { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } I com d\u00e9iem, es pot posar m\u00e9s d'un camp d'ordenaci\u00f3. Per exemple, per editorial en ordre ascendent, i per preu en ordre descendent > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).sort({editorial:1 , precio:-1}) { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } Observeu com el primer \u00e9s el que no t\u00e9 editorial (equivalent a null). I com que hi ha dos de l'editorial Planeta, apareix primer el m\u00e9s car, i despr\u00e9s el m\u00e9s barat. I evidentment, es poden combinar els m\u00e8todes limit, skip i sort. En aquest exemple traurem el segon i tercer llibre m\u00e9s car. Per a aix\u00f2 ordenem per preu de forma descendent, saltem un i limitem a 2. No importa l'ordre com col\u00b7locar skip, limit i sort. > db.libro.find({} , {titulo:1 , precio:1 , > editorial:1}).sort({precio:-1}).skip(1).limit(2) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } 3.9 - Agregaci\u00f3 L'agregaci\u00f3 ens permetr\u00e0 fer consultes molt avan\u00e7ades. \u00c9s un proc\u00e9s un poc complicat per\u00f2 molt potent. Ens donar\u00e0 una pot\u00e8ncia quasi com la del SQL quan comencem a utilitzar el GROUP BY i HAVING. La t\u00e8cnica que s'utilitza \u00e9s la del pipeline , \u00e9s a dir fer una s\u00e8rie de comandos, cadascun agafa les dades que proporciona l'anterior i a la seua vegada proporciona les dades al seg\u00fcent comando. D'aquesta manera es tractar\u00e0 un conjunt de documents i es faran \"operacions\" sobre ells seq\u00fcencialment en blocs: filtrat, projecci\u00f3, agrupacions, ordenaci\u00f3, limitaci\u00f3 i skipping (saltar alguns). La sintaxi ser\u00e0: db.col_leccio1.aggregate ( _operador $matc_ h , _operador $projec_ t , _operador $group_ , _operador $sort_ , _operador $limit_ , _operador $skip_ ) L'ordre dels operadors pot canviar, per\u00f2 hem de tenir en compte que els comandos s'executen en el ordre en qu\u00e8 els posem (d'esquerra a dreta). Aix\u00ed, per exemple, pot ser molt convenient posar el primer operador el $match, que \u00e9s el de seleccionar documents, aix\u00ed les altres operacions es faran sobre menys documents i aniran m\u00e9s r\u00e0pides. Cada par\u00e0metre del aggregate, \u00e9s a dir, cada operador tindr\u00e0 format JSON, i per tant sempre ser\u00e0 de l'estil: { $operador : { clau:valor , ... } } $match Servir\u00e0 per a filtrar els documents. Aleshores, l'agregaci\u00f3 nom\u00e9s afectar\u00e0 als documents seleccionats. Es poden utilitzar tots els operadors que hem anat estudiant. El seg\u00fcent exemple selecciona els documents de l'editorial Planeta. Ho fa per mig de aggregate , per\u00f2 com no fem res m\u00e9s, senzillament selecciona els documents. > db.libro.aggregate({$match:{editorial:\"Planeta\"}}) En el seg\u00fcent exemple, a m\u00e9s de seleccionar els de l'editorial Planeta despr\u00e9s apliquem una projecci\u00f3 sobre els camps t\u00edtol i editorial, per a poder visualitzar millor el resultat. > db.libro.aggregate({$match:{editorial:\"Planeta\"}},{$project:{titulo:1,editorial:1}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\"} { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\": \"Planeta\" } $project Ens permet projectar sobre determinats camps del document, per\u00f2 \u00e9s molt m\u00e9s complet que en la projecci\u00f3 \"normal\" que hav\u00edem fet fins ara, ja que permet tamb\u00e9 renomenar camps, fer c\u00e0lculs, etc. Projeccci\u00f3 La manera m\u00e9s senzilla, evidentment \u00e9s projectar sobre alguns camps dels existents, i el funcionament \u00e9s id\u00e8ntic al de l'altra vegada (valors 1 per a que apareguen, 0 per a que no apareguen; per defecte _id sempre apareix): > db.libro.aggregate({$project:{titulo:1,editorial:1}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\" } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Renomenar $project tamb\u00e9 ens permet renomenar camps existents (despr\u00e9s veurem que tamb\u00e9 c\u00e0lculs). La manera ser\u00e0 posar d'aquest manera: { $project : { \"nom_nou\" : \"$camp_vell\" }} El secret est\u00e0 en el d\u00f2lar que va davant del camp vell, ja que d'aquesta manera ens referim al valor d'aquest camp. Aix\u00ed per exemple renomenem el camp enstock a disponible , a banda de traure el t\u00edtol: > db.libro.aggregate({$project:{titulo:1 , disponible:\"$enstock\"}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"disponible\" : true } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"disponible\" : true } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" disponible\" : true } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"disponible\" : false } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"disponible\" : true } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"disponible\" : false } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"disponible\" : true } Camps calculats Amb aquest nom gen\u00e8ric ens referirem a tots els c\u00e0lculs, expressions i m\u00e9s coses que podrem posar per a trasnsformar el que ja tenim. Com veiem, a\u00e7\u00f2 \u00e9s molt m\u00e9s potent que la projecci\u00f3 normal. Expressions matem\u00e0tiques : Podrem aplicar f\u00f3rmules per a sumar ( $add ), restar ( $subtract ), multiplicar ( $multiply ), dividir ( $divide ) i m\u00e9s coses (pot\u00e8ncia, arrel quadrada, valor absolut, m\u00f2dul, ...). Cada operaci\u00f3 t\u00e9 el seu operador que ser\u00e0 una paraula precedida pel d\u00f2lar, i amb la sintaxi de JSON, on posarem els operands en un array. Per exemple, traurem t\u00edtol del llibre, preu i preu en pessetes (multiplicant per 166.386) > db.libro.aggregate({$project:{titulo:1 , precio:1 , preu_pessetes:{$multiply:[\"$precio\" , 166.386]}}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"precio\" : 21.75, \"preu_pessetes\" : 3618.8955 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"precio\" : 21.75, \"preu_pessetes\" : 3618.8955 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"precio\" : 9.5, \"preu_pessetes\" : 1580.667 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"precio\" : 9.45, \"preu_pessetes\" : 1572.3476999999998 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11, \"preu_pessetes\" : 1830.2459999999999 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23, \"preu_pessetes\" : 2866.83078 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9, \"preu_pessetes\" : 2645.5374 } Expressions de dates : Ja veurem i ja podem anar intuint que moltes agregacions estaran basades en el temps, per a poder fer consultes de documents de la setmana passada, o el mes passat, ... Per a poder fer aquestes agregacions, hi ha un conjunt d'expressions que permeten extraure f\u00e0cilment d'una data el seu dia, mes, any, ... en forma de n\u00famero S\u00f3n les expressions: $year, $month, $week, $dayOfMonth, $DayOfWeek, $dayOfYear, $hour, $minute i $second . En el seg\u00fcent exemple traurem tots els documents, projectant per la data, any i mes: > db.libro.aggregate({$project : {fecha:1 , a\u00f1o:{$year:\"$fecha\"} , mes:{$month:\"$fecha\"}}}) { \"_id\" : \"9788408117117\", \"fecha\" : ISODate(\"2013-08-29T00:00:00Z\"), \"a\u00f1o\" : 2013, \"mes\" : 8 } { \"_id\" : \"9788401342158\", \"fecha\" : ISODate(\"2014-03-01T00:00:00Z\"), \"a\u00f1o\" : 2014, \"mes\" : 3 } { \"_id\" : \"9788496208919\", \"fecha\" : ISODate(\"2011-11-24T00:00:00Z\"), \"a\u00f1o\" : 2011, \"mes\" : 11 } { \"_id\" : \"9788499088075\", \"fecha\" : ISODate(\"2009-01-09T00:00:00Z\"), \"a\u00f1o\" : 2009, \"mes\" : 1 } { \"_id\" : \"9788415140054\", \"fecha\" : ISODate(\"2012-10-30T00:00:00Z\"), \"a\u00f1o\" : 2012, \"mes\" : 10 } { \"_id\" : \"9788408113331\", \"fecha\" : ISODate(\"2013-06-04T00:00:00Z\"), \"a\u00f1o\" : 2013, \"mes\" : 6 } { \"_id\" : \"9788468738895\", \"fecha\" : ISODate(\"2014-02-06T00:00:00Z\"), \"a\u00f1o\" : 2014, \"mes\" : 2 } Expressions de strings : Ens permeten manipular els strings per a extraure subcadenes, concatenar, passar a maj\u00fascules o min\u00fascules. Aquestes s\u00f3n algunes de les funcions: $substr : [exp , inici , llarg\u00e0ria] : extrau una subcadena del string del primer par\u00e0metre, des de la posici\u00f3 que indica el segon par\u00e0metre (o primer car\u00e0cter) i tants car\u00e0cters com el tercer par\u00e0metre $concat : [ exp1 , exp2 , ...] : concatena les expressions que hi ha en l'array $toLower : exp i $toUpper : exp : converteixen l'expressi\u00f3 a maj\u00fascules i min\u00fascules respectivament Per exemple, anem a traure el t\u00edtol dels llibres amb l'autor entre par\u00e8ntesis: > db.libro.aggregate({$project: { \"Llibre:\" : {$concat : [\"$titulo\" , \" (\" , \"$autor\" , \")\"]}}}) { \"_id\" : \"9788408117117\", \"Llibre:\" : \"Circo M\u00e1ximo (Santiago Posteguillo)\" } { \"_id\" : \"9788401342158\", \"Llibre:\" : \"El juego de Ripper (Isabel Allende)\" } { \"_id\" : \"9788496208919\", \"Llibre:\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1 (George R.R. Martin)\" } { \"_id\" : \"9788499088075\", \"Llibre:\" : \"La ladrona de libros (Markus Zusak)\" } { \"_id\" : \"9788415140054\", \"Llibre:\" : \"La princesa de hielo (Camilla Lackberg)\" } { \"_id\" : \"9788408113331\", \"Llibre:\" : \"Las carreras de Escorpio (Maggie Stiefvater)\" } { \"_id\" : \"9788468738895\", \"Llibre:\" : \"Las reglas del juego (Anna Casanovas)\"} I ara el mateix, per\u00f2 amb el t\u00edtol en maj\u00fascules: > db.libro.aggregate({$project: { \"Llibre:\" : {$concat : [{$toUpper:\"$titulo\"}, \" (\" , \"$autor\" , \")\"]}}}) { \"_id\" : \"9788408117117\", \"Llibre:\" : \"CIRCO M\u00e1XIMO (Santiago Posteguillo)\" } { \"_id\" : \"9788401342158\", \"Llibre:\" : \"EL JUEGO DE RIPPER (Isabel Allende)\" } { \"_id\" : \"9788496208919\", \"Llibre:\" : \"JUEGO DE TRONOS: CANCI\u00f3N DE HIELO Y FUEGO 1 (George R.R. Martin)\" } { \"_id\" : \"9788499088075\", \"Llibre:\" : \"LA LADRONA DE LIBROS (Markus Zusak)\" } { \"_id\" : \"9788415140054\", \"Llibre:\" : \"LA PRINCESA DE HIELO (Camilla Lackberg)\" } { \"_id\" : \"9788408113331\", \"Llibre:\" : \"LAS CARRERAS DE ESCORPIO (Maggie Stiefvater)\" } { \"_id\" : \"9788468738895\", \"Llibre:\" : \"LAS REGLAS DEL JUEGO (Anna Casanovas)\" } $group Realitza grups sobre els documents seleccionats pr\u00e8viament, per a valors iguals del camp o expressions que determinem. Posteriorment, amb els grups, podrem realitzar operacions, com sumar o traure la mitjana d'alguna quantitat dels documents del grup, o el m\u00e0xim o m\u00ednim, ... Per a poder agrupar, haurem de definir com a _id del grup el camp o camps pels valors dels quals volem agrupar. Per exemple, si volem agrupar els llibres per l'editorial, haurem de definir el _id del grup el camp editorial $group : { \"_id\" : _camp o camps_ } Si agrupem per un \u00fanic camp, senzillament el posem amb un d\u00f2lar davant i entre cometes. Si \u00e9s m\u00e9s d'un camp, els posem com un objecte. Per exemple, agrupem per editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" } } ) { \"_id\" : \"Debolsillo\" } { \"_id\" : null } { \"_id\" : \"Gigamesh\" } { \"_id\" : \"Embolsillo\" } { \"_id\" : \"Plaza & Janes\" } { \"_id\" : \"Planeta\" } Podem observar com hi ha algun llibre que no t\u00e9 editorial. Ara agrupem per any de publicaci\u00f3 (l'extraurem del camp fecha ): > db.libro.aggregate( { $group : { \"_id\" : { \"any\" : { $year : \"$fecha\" } } }} ) { \"_id\" : { \"any\" : 2012 } } { \"_id\" : { \"any\" : 2009 } } { \"_id\" : { \"any\" : 2011 } } { \"_id\" : { \"any\" : 2014 } } { \"_id\" : { \"any\" : 2013 } } I ara agrupem per editorial i any de publicaci\u00f3 (els dos llibres de Planeta s\u00f3n del 2013) > db.libro.aggregate( { $group : { \"_id\" : { \"Editorial\" : \"$editorial\" , \"any\" : { $year : \"$fecha\" } } } } ) { \"_id\" : { \"Editorial\" : \"Embolsillo\", \"any\" : 2012 } } { \"_id\" : { \"any\" : 2014 } } { \"_id\" : { \"Editorial\" : \"Debolsillo\", \"any\" : 2009 } } { \"_id\" : { \"Editorial\" : \"Gigamesh\", \"any\" : 2011 } } { \"_id\" : { \"Editorial\" : \"Plaza & Janes\", \"any\" : 2014 } } { \"_id\" : { \"Editorial\" : \"Planeta\", \"any\" : 2013 } } Operadors d'agrupaci\u00f3 Ens permetran fer alguna operaci\u00f3 sobre els documents del grup. Es posen com a segon par\u00e0metre del grup (despr\u00e9s de la definici\u00f3 del _id ). $sum : valor : sumar\u00e0 el valor de tots els documents del grup. El valor pot ser un camp num\u00e8ric, o alguna altra cosa m\u00e9s complicada. $avg : valor : calcular\u00e0 la mitjana dels valors per als documents del grup $max : valor : m\u00e0xim $min : valor : m\u00ednim $first : exp : agafar\u00e0 el primer valor de l'expressi\u00f3 del grup, ignorant les altres del grup $last : exp : agafar\u00e0 l'\u00faltim La documentaci\u00f3 diu que tamb\u00e9 existeix l'operador $count , per\u00f2 a partir d'una determinada versi\u00f3. Es pot substituir la seua utilitzaci\u00f3 per l'operador $sum , sumant la quantitat 1. Per exemple, la suma dels preus dels llibres de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"suma_preus\" : {$sum : \"$precio\"} } } ) { \"_id\" : \"Debolsillo\", \"suma_preus\" : 9.45 } { \"_id\" : null, \"suma_preus\" : 15.9 } { \"_id\" : \"Gigamesh\", \"suma_preus\" : 9.5 } { \"_id\" : \"Embolsillo\", \"suma_preus\" : 11 } { \"_id\" : \"Plaza & Janes\", \"suma_preus\" : 21.75 } { \"_id\" : \"Planeta\", \"suma_preus\" : 38.980000000000004 } O la mitjana dels preus de cada any: > db.libro.aggregate( { $group : { \"_id\" : { \"any\" : { $year : \"$fecha\" } } , \"mitjana preus\" : { $avg : \"$precio\" } } } ) { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 } { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } I ara intentem comptar la quantitat de llibres de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"quants\" : { $sum : 1} } } ) { \"_id\" : \"Debolsillo\", \"quants\" : 1 } { \"_id\" : null, \"quants\" : 1 } { \"_id\" : \"Gigamesh\", \"quants\" : 1 } { \"_id\" : \"Embolsillo\", \"quants\" : 1 } { \"_id\" : \"Plaza & Janes\", \"quants\" : 1 } { \"_id\" : \"Planeta\", \"quants\" : 2 } $sort Serveix per a ordenar i segueix la mateixa sint\u00e0xi que en les consultes normal (1: ordre ascendent; -1: ordre descendent). Podrem ordenar pels camps normals o per camps clalculats. Per exemple ordenem per la suma de preus de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"suma_preus\" : { $sum : \"$precio\"} } } , { $sort : { suma_preus : 1 } }) { \"_id\" : \"Debolsillo\", \"suma_preus\" : 9.45 } { \"_id\" : \"Gigamesh\", \"suma_preus\" : 9.5 } { \"_id\" : \"Embolsillo\", \"suma_preus\" : 11 } { \"_id\" : null, \"suma_preus\" : 15.9 } { \"_id\" : \"Plaza & Janes\", \"suma_preus\" : 21.75 } { \"_id\" : \"Planeta\", \"suma_preus\" : 38.980000000000004 } I ara ordenem de forma descendent per la mitjana de preus de cada any: > db.libro.aggregate( { $group : { \"_id\" : {\"any\":{$year:\"$fecha\"}} , \"mitjana preus\":{$avg:\"$precio\"} } } , {$sort:{\"mitjana preus\":-1}}) { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 } { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 } $limit Limita el resultat del aggregate al n\u00famero indicat. Per exemple, els tres anys de mitjana de preus m\u00e9s cara. \u00c9s com l'\u00faltim exemple, afegint el l\u00edmit: > db.libro.aggregate({$group:{\"_id\":{\"any\":{$year:\"$fecha\"}},\"mitjana preus\":{$avg:\"$precio\"}}} , {$sort:{\"mitjana preus\":-1}} , {$limit:3}) { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 } $skip Salta el n\u00famero indicat En l'exemple anterior, ara saltem els 3 primers: > db.libro.aggregate({$group:{\"_id\":{\"any\":{$year:\"$fecha\"}},\"mitjana preus\":{$avg:\"$precio\"}}} , {$sort:{\"mitjana preus\":-1}} , {$skip:3}) { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 } 3.10 - Resum Comandos Per a qualsevol operaci\u00f3 s'ha de posar db seguit del nom de la col\u00b7lecci\u00f3, i despr\u00e9s l'operaci\u00f3 que volem fer. Operacions sobre el servidor MongoDB Connectar a MongoDB => mongo Seleccionar la base de dades => use miBaseDeDatos Mostrar totes les bases de dades en el teu servidor MongoDB => show dbs Mostrar els usuaris de la base de dades actual => show users Mostrar els rols definits en la base de dades actual => show roles Mostrar la versi\u00f3 del servidor MongoDB => db.version() Mostrar el nom de la BD del servidor MongoDB => db.getName() Mostrar les operacions que s\u2019estan executant en el servidor => db.currentOp() Mostrar informaci\u00f3 de la base de dades actual => db.stats() Operacions sobre col\u00b7leccions Mostrar totes les col\u00b7leccions en la base de dades seleccionada => show collections Crear una col\u00b7lecci\u00f3 dins de la base de dades on estiguem situats => db.createCollection(\"nom_de_la_col\u00b7lecci\u00f3\") Altres funcions sobre una col\u00b7lecci\u00f3 db.nom_de_la_col\u00b7lecci\u00f3.XXXXXXX Eliminar la col\u00b7lecci\u00f3 => drop() Formatar l\u2019eixida => pretty() Comptar de manera precisa el nombre de documents de la col\u00b7lecci\u00f3 => countDocuments() Realitzar un recompte per a una estimaci\u00f3 r\u00e0pida => estimatedDocumentCount() Operacions CRUD dins de la col\u00b7lecci\u00f3 db.nom_de_la_col\u00b7lecci\u00f3.XXXXXXX Create (crear document/s) => insertOne() , insertMany() Read (llegir, buscar document/s) => findOne() , find() , group() , sort() , limit() , skip() Update (modificar document/s) => updateOne() , updateMany() , replaceOne() Delete (eliminar document/s) => deleteOne() , deleteMany() Operacions avan\u00e7ades Pipeline o agregaci\u00f3 => aggregation() Exercicis Exercici 2 Sobre la teua Base de Dades MONGODB treballarem sobre la col\u00b7lecci\u00f3 libro , la mateixa que hem utilitzat en els exemples. Si no la tens creada, executa les sent\u00e8ncies del principi de la pregunta 3.8 - Operadors de consulta/ Operadors . Fes les seg\u00fcents consultes. Copia-les en un \u00fanic fitxer de text, de forma numerada. \u00c9s aquest fitxer el que haur\u00e0s de pujar. Busca els llibres que tenen m\u00e9s de 500 p\u00e0gines. Visualitza el _id, el t\u00edtol i el n\u00famero de p\u00e0gines. Busca els llibres de l'any 2014. Visualitza \u00fanicament t\u00edtol i data. Busca els llibres de l'editorial Planeta. Visualitza \u00fanicament t\u00edtol i editorial. Busca els llibres de l'editorial Planeta de m\u00e9s de 500 p\u00e0gines. Visualitza \u00fanicament t\u00edtol, editorial i p\u00e0gines. Busca els llibres que no tenen editorial. Visualitza \u00fanicament t\u00edtol i editorial. Busca els llibres que en el resum contenen la paraula caballo . Visualitza el resum per poder comprovar-ho. Han d'eixir 2 llibres, Circo m\u00e1ximo i Las carreras de Escorpio . Utilitzant la funci\u00f3 aggregate , trau l'editorial i la mitjana de p\u00e0gines d'aquelles editorials que tenen una mitjana de p\u00e0gines superior a 500. Eixiran 3 editorials. Incrementar el preu dels llibres de l'editorial Planeta en 2\u20ac (recordeu que per a modificar m\u00e9s d'un document, hem de posar com a tercer par\u00e0metre l'opci\u00f3 {multi:true} ). Crear el camp editorial amb el valor nul, per a tots aquells documents que no tinguen el camp editorial. Fer l'operaci\u00f3 inversa: eliminar el camp editorial per a tots aquells que el tinguen nul. Traure l'any del llibre, a partir de la fecha (ser\u00e0 un camp calculat anomenat a\u00f1o ). Aprofita el camp anterior per a traure els llibres estrictament anteriors a l'any 2013. Visualitza titulo , fecha i a\u00f1o . Exercici 3 Aquest exercici l'has de realitzar sobre la teua BD de MongoDB (col\u00b7lecci\u00f3 pelicula ). title : Fight Club writer : Chuck Palahniuk year : 1999 actors : [ Brad Pitt Edward Norton ] title : Pulp Fiction writer : Quentin Tarantino year : 1994 actors : [ John Travolta Uma Thurman ] title : Inglorious Basterds writer : Quentin Tarantino year : 2009 actors : [ Brad Pitt Diane Kruger Eli Roth ] title : The Hobbit: An Unexpected Journey writer : J.R.R. Tolkein year : 2012 franchise : The Hobbit title : The Hobbit: The Desolation of Smaug writer : J.R.R. Tolkein year : 2013 franchise : The Hobbit title : The Hobbit: The Battle of the Five Armies writer : J.R.R. Tolkein year : 2012 franchise : The Hobbit synopsis : Bilbo y compa\u00f1\u00eda se ven obligados a participar en una guerra contra una serie de combatientes y evitar que la Lonely Mountain caiga en manos de una oscuridad creciente. title : Pee Wee Herman's Big Adventure title : Avatar Inserir tots els documents anteriors. Ha de ser obligat\u00f2riament amb una \u00fanica sent\u00e8ncia, per a la qual cosa pots utilitzar variables, una per a cada document. Consultar tots els documents Obtenir els documents amb writer igual a \"Quentin Tarantino\" Obtenir els documents amb actors que incloguen a \"Brad Pitt\" Obtenir els documents amb franchise igual a \"The Hobbit\" Obtenir totes les pel\u00b7l\u00edcules dels anys 90. Obtenir les pel\u00b7l\u00edcules estrenades entre l'any 2000 i el 2010. Agregar sinopsis a \"The Hobbit: An Unexpected Journey\" : \"Un hobbit reacio, Bilbo Baggins, se dirige a Lonely Mountain con un en\u00e9rgico grupo de enanos para reclamar su hogar en la monta\u00f1a, y el oro que contiene, del drag\u00f3n Smaug\". Agregar sinopsis a \"The Hobbit: The Desolation of Smaug \": \"Los enanos, junto con Bilbo Baggins y Gandalf the Grey, contin\u00faan su b\u00fasqueda para recuperar Erebor, su tierra natal, de manos de Smaug. Bilbo Baggins est\u00e1 en posesi\u00f3n de un anillo misterioso y m\u00e1gico\". Agregar un actor anomenat \"Samuel L. Jackson\" a la pel\u00b7l\u00edcula \"Pulp Fiction\" Trobar les pel\u00b7l\u00edcules que en la sinopsis continguen la paraula \"Bilbo\" Trobar les pel\u00b7l\u00edcules que en la sinopsis continguen la paraula \"Gandalf\" Trobar les pel\u00b7l\u00edcules que en la sinopsis continguen la paraula \"Bilbo\" i no la paraula \"Gandalf\" . S'aconsella utilitzar l'operador $and Trobar les pel\u00b7l\u00edcules que en la sinopsis continguen la paraula \"enanos\" o \"hobbit\" Trobar les pel\u00b7l\u00edcules que en la sinopsis continguen les paraules \"oro\" i \"drag\u00f3n\" Eliminar la pel\u00b7l\u00edcula \"Pee Wee Herman's Big Adventure\" Eliminar la pel\u00b7l\u00edcula \"Avatar\" Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"3 - MongoDB"},{"location":"3__mongodb/#3-mongodb","text":"Segurament MongoDB \u00e9s el m\u00e9s fam\u00f3s dels Sistemes Gestors de Bases de Dades NoSQL . El nom de MongoDB prov\u00e9 de la paraula anglesa hu mongo us , que significa enorme, que \u00e9s el prop\u00f2sit d'aquesta Base de Dades: guardar grans quantitats d'informaci\u00f3. \u00c9s de codi obert i est\u00e0 programada en C++. El va crear l'empresa 10gen (actualment MongoDB Inc. ) \u00c9s un SGBD Documental , \u00e9s a dir, que servir\u00e0 per a guardar documents. La manera interna de guardar-los \u00e9s en format BSON (Binary JSON) que en ess\u00e8ncia \u00e9s una variant del JSON per a poder guardar f\u00edsicament les dades d'una manera m\u00e9s eficient. En un servidor Mongo poden haver m\u00e9s d'una Base de Dades, encara que nosaltres nom\u00e9s en gastarem una: test . En cada Base de Dades la informaci\u00f3 es guardar\u00e0 en col\u00b7leccions . Cada col\u00b7lecci\u00f3 constar\u00e0 d'uns quants documents . I cada document seran una s\u00e8rie de dades guardades en forma de clau-valor , dels tipus suportats per MongoDB, i amb el format JSON (en realitat BSON) Per tant, en Mongo no hi ha taules. Mirem uns exemples de documents JSON per a guardar la informaci\u00f3 de llibres i autors. Depenen de com s'haja d'accedir a la informaci\u00f3 ens podem plantejar guardar els llibres amb els seus autors, o guardar els autors, amb els seus llibres. Fins i tot ens podr\u00edem guardar els dos, per a poder accedir de totes les maneres, encara que \u00e9s a costa de doblar la informaci\u00f3. De la primera manera, guardant els llibres amb el seu autor, podr\u00edem tenir documents amb aquesta estructura, que es podrien guardar en una col\u00b7lecci\u00f3 anomenada Llibres : { _id:101, titol:\"El secret de Khadrell\", autor: { nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960 }, isbn:\"84-95620-72-3\" }, { _id:102, titol:\"L'Ombra del Vent\", autor: { nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\" }, pagines:490, editorial:\"Planeta\" } Observeu com els objectes no tenen per qu\u00e8 tenir la mateixa estructura. La manera d'accedir al nom d'un autor seria aquesta: objecte.autor.nom Una manera alternativa de guardar la informaci\u00f3, com hav\u00edem comentat abans seria organitzar per autors, amb els seus llibres. D'aquesta manera podr\u00edem anar omplint la col\u00b7lecci\u00f3 Autors amb un o m\u00e9s documents d'aquest estil: { _id: 201, nom:\"Pep\", cognoms:\"Castellano Puchol\", any_naixement:1960, llibres: [ { titol:\"El secret de Khadrell\", isbn:\"84-95620-72-3\" }, { titol:\"Habitaci\u00f3 502\", editorial:\"Tabarca\" } ] }, { _id:202, nom:\"Carlos\", cognoms:\"Ruiz Zafon\", pais:\"Espanya\", llibres: [ { titol:\"L'Ombra del Vent\", pagines:490, editorial:\"Planeta\" } ] } Observeu com per a un autor, ara tenim un array ( els claud\u00e0tors: [ ] ) amb els seus llibres. Quina de les dues maneres \u00e9s millor per a guardar la informaci\u00f3? Doncs dep\u00e9n de l'acc\u00e9s que s'haja de fer a les dades. La millor ser\u00e0 segurament aquella que depenent dels accessos que s'hagen de fer, torne la informaci\u00f3 de forma m\u00e9s r\u00e0pida.","title":"3 - MongoDB"},{"location":"3__mongodb/#31-estructura-json","text":"Amb JSON podrem representar: Valors , de tipus car\u00e0cter (entre cometes dobles), num\u00e8ric (sense cometes) , boole\u00e0 (true o false) o null . Parelles clau valor , \u00e9s a dir un nom simb\u00f2lic acompanyat d'un valor associat.. Es representen aix\u00ed: \"nom\" : valor Objectes , que \u00e9s una col\u00b7lecci\u00f3 de membres, cadasc\u00fa dels quals pot ser una parella clau valor, o altres objectes (fins i tot arrays): es representen entre claus, i amb els elements separats per comes: { \"nom1\" : \"valor1\" , \"nom2\": valor2 , valor 3 , ... } Arrays , que s\u00f3n llistes d'elements. Els elements no tenen per qu\u00e8 tenir la mateixa estructura, per\u00f2 nosaltres intentarem que s\u00ed que la tinguen per coher\u00e8ncia. Cada element pot ser un valor , una parella clau valor, un objecte o un array. Veje'm algun exemples: { \"p1\" : 2 , \"p2\" : 4 , \"p3\" : 6 , \"p4\" : 8 , \"p5\" : 10 } en aquest cas tenim un objecte, l'arrel, que t\u00e9 5 membres, tots ells parelles clau-valor. { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } ara un objecte, l'arrel, tamb\u00e9 amb 5 membres que s\u00f3n parelles clau-valor. Observeu com la clau sempre la posem entre cometes, i el valor quan \u00e9s un string tamb\u00e9, per\u00f2 quan \u00e9s num\u00e8ric, no. { \"empleat\" : { \"num\": 1 , \"nom\": \"Andreu\" , \"departament\": 10 , \"edat\": 32 , \"sou\": 1000.0 } } en aquest cas tenim un objecte, l'arrel que consta d'un \u00fanic objecte, empleat , el qual consta de 5 membres clau-valor. Mirem ara un exemple amb un array: { \"notes\" : [ 5 , 7 , 8 , 7 ] } on tenim l'element arrel que consta d'un \u00fanic membre, notes , que \u00e9s un array. Tamb\u00e9 seria correcte d'aquesta manera, per veure que l'element arrel no t\u00e9 perqu\u00e8 ser un objecte, sin\u00f3 tamb\u00e9 un array [ 5 , 7 , 8 , 7 ] I ara un m\u00e9s complet amb la mateixa estructura que el fitxer XML que hav\u00edem vist en la pregunta 4. Tindrem un objecte arrel, amb nom\u00e9s un objecte, empresa , que t\u00e9 un \u00fanic element empleat que \u00e9s un array amb 4 elements, cadascun dels empleats: { \"empresa\": { \"empleat\": [ { \"num\": \"1\", \"nom\": \"Andreu\", \"departament\": \"10\", \"edat\": \"32\", \"sou\": \"1000.0\" }, { \"num\": \"2\", \"nom\": \"Bernat\", \"departament\": \"20\", \"edat\": \"28\", \"sou\": \"1200.0\" }, { \"num\": \"3\", \"nom\": \"Cl\u00e0udia\", \"departament\": \"10\", \"edat\": \"26\", \"sou\": \"1100.0\" }, { \"num\": \"4\", \"nom\": \"Dami\u00e0\", \"departament\": \"10\", \"edat\": \"40\", \"sou\": \"1500.0\" } ] } } Anem a veure un parell de casos m\u00e9s reals. Aquesta \u00e9s la contestaci\u00f3 que fa el WebService de Bicicas en sol\u00b7licitar l'estat actual de bicicletes en els diferents punts (en el moment de fer els apunts es consulta en l'adre\u00e7a http://gestiona.bicicas.es/apps/apps.php ): [ {\"ocupacion\": [ {\"id\":\"01\",\"punto\":\"UJI - FCHS\",\"puestos\":27,\"ocupados\":12,\"latitud\":\"39.99533\",\"longitud\":\"-0.06999\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"02\",\"punto\":\"ESTACI\u00d3N DE FERROCARRIL Y AUTOBUSES\",\"puestos\":24,\"ocupados\":7,\"latitud\":\"39.98765\",\"longitud\":\"-0.05281\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, {\"id\":\"03\",\"punto\":\"PLAZA DE PESCADER\u00cdA\",\"puestos\":28,\"ocupados\":4,\"latitud\":\"39.98580\",\"longitud\":\"-0.03798\", \"porcentajeAltaOcupacion\":\"80\",\"porcentajeBajaOcupacion\":\"20\"}, ... ] } ] Com podeu comprovar, l'arrel no \u00e9s un objecte, sin\u00f3 un Array . En l'array nom\u00e9s ens interessa el primer element que \u00e9s un objecte amb un \u00fanic membre, ocupacion (en l'exemple no hi ha m\u00e9s elements, per\u00f2 en poden haver m\u00e9s en un moment determinat, quan volen fer avisos). I ocupacion \u00e9s un array , amb un objecte per cada estaci\u00f3 de bicicas , amb les parelles clau valor id , punto , puestos (les bicicletes que caben), ocupados (quantes bicicletes hi ha col\u00b7locades en aquest moment), latitud i longitud (les coordenades), ... Nota En realitat ens apareixer\u00e0 tota la informaci\u00f3 molt m\u00e9s apegada, perqu\u00e8 realment est\u00e0 en una \u00fanica l\u00ednia. Per a poder observar millor l'estructura podem utilitzar un visor de json. Normalment el navegador Firefox els visualitza b\u00e9, encara que tamb\u00e9 dep\u00e9n de la versi\u00f3. Si tenim instal\u00b7lada una versi\u00f3 que admet la visualitzaci\u00f3 de JSON, ho intentar\u00e0 interpretar, encara que segurament la millor manera de veure el format JSON \u00e9s,tiar les opcions Dades sense processar -- > Format d'impressi\u00f3 , que \u00e9s la que veiem a la dreta: Si la versi\u00f3 nostra de Firefox no visualitza el format JSON, podem buscar un visor dels molts que hi ha per internet. En la figura n'hem utilitzat un, i es pot observar com facilita molt la lectura. Un altre exemple. Un WebService de GeoNames (una Base de Dade geogr\u00e0fica gratu\u00efta i accessible a trav\u00e9s d'Internet) ens proporciona informaci\u00f3 dels llocs que troba dins d'un rectangle delimitat per un latitud al nord i al sud, i una longitud a l'esti a l'oest (en l'exemple: nord 40.01, sud 39.9, est 0.1 i oest -0.1). Per exemple, http://api.geonames.org/citiesJSON?north=40.01&south=39.99&east=0.01&west=-0.01&lang=ES&username=demo torna el seg\u00fcent: { \"geonames\": [ { \"lng\": -0.04935, \"geonameId\": 2519752, \"countrycode\": \"ES\", \"name\": \"Castell\u00f3 de la Plana\", \"fclName\": \"city, village,...\", \"toponymName\": \"Castell\u00f3 de la Plana\", \"fcodeName\": \"seat of a second-order administrative division\", \"wikipedia\": \"en.wikipedia.org/wiki/Castell%C3%B3n_de_la_Plana\", \"lat\": 39.98567, \"fcl\": \"P\", \"population\": 180005, \"fcode\": \"PPLA2\" }, { \"lng\": -0.06313, \"geonameId\": 2521909, \"countrycode\": \"ES\", \"name\": \"Almazora\", \"fclName\": \"city, village,...\", \"toponymName\": \"Almassora\", \"fcodeName\": \"populated place\", \"wikipedia\": \"en.wikipedia.org/wiki/Almassora\", \"lat\": 39.94729, \"fcl\": \"P\", \"population\": 24963, \"fcode\": \"PPL\" }, ... ] } A partir de l'arrel (que ara s\u00ed que \u00e9s un objecte), tenim un membre: geonames , que \u00e9s un array (un element per cada \"lloc\" trobat), on cada element t\u00e9 informaci\u00f3 diversa, com el nom del lloc, les coordenades, la poblaci\u00f3, ... Nota De fa uns mesos que Google limita el servei anterior, i ha de ser amb un usuari validat. No valdr\u00e0 la pena, per al poc profit que li traur\u00edem. Mostrem en qu\u00e8 consisteix el servei \u00fanicament a nivell il\u00b7lustratiu","title":"3.1 - Estructura JSON"},{"location":"3__mongodb/#32-installacio-de-mongodb","text":"Podrem instal\u00b7lar MongoDB en qualsevol plataforma. I fins i tot sense tenir permisos d'administrador, com veurem en el cas d'Ubuntu. Tamb\u00e9 est\u00e0 la possibilitat de crear un servidor en el n\u00favol, fins i tot gratu\u00eft. \u00c9s l'opci\u00f3 que ens suggereix Mongo per defecte, per\u00f2 nosaltres no la utilitzarem.","title":"3.2 - Instal\u00b7laci\u00f3 de MongoDB"},{"location":"3__mongodb/#installacio-en-linux","text":"Per a poder fer la instal\u00b7laci\u00f3 m\u00e9s b\u00e0sica, podrem fer-lo sense permisos d'administrador. Si els tenim tot \u00e9s m\u00e9s c\u00f2mode, per\u00f2 si no en tenim tamb\u00e9 ho podem fer, com veurem i remarcarem a continuaci\u00f3. Pas 1. Instal\u00b7laci\u00f3 del servidor (Linux) 1- De la p\u00e0gina de MongoDB ( https://www.mongodb.com/try/download/community ) anem al men\u00fa Products - > Comunity Edition ->Comunity Server i ens baixem la versi\u00f3 apropiada per al nostre Sistema Operatiu. Observeu com en el cas de Linux hi ha moltes versions, per a moltes distribucions. I millor triar el paquet tgz , ja que amb descomprimir el fitxer ser\u00e0 suficient. En el cas d' Ubuntu 22.04 de 64 bits , aquest fitxer \u00e9s: https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu2204-8.0.5.tgz . Per\u00f2 recordeu que us heu d'assegurar de la versi\u00f3. 2- Descomprimirem aquest fitxer on vulguem, i ja estar\u00e0 feta la instal\u00b7laci\u00f3 b\u00e0sica. 3- Es necessari tindre un directori de dades per emmagatzemar la base de dades. Creem el directori de dades en el directori arrel (carpeta d'instal\u00b7laci\u00f3). mkdir data mkdir data/db 4- Arranquem el servidor: <directori arrel Mongo> /bin/mongod ./bin/mongod --dbpath ./data/db La seg\u00fcent imatge il\u00b7lustra aquesta segona opci\u00f3. Est\u00e0 per a una versi\u00f3 anterior de MongoDB, per\u00f2 \u00e9s totalment equivalent: Nota Una vegada en marxa el servidor, no hem de tancar aquesta terminal, ja que parar\u00edem el servidor. Pas 2. Instal\u00b7laci\u00f3 del client MongoShell (Linux) 1- De la p\u00e0gina de MongoDB ( https://www.mongodb.com/try/download/shell ) anem al men\u00fa Products - > Tools ->MongoDB Shell i ens baixem la versi\u00f3 apropiada per al nostre Sistema Operatiu. Observeu com en el cas de Linux hi ha moltes versions, per a moltes distribucions, i millor triar el paquet tgz , ja que amb descomprimir el fitxer ser\u00e0 suficient. En el cas d' Ubuntu 22.04 de 64 bits , triarem l'opi\u00f3 gen\u00e8rica Linux 64 ja que \u00e9s la opci\u00f3 que t\u00e9 el paquet tgz , i aquest fitxer \u00e9s: https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz . Per\u00f2 recordeu que us heu d'assegurar de la versi\u00f3. 2- Descomprimirem aquest fitxer on vulguem, i ja estar\u00e0 feta la instal\u00b7laci\u00f3 b\u00e0sica. 3- Per a connectar un client, obrim una segona terminal i executem el client mongosh : <directori arrel Mongosh>/bin/mongosh ./bin/mongosh","title":"\ud83d\udc27Instal\u00b7laci\u00f3 en Linux"},{"location":"3__mongodb/#installacio-en-windows","text":"Pas 1. Instal\u00b7laci\u00f3 del servidor (Windows) 1- Ens baixem la versi\u00f3 apropiada de MongoDB per a Windows, que resultar\u00e0 ser un .msi directament executable. En el moment de fer aquestos apunts, la versi\u00f3 de 64 bits \u00e9s la 8.0.5: https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-8.0.5-signed.msi 2- Com en el cas de Linux, abans d'executar el servidor haurem de tenir el directori creat. Per defecte el directori ser\u00e0 \\data\\db 3- Aqueste serien les ordres per a crear el directori i despr\u00e9s arrancar el servidor. mkdir \\data\\db C:\\Program Files\\MongoDB\\Server\\8.0\\bin\\mongod.exe Hauria d'apar\u00e8ixer la imatge seg\u00fcent Nota Si vas instal\u00b7lar MongoDB amb el MongoDB MSI Installer, normalment el servei ja estar\u00e0 instal\u00b7lat i no caldr\u00e0 executar-lo. Pas 2. Instal\u00b7laci\u00f3 del client MongoShell (Windows) 1- Per a connectar-nos com a clients, ho haurem de fer des d'una altra terminal, amb mongosh.exe , que \u00e9s la interf\u00edcie de l\u00ednia d'ordres (CLI) oficial de MongoDB, utilitzada per interactuar amb la base de dades mitjan\u00e7ant ordres en JavaScript: Ens baixem la versi\u00f3 apropiada de MongoDB per a Windows https://downloads.mongodb.com/compass/mongosh-2.4.0-linux-x64.tgz Mongo Compass Tamb\u00e9 us podeu descarregar la versi\u00f3 MongoDB Compass , que \u00e9s l'eina gr\u00e0fica oficial de MongoDB que permet visualitzar, explorar i administrar bases de dades de MongoDB sense necessitat d'utilitzar la l\u00ednia de comandos. https://downloads.mongodb.com/compass/mongodb-compass-1.45.3-win32-x64.exe","title":"\ud83d\udda5\ufe0fInstal\u00b7laci\u00f3 en Windows"},{"location":"3__mongodb/#33-funcionament-de-mongodb","text":"Recordeu que tindrem dues teminals: Una amb el servidor en marxa (i que no hem de tancar): mongod Una altra amb el client que es connecta al servidor: mongosh Probar el funcionament Per a provar el seu funcionament, anem a fer alguns comandos: Mostrar la versi\u00f3 del servidor MongoDB => db.version() Mostrar totes les bases de dades en el teu servidor MongoDB => show dbs Mostrar el nom de la BD del servidor MongoDB => db.getName() Mostrar totes les col\u00b7leccions en la base de dades seleccionada => show collections","title":"3.3 - Funcionament de MongoDB"},{"location":"3__mongodb/#34-utilitzacio-de-variables","text":"Com coment\u00e0vem el que m\u00e9s utilitzarem del llenguatge Javascript \u00e9s la utilitzaci\u00f3 de variables, que ens pot ser molt \u00fatil en algunes ocasions. Podrem utilitzar-les durant la sessi\u00f3, per\u00f2 evidentment no perduraran d'una sessi\u00f3 a l'altra. Per a definir una variable podem posar opcionalment davant la paraula reservada var , per\u00f2 no \u00e9s necessari. Posarem el nom de la variable, el signe igual, i a continuaci\u00f3 el valor de la variable, que pot ser una constant, o una expressi\u00f3 utilitzant constants, operadors, altres variables, funcions de Javascript, ... Especialment interessant s\u00f3n les variables que poden contenir un document JSON. Per exemple: > a = 30 30 > b = a/4 7.5 > Math.sqrt(b) 2.7386127875258306 > doc = {camp1: \"Hola\", camp2: 45, camp3: new Date()} { \"camp1\" : \"Hola\", \"camp2\" : 45, \"camp3\" : ISODate(\"2022-01-16T18:07:51.118Z\") } > Una variable de tipus JSON es podr\u00e0 modificar molt f\u00e0cilment, tota ella, o algun dels elements. Per a arribar als elements posarem nom_variable.nom_camp : > doc.camp4 = 3.141592 3.141592 > doc.camp5 = [ 2 , 4 , 6 , 8] [ 2, 4, 6, 8 ] I si ara intentem traure el contingut de la variable: > doc { \"camp1\" : \"Hola\", \"camp2\" : 45, \"camp3\" : ISODate(\"2022-01-16T18:07:51.118Z\"), \"camp4\" : 3.141592, \"camp5\" : [ 2, 4, 6, 8 ] } > Tamb\u00e9 hem de fer constar que en un document, que ser\u00e0 de tipus JSON (pr\u00e0cticament), ser\u00e0 un conjunt de parelles clau-valor, amb algunes restriccions: El document (que moltes vegades l'associarem a objecte de JSON) va entre claus ( { } ) Els elements d'un objecte van separats per comes, i s\u00f3n parelles clau-valor. La clau no pot ser nula, ni repetir-se en el mateix objecte (s\u00ed en diferents objectes, clar) Els valors s\u00f3n dels tipus que veurem en l'apartat seg\u00fcent. Un document guardat ha de contenir obligat\u00f2riament un camp anomenat _id , i que contindr\u00e0 un valor \u00fanic en la col\u00b7lecci\u00f3 i servir\u00e0 per a identificar-lo. Si en guardar un document no li hem posat camp _id , el generar\u00e0 autom\u00e0ticament MongoDB.","title":"3.4 - Utilitzaci\u00f3 de variables"},{"location":"3__mongodb/#35-tipus-de-dades","text":"Els valors dels elements, \u00e9s a dir de les parelles clau valor, poden ser d'uns quants tipus. Fem un r\u00e0pid rep\u00e0s. En els exemples que van a continuaci\u00f3 definim senzillament parelles clau-valor dels diferents tipus, o en tot cas ens ho guardem en variables, per\u00f2 no guardarem encara en la Base de Dades (ho farem en la seg\u00fcent pregunta). Quan guardem en una variable es mostrar\u00e0 el prompt, la definici\u00f3 de la variable i despr\u00e9s el resultat d'haver guardat la variable. Utilitzarem requadres blancs. Els requadres grocs s\u00f3n \u00fanicament de la definici\u00f3 d'una clau-valor d'un determinat tipus NULL M\u00e9s que un tipus de dades \u00e9s un valor, millor dit, l'abs\u00e8ncia de valor { \"x\" : null } BOOLEAN El tipus boole\u00e0, que pot agafar els valors true o false. { \"x\" : true } { \"y\" : false } NUMBER Per defecte, el tiups de dades num\u00e8rics ser\u00e0 el de coma flotant ( float ), simple precisi\u00f3. Si volem un altre tiups (enter, doble precisi\u00f3, ...) ho haurem d'indicar expressament. Aix\u00ed els dos seg\u00fcents valors s\u00f3n float: { \"x\" : 3.14 } { \"y\" : 3 } Si volem que siga estrictament enter, per exemple, haurem d'utilitzar una funci\u00f3 de conversi\u00f3: { \"x\" : NumberDouble(\"3.14\") } { \"y\" : NumberInt(\"3\") } STRING Es pot guardar qualsevol cadena amb car\u00e0cters de la codificaci\u00f3 UTF-8 { x : \"Hola, qu\u00e8 tal?\"} DATE Es guarda data i hora, i internament es guarden en milisegons des de l'any inicial. No es guarda el Time zone , \u00e9s a dir, la desviaci\u00f3 respecte a l'hora internacional. { x : ISODate(\"2022-01-16T11:15:27.471Z\") } Normalment utilitzarem funcions de tractament de la data-hora. L'anterior era per a convertir el string en data-hora. La seg\u00fcent \u00e9s per a obtenir la data- hora actual: { x : new Date() } \u00c9s a dir, que si no posem par\u00e0metre, ens d\u00f3na la data-hora actual. Per\u00f2 li podem posar com a par\u00e0metre la data-hora que volem que genere. En aquest exemple, nom\u00e9s posem data, per tant l'hora ser\u00e0 les 00:00: > z = new Date(\"2022-01-16\") ISODate(\"2022-01-16T00:00:00Z\") En aquest s\u00ed que posem una determinada hora, i observeu com hem deposar la T (Time) entre el dia i l'hora: > z = new Date(\"2022-02-16T18:00\") ISODate(\"2022-01-16T18:00:00Z\") \u00c9s molt important que posem sempre New Date() per a generar una data-hora. Si posem \u00fanicament Date() , el que estem generant \u00e9s un string (segurament amb la data i hora actual, per\u00f2 un string): > z = Date(\"2022-01-16\") Sun Jan 16 2022 22:20:09 GMT+0100 (CET) ARRAY \u00c9s un conjunt d'elements, cadascun de qualsevol tipus, encara que el m\u00e9s habitual \u00e9s que siguen del mateix tipus. Van entre claud\u00e0tors ( [ ] ) i els elements separats per comes. { x : [ 2 , 4 , 6 , 8 ] } Com coment\u00e0vem, cada element de l'array pot ser de qualsevol tipus: { y : [ 2 , 3.14 , \"Hola\" , new Date() ] } En MongoDB podrem treballar molt b\u00e9 amb arrays, i tindrem operacions per a poder buscar dins de l'array, modificar un element, crear \u00edndex, ... DOCUMENTS (OBJECTES) Els documents poden contenir com a elements uns altres documents ( objectes en la terminologia JSON, per\u00f2 documents en la terminologia de MongoDB). Van entre claus ( { } ), i els elements que contindran van separats per comes i seran parelles clau-valor de qualsevol tipus (fins i tot altres documents). { x : { a : 1 , b : 2 } } Posar documents dins d'uns altres documents (el que s'anomena embedded document ) ens permet guardar la informaci\u00f3 d'una manera m\u00e9s real, no tan plana. Aix\u00ed per exemple, les dades d'una persona les podr\u00edem definir de la seg\u00fcent manera. Les posarem en una variable, per veure despr\u00e9s com podem accedir als diferents elements, encara que el m\u00e9s normal ser\u00e0 guardar-lo en la Base de Dades (amb insert() ). Si copiem el que va a continuaci\u00f3 al terminal de Mongo, ens apareixer\u00e0 amb un format estrany. \u00c9s perqu\u00e8 la sent\u00e8ncia d'assignaci\u00f3 a la variable ocupa m\u00e9s d'una l\u00ednia, i apareixeran 3 punts al principi per a indicar que continua la sent\u00e8ncia. Per\u00f2 funcionar\u00e0 perfectament : doc = { nom:\"Joan Mart\u00ed\", adre\u00e7a: { carrer:\"Major\", n\u00famero:1, poblaci\u00f3:\"Castell\u00f3\" } , tel\u00e8fons : [964223344,678345123] } Observeu com aquesta estructura que ha quedat tan clara, segurament en una Base de Dades Relacional ens hauria tocat guardar en 3 taules: la de persones, la d'adreces i la de tel\u00e8fons. Per a accedir als elements d'un document pos\u00e0vem el punt. Doncs el mateix per als elements d'un document dins d'un document. I tamb\u00e9 podem accedir als elements d'un array, posant l'\u00edndex entre claud\u00e0tors. > doc.nom Joan Mart\u00ed > doc.adre\u00e7a { \"carrer\" : \"Major\", \"n\u00famero\" : 1, \"poblaci\u00f3\" : \"Castell\u00f3\" } > doc.adre\u00e7a.carrer Major > doc.tel\u00e8fons [ 964223344, 678345123 ] > doc.tel\u00e8fons[0] 964223344 OBJECT ID \u00c9s un tipus que defineix MongoDB per a poder obtenir valors \u00fanics. \u00c9s el valor per defecte de l'element _id , necessari en tot document (atenci\u00f3: en un document, no en un element de tipus document que hem dit equivalent a l'objecte de JSON). \u00c9s un n\u00famero long, \u00e9s a dir que utilitza 24 bytes. Farem proves de la seua utilitzaci\u00f3 en la se\u00fcent pregunta, en el moment d'inserir diferents documents.","title":"3.5 - Tipus de dades"},{"location":"3__mongodb/#36-operacions-crud-basiques","text":"En aquest punt anem a veure les operacions m\u00e9s b\u00e0siques, per a poder treballar sobre exemples pr\u00e0ctics, i aix\u00ed disposar ja d'unes dades inicials per a practicar.","title":"3.6 - Operacions CRUD B\u00e0siques"},{"location":"3__mongodb/#creacio-insert","text":"MongoDB proporciona els m\u00e8todes seg\u00fcents per inserir documents en una col\u00b7lecci\u00f3: db.collection. insertOne() db.collection. insertMany() La funci\u00f3 insert afegir\u00e0 documents a una col\u00b7lecci\u00f3. En el par\u00e0metre posem el document directament, o una variable que continga el document. Si la col\u00b7lecci\u00f3 no existia, la crear\u00e0 i despr\u00e9s afegir\u00e0 el document. En la seg\u00fcent sent\u00e8ncia estem treballant sobre la col\u00b7lecci\u00f3 exemple , que segurament ja existir\u00e0 de quan vam fer la pregunta 3.1 d'instal\u00b7laci\u00f3 de MongoDB, que per a provar vam inserir un document. Per\u00f2 si no existia, la crear\u00e0 sense problemes. > db.exemple.insertOne({ msg : \"Hola, qu\u00e8 tal?\"}) Acabem d'inserir un nou document, i aix\u00ed ens ho avisa ( { \"nInserted\" : 1 } , s'ha inserit un document). Autom\u00e0ticament haur\u00e0 creat un element _id de tipus ObjectId , ja que li fa falta per a identificar el document entre tots els altres de la col\u00b7lecci\u00f3. Insertem un altre document: > db.exemple.insertOne({ msg2 : \"Com va la cosa?\"}) I en aquest exemple ens guardem el document en la variable doc , i despr\u00e9s l'inserim > doc = { msg3 : \"Per ac\u00ed no ens podem queixar ...\"} > db.exemple.insertOne(doc) Tamb\u00e9 ens indica que ha inserit un document. I haur\u00e0 creat tamb\u00e9 el camp _id com veurem en el seg\u00fcent punt. Inserci\u00f3 especificant el id En els document que hem inserit fins el moment, no hem especificat el camp _id , i Mongo l'ha generat autom\u00e0ticament de tipus ObjectId . Per\u00f2 nosaltres podrem posar aquest camp _id amb el valor que vulguem. Aix\u00f2 s\u00ed, haurem d'estar segurs que aquest valor no l'agafa cap altre document de la col\u00b7lecci\u00f3, o ens donar\u00e0 un error. Aix\u00ed per exemple anem a inserir la informaci\u00f3 d'uns alumnes. Els posarem en una col\u00b7lecci\u00f3 nova anomenada alumnes , i els intentarem posar un _id personal. Per exemple posarem els n\u00fameros 51, 52, 53, ... > db.alumnes.insertOne ({_id: 51 , nom: \"Rebeca\" , cognoms: \"Mart\u00ed Peral\"}) Ha anat b\u00e9, i si mirem els documents que tenim en la col\u00b7lecci\u00f3, comprovarem que ens ha respectat el _id : > db.alumnes.find() { \"_id\" : 51, \"nom\" : \"Rebeca\", \"cognoms\" : \"Mart\u00ed Peral\" } Per\u00f2 si intentem inserir un altre document amb el mateix _id (51), ens donar\u00e0 error: > db.alumnes.insertOne ({_id: 51 , nom: \"Raquel\" , cognoms: \"Gomis Arnau\"}) WriteResult({ \"nInserted\" : 0, \"writeError\" : { \"code\" : 11000, \"errmsg\" : \"E11000 duplicate key error collection: test.alumnes index: _id_ dup key: { : 51.0 }\" } }) > Ens avisa que estem duplicant la clau principal , \u00e9s a dir l'identificador. Inserci\u00f3 m\u00faltiple Quan els documents que volem inserir s\u00f3n senzills, podem inserir m\u00e9s d'un a la vegada, posant dis del insertMany() un array amb tots els elements. En el seg\u00fcent exemple creem uns quants nombres primers en la col\u00b7lecci\u00f3 del mateix nom: > db.nombresprimers.insertMany( [ {_id:2} , {_id:3} , {_id:5} , {_id:7} , {_id:11} > , {_id:13} , {_id:17} , {_id:19} ] ) BulkWriteResult({ \"writeErrors\" : [ ], \"writeConcernErrors\" : [ ], \"nInserted\" : 8, \"nUpserted\" : 0, \"nMatched\" : 0, \"nModified\" : 0, \"nRemoved\" : 0, \"upserted\" : [ ] }) > Ens avisa que ha fet 8 insercions, i ac\u00ed els tenim: > db.nombresprimers.find() { \"_id\" : 2 } { \"_id\" : 3 } { \"_id\" : 5 } { \"_id\" : 7 } { \"_id\" : 11 } { \"_id\" : 13 } { \"_id\" : 17 } { \"_id\" : 19 } >","title":"Creaci\u00f3: insert"},{"location":"3__mongodb/#lectura-find","text":"MongoDB ofereix els m\u00e8todes seg\u00fcents per llegir documents d'una col\u00b7lecci\u00f3: db.collection. find() recuperar\u00e0 tots els documents de la col\u00b7lecci\u00f3, encara que podrem posar criteris per a que ens torne tots els documents que acomplesquen aquestos criteris (ho veurem m\u00e9s avant). Exemple: > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Com va la cosa?\" } { \"_id\" : ObjectId(\"56ce3237c61e04ba81def50d\"), \"msg3\" : \"Per ac\u00ed no ens podem queixar ...\" } > En tots els casos podem comprovar que \u00e9s cert el que ven\u00edem afirmant, que ha creat autom\u00e0ticament l'element _id per a cada document guardat. Evidentment, cadasc\u00fa de nosaltres tindr\u00e0 una valors diferents.","title":"Lectura: find"},{"location":"3__mongodb/#eliminacio-delete","text":"Per a esborrar un document d 'una col\u00b7lecci\u00f3 utilitzarem la funci\u00f3 deleteOne , passant-li com a par\u00e0metre la condici\u00f3 del document o documents a esborrar. MongoDB ofereix els m\u00e8todes seg\u00fcents per eliminar documents d'una col\u00b7lecci\u00f3: db.collection. deleteOne() db.collection. deleteMany() > db.nombresprimers.deleteOne( {\"_id\" : 19} ) Ens avisa que ha esborrat un document. La condici\u00f3 no cal que siga sobre el camp _id . Pot ser sobre qualsevol camp, i esborrar\u00e0 tots els que coincideixen . > db.exemple.deleteMany( {\"msg3\" : \"Per ac\u00ed no ens podem queixar ...\"} ) Tamb\u00e9 tenim la possibilitat d'esborrar tota una col\u00b7lecci\u00f3 amb la funci\u00f3 drop() . Pareu atenci\u00f3 perqu\u00e8 \u00e9s molt senzilla d'eliminar, i per tant, potencialment molt perillosa. > db.nombresprimers.drop() true >","title":"Eliminaci\u00f3: delete"},{"location":"3__mongodb/#actualitzacio-update","text":"La funci\u00f3 update servir\u00e0 per a actualitzar un document ja guardat. Tindr\u00e0 dos par\u00e0metres: El primer par\u00e0metre ser\u00e0 la condici\u00f3 per a trobar el document que s'ha d'actualitzar. El segon par\u00e0metre ser\u00e0 el nou document que substituir\u00e0 l'anterior MongoDB ofereix els m\u00e8todes seg\u00fcents per actualitzar els documents d'una col\u00b7lecci\u00f3: db.collection. updateOne() db.collection. updateMany() db.collection. replaceOne() Per exemple, si mirem les dades actuals: > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Com va la cosa?\" } Podem comprovar el contingut del segon document, el que te msg2 . Anem a modificar-lo: en el primer par\u00e0metre posem condici\u00f3 de recerca (nom\u00e9s hi haur\u00e0 un) i en el segon posem el nou document que substituir\u00e0 l'anterior amb el par\u00e0metre $set . > db.exemple.updateOne( {msg2:\"Com va la cosa?\"} , {$set: {msg2:\"Qu\u00e8? Com va la cosa?\"}}) Observeu que la contestaci\u00f3 del update () \u00e9s que ha fet match (hi ha hagut coincid\u00e8ncia) amb un document, i que ha modificat un. Si no en troba cap, no donar\u00e0 error, senzillament dir\u00e0 que ha fet match amb 0 documents, i que ha modificat 0 documents. Mirem com efectivament ha canviat el segon document > db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } { \"_id\" : ObjectId(\"56ce31f6c61e04ba81def50c\"), \"msg2\" : \"Qu\u00e8? Com va la cosa?\" } Ens vindran molt b\u00e9 les variables per a les actualitzacions, ja que en moltes ocasions ser\u00e0 modificar lleugerament el document, canviant o afegint algun element. Ho podrem fer c\u00f2modament amb la variable: primer guardem el document a modificar en una variable; despr\u00e9s modifiquem la variable; i per \u00faltim fem l'operaci\u00f3 d'actualitzaci\u00f3. Evidentment si tenim alguna variable amb el contingut del document ens podr\u00edem estalviar el primer pas. > doc1 = db.exemple.find() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\" } > doc1.titol = \"Missatge 1\" Missatge 1 > db.exemple.updateOne( {msg:\"Hola, qu\u00e8 tal?\"} , doc1) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > db.exemple.findOne() { \"_id\" : ObjectId(\"56ce310bc61e04ba81def50b\"), \"msg\" : \"Hola, qu\u00e8 tal?\", \"titol\" : \"Missatge 1\" } > Reempla\u00e7ar un document Per reempla\u00e7ar tot el contingut d'un document excepte el _id, passeu un document completament nou com a segon argument a Collection. replaceOne() . En reempla\u00e7ar un document, aquest ha de constar \u00fanicament de parells camp-valor. No podeu incloure expressions d'operadors d'actualitzaci\u00f3. El document de substituci\u00f3 pot tenir camps diferents dels del document original. Al document de reempla\u00e7ament, podeu ometre el _id, ja que _id es immutable. No obstant aix\u00f2, si l'inclou _id, heu de tenir el mateix valor que l'actual. db.exemple.replaceOne( { \"msg\" : \"Hola, qu\u00e8 tal?\" }, { \"msg\" : \"Hola, qu\u00e8 tal?\" , \"titol2\" : \"Missatge 2\" } )","title":"Actualitzaci\u00f3 - update"},{"location":"3__mongodb/#37-operadors-dactualitzacio","text":"En el apartat anterior hem vist l'actualitzaci\u00f3 de documents ja existents a la Base de Dades. Aquesta actualitzaci\u00f3 la f\u00e9iem modificant tot el document, encara que tenim la variant de guardar el document en una variable, modificar aquesta variable i despr\u00e9s fer l'actualitzaci\u00f3 amb aquesta variable. Per\u00f2 observeu que continua sent una modificaci\u00f3 de tot el document, una substituci\u00f3 del document antic per un document nou. En aquest apartat veurem la utilitzaci\u00f3 d'uns modificadors ( modifiers ) de l'operaci\u00f3 update() , que ens permetran modificar documents de forma potent: creant i eliminant claus (elements) d'un document, o canviant-los, i fins i tot afegir o eliminar elements d'un array.","title":"3.7 - Operadors d'actualitzaci\u00f3"},{"location":"3__mongodb/#set","text":"El modificador $set assigna un valor a un camp del document seleccionat de la Base de Dades. Si el camp ja existia, modificar\u00e0 el valor, i si no existia el crear\u00e0. La sintaxi del modificador $set \u00e9s la seg\u00fcent: { $set : { clau : valor} } Per\u00f2 recordeu que \u00e9s un modificador, i l'hem d'utilitzar dins d'una operaci\u00f3 d'actualitzaci\u00f3. Anir\u00e0 en el segon par\u00e0metre del update() , i per tant amb aquestos modificadors ja no posem tot el document en el segon par\u00e0metre, sin\u00f3 \u00fanicament l'operador de modificaci\u00f3. Mirem-ho millor en un exemple: > db.alumnes.insertOne( {nom:\"Abel\", cognoms:\"Bernat Carrera\"} ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\" } > Suposem ara que li volem afegir l'edat. Abans ho far\u00edem guardant el document en una variable, i afegint el camp, per a guardar despr\u00e9s. Ara ho tenim m\u00e9s f\u00e0cil: > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {edat:21} } ) Ha trobat un, i l'ha modificat. Evidentment, si hi haguera m\u00e9s d'un alumne a mb el nom Abel, els modificaria tots. > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 21 } Es pot especificar m\u00e9s d'un camp amb els valor corresponents. Si no existien es crearan, i si ja existien es modificaran: > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {nota: 8.5 , edat:22} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : 8.5 } I fins i tot es pot canviar el tipus d'un camp determinat, i utilitzar arrays, i objectes, ... > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {nota: [8.5,7.5,9], adre\u00e7a:{carrer:\"Major\",numero:7,cp:\"12001\"} } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12001\" } } Podem fins i tot modificar ara nom\u00e9s el valor d'un camp d'un objecte del document. Per exemple, anem a modificar el codi postal de l'anterior alumne. La manera d'arribar al codi postal ser\u00e0 adre\u00e7a.cp , per\u00f2 haurem d'anar amb compte que vaja entre cometes per a que el trobe: > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {adre\u00e7a.cp:\"12502\"} } ) uncaught exception: SyntaxError: missing : after property id : @(shell):1:49 > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {\"adre\u00e7a.cp\":\"12502\"} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" } }","title":"$set"},{"location":"3__mongodb/#unset","text":"El modificador $unset servir\u00e0 per a eliminar elements (camps) d'un o uns documents. Si el camp existia, l'eliminar\u00e0, i si no existia, no donar\u00e0 error (avisar\u00e0 que s'han modificat 0 documents). La sintaxi \u00e9s: { $unset : {camp : 1 } } Haurem de posar un valor al camp que anem a esborrar per a mantenir la sintaxi correcta, i posem 1 que equival a true. Tamb\u00e9 podr\u00edem posar -1, que equival a false, per\u00f2 aleshores no l'esborraria, i per tant no far\u00edem res. Sempre posarem 1. Mirem el seg\u00fcent exemple. Afegim un camp, que ser\u00e0 el n\u00famero d'ordre, i despr\u00e9s el llevarem. > db.alumnes.updateOne( {nom:\"Abel\"} , { $set: {num_ordre:10} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"num_ordre\" : 10 } > db.alumnes.updateOne( {nom:\"Abel\"} , { $unset: {num_ordre:1} } ) > db.alumnes.updateOne( {nom:\"Abel\"} , { $unset: {puntuacio:1} } ) Hem afegit primer el camp num_ordre , i hem mostrat el document per comprovar que existeix. Despr\u00e9s esborrem el camp num_ordre (i ens confirma que ha modificat un document). Despr\u00e9s intentem esborrar un camp que no existeix, puntuacio . No d\u00f3na error, per\u00f2 ens avisa que ha modificat 0 documents. Podem comprovar al final com el document ha quedat com esper\u00e0vem. > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" } }","title":"$unset"},{"location":"3__mongodb/#rename","text":"El modificador $rename canviar\u00e0 el nom d'un camp. Si no existia, no donar\u00e0 error i senzillament no el modificar\u00e0. Hem de cuidar de posar el nou nom del camp entre cometes, per a que no done error. La sintaxi \u00e9s: { $rename : { camp1 : \"nou_nom1\" , camp2 : \"nou_nom2\" , ... } } Per exemple, canviem el nom del camp nota a notes : > db.alumnes.updateOne( {nom:\"Abel\"} , { $rename: {nota:\"notes\"} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"notes\" : [ 8.5, 7.5, 9 ] } Observeu que l'ha canviat de lloc, cosa que ens fa pensar que en canviar de nom un camp, el que fa \u00e9s tornar a crear-lo amb el nou nom, i esborrar el camp antic. En aquest exemple tornem a canviar el nom a nota , i intentem canviar el nom a un camp inexistent, camp1 . No donar\u00e0 error. > db.alumnes.updateOne( {nom:\"Abel\"} , { $rename: {camp1: \"camp2\" , notes:\"nota\"} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 8.5, 7.5, 9 ] }","title":"$rename"},{"location":"3__mongodb/#inc","text":"Com cabria esperar, el modificador $inc servir\u00e0 per a incrementar un camp num\u00e8ric. Si el camp existia, l'incrementar\u00e0 en la quantitat indicada. Si no existia, crear\u00e0 el camp amb un valor inicial de 0, i incrementar\u00e0 el valor amb la quantitat indicada. La quantitat pot ser positiva, negativa o fins i tot amb part fraccion\u00e0ria. Sempre funcionar\u00e0 b\u00e9, excepte quan el camp a incrementar no siga num\u00e8ric, que donar\u00e0 error. La sintaxi \u00e9s aquesta: { $inc : {camp : quantitat } } En els seg\u00fcents exemples, incrementem un camp nou (per tant el crear\u00e0 amb el valor especificat), i despr\u00e9s l'incrementem en quantitats positives, negatives i fraccion\u00e0ries, concretament l'inicialitzem amb un 2 , i desp\u00e9s l'incrementem en 5 , en -4 i en 2.25 , per tant el resultat final ser\u00e0 5.25 : > db.alumnes.updateOne( {nom:\"Abel\"} , { $inc: {puntuacio:2} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"puntuacio\" : 2 } > db.alumnes.updateOne( {nom:\"Abel\"} , { $inc: {puntuacio:5} } ) > db.alumnes.updateOne( {nom:\"Abel\"} , { $inc: {puntuacio:-4} } ) > db.alumnes.updateOne( {nom:\"Abel\"} , { $inc: {puntuacio:2.25} } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"nota\" : [ 8.5, 7.5, 9 ], \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"puntuacio\" : 5.25 }","title":"$inc"},{"location":"3__mongodb/#min","text":"Actualitza el valor del camp a un valor especificat si aquest \u00e9s menor que el valor actual del camp. db.alumnes..updateOne( { nom:\"Abel\"}, { $min: { puntuacio: 1 } } ) El valor de puntuaci\u00f3 s'actualitza a 1 perqu\u00e8 \u00e9s menor que el valor actual de 5.","title":"$min"},{"location":"3__mongodb/#max","text":"Actualitza el valor del camp a un valor especificat si aquest \u00e9s major que el valor actual del camp. db.alumnes..updateOne( { nom:\"Abel\"}, { $max: { puntuacio: 7 } } ) El valor de puntuaci\u00f3 s'actualitza a 7 perqu\u00e8 \u00e9s menor que el valor actual de 1.","title":"$max"},{"location":"3__mongodb/#mul","text":"Multiplica el valor d'un camp per un n\u00famero., $currentDate db.alumnes.updateOne({ nom:\"Abel\"},{ $mul: {puntuacio: 2}}) L'operador $mul multiiplica el camp puntuaci\u00f3 per 2.","title":"$mul"},{"location":"3__mongodb/#arrays","text":"Per a accedir directament a un element d'un array d'un determinat document es pot utilitzar la seg\u00fcent sintaxi: \"array.index\" Hem de tenir present que el primer element de l'array \u00e9s el de sub\u00edndex 0. I no us oblideu de tancar-ho tot entre comentes per a que ho puga trobar. Si no existeix l'element amb el sub\u00edndex indicat, donar\u00e0 error. Per exemple, anem a pujar un punt la primera nota de l'alumne que estem utilitzant en tots els exemples : >db.alumnes.updateOne( {nom:\"Abel\"} , { $inc : { \"nota.0\" : 1 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9 ] }","title":"Arrays"},{"location":"3__mongodb/#actualitzacio-y","text":"$ Identifica un element en un array per actualitzar sense especificar expl\u00edcitament la posici\u00f3 de l'element en un array. Ejemplo: Modificar la primera nota mayor a 8 en el array nota db.alumnes.updateOne( { \"_id\": ObjectId(\"56df11d778549bdfbf2125e3\"), \"nota\": { $gt: 8 } }, { $set: { \"nota.$\": 10 } } ) $[] L'operador $[] es fa servir per actualitzar tots els elements en un array. Ejemplo: Aumentar en 1 punto todas las notas en el array nota db.alumnes.updateOne( { \"_id\": ObjectId(\"56df11d778549bdfbf2125e3\") }, { $inc: { \"nota.$[]\": 1 } } )","title":"Actualitzaci\u00f3: $ y $[]"},{"location":"3__mongodb/#insercio-push","text":"La manera m\u00e9s senzilla d'introduir un element en un array \u00e9s utilitzar $push sense m\u00e9s. Si existia l'array, introduir\u00e0 el o els nous elements al final. Si no existia l'array, el crear\u00e0 amb aquest o aquestos elements. La sintaxi \u00e9s: { $push : { clau : element } } Per exemple anem a afegir una nota a l'alumne de sempre, i posem-la diferent per veure que s'introdueix al final: > db.alumnes.updateOne( {nom:\"Abel\"} , { $push : { nota : 7 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9, 7 ] } Tamb\u00e9 hi ha manera d'introduir un element en una determinada posici\u00f3 que no siga al final, per\u00f2 es complica prou la cosa, ja que hem d'utilitzar per una banda el modificador $position per a dir on s'ha d'inserir, i per una altra banda el modificador $each per a poder especificar el o els valors que es volen inserir. Es posa a continuaci\u00f3 \u00fanicament de forma il\u00b7lustrativa. Per a inserir en una determinada posici\u00f3 hem d'utilitzar obligat\u00f2riament 2 modificadors m\u00e9s: $position indicar\u00e0 a partir de quina posici\u00f3 es far\u00e0 l'acci\u00f3 (normalment d'inserir en l'array, \u00e9s a dir, $push ) $each ens permet especificar una s\u00e8rie de valors com un array, i vol dir que es far\u00e0 l'operaci\u00f3 per a cada valor de l'array Els dos modificadors seguiran la sintaxi de sempre, de clau valor, per tant el conjunt de la sintaxi \u00e9s: { $ push : { clau_del_array : { $position : _posici\u00f3_ , $each : [ _valors_ ] } } } Ac\u00ed tenim un exemple on introdu\u00efm una nota en la primera posici\u00f3: > db.alumnes.updateOne( {nom:\"Abel\"} , { $push : { nota : { $position : 0 , $each > : [5] } } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9, 7 ] }","title":"Inserci\u00f3: $push"},{"location":"3__mongodb/#eliminacio-pop-i-pull","text":"Hi ha m\u00e9s d'una manera d'eliminar elements d'un array. $pop Si volem eliminar el primer element o l'\u00faltim, el modificador adequat \u00e9s $pop . La sintaxi \u00e9s { $pop : { clau : posicio } } On en posici\u00f3 podrem posar: -1 , i esborrar\u00e0 el primer element 1 , i esborrar\u00e0 l'\u00faltim En els seg\u00fcents exemples s'esborren primer l'\u00faltim element i despr\u00e9s el primer. > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9, 7 ] } > db.alumnes.updateOne( {nom:\"Abel\"} , { $pop : { nota : 1 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 5, 9.5, 7.5, 9 ] } > db.alumnes.updateOne( {nom:\"Abel\"} , { $pop : { nota : -1 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56df11d778549bdfbf2125e3\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9 ] } $pull Amb aquest modificador esborrarem els elements de l'array que coincidesquen amb una condici\u00f3, estiguen en la posici\u00f3 que estiguem. Observeu com es pot eliminar m\u00e9s d'un element. Per a poder comprovar-lo b\u00e9, primer inserim un altre element al final de l'array, amb el valor 7.5 (si heu seguit els mateixos exemples que en aquestos apunts, aquest valor ja es troba en la segona posici\u00f3). > db.alumnes.updateOne( {nom:\"Abel\"} , { $push : { nota : 7.5 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 7.5, 9, 7.5 ] } Ara anem a esborrar amb $pull l'element de valor 7.5 > db.alumnes.update( {nom:\"Abel\"} , { $pull : { nota : 7.5 } } ) > db.alumnes.find() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Carrera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] }","title":"Eliminaci\u00f3: $pop i $pull"},{"location":"3__mongodb/#38-operadors-de-consulta","text":"En la pregunta anterior hem vist com introduir, eliminar i modificar documents. Les consultes de documents han segut molt senzilles, per a comprovar \u00fanicament els resultats. En aquesta pregunta veurem en profunditat la consulta de documents. Funcion find() . Veurem en profunditat la seua sintaxi i pot\u00e8ncia. Limitarem i ordenarem tamb\u00e9 els resultats Fins i tot podrem elaborar m\u00e9s els resultats, agrupant els resultats, utilitzant funcions d'agregaci\u00f3 (o millor dir operadors d'agregaci\u00f3) i donant-los un aspecte diferent","title":"3.8 - Operadors de consulta"},{"location":"3__mongodb/#parametres-de-find","text":"La funci\u00f3 find() s'ha comparat tradicionalment amb la sent\u00e8ncia SELECT de SQL. Sempre tornar\u00e0 un conjunt de documents, que poden variar des de no tornar cap document, a tornar-los tots els de la col\u00b7lecci\u00f3. La funci\u00f3 find() pot tenir uns quants par\u00e0metres. El primer indica una condici\u00f3 o criteri, i tornar\u00e0 aquells documents de la col\u00b7lecci\u00f3 que acomplisquen la condici\u00f3 o criteri. Aquesta condici\u00f3 ve donada en forma de document (o objecte) JSON, i \u00e9s com l'hav\u00edem vist en la funci\u00f3 update() : db.col_leccio1.find( { clau1 : valor1 } ) Tornar\u00e0 tots els documents de la col\u00b7lecci\u00f3 col_leccio1 que tinguen el camp clau1 i que en ell tinguen el valor valor1 . Aquest criteri pot ser el complicat que fa\u00e7a falta, formant-lo en JSON. Pot tenir m\u00e9s d'un membre. En definitiva, tornar\u00e0 aquells documents que facen matching amb el document del criteri, \u00e9s a dir, funcionaria com un and en cas que tinga m\u00e9s d'un membre en la condici\u00f3 db.col_leccio1.find( { clau1 : valor1 , clau2 : valor2 } ) que tornaria aquells documents de la col_lecci\u00f31 que tenen el camp clau1 amb el valor valor1 i que tenen el camp clau2 amb el valor valor2 Si no volem posar cap criteri, per a que els torne tots, no posem res com a par\u00e0metre, o encara millor, li passem un document (objecte) buit, de manera que tots els documents de la col\u00b7lecci\u00f3 faran matching amb ell. db.col_leccio1.find( { } ) El segon par\u00e0metre ens servir\u00e0 per a delimitar els camps dels documents que es tornaran. Tamb\u00e9 tindr\u00e0 el format JSON d'un objecte al qual li posarem com a claus els diferents camps que volem que apareguen o no, i com a valor 1 per a que s\u00ed que apareguen i 0 per a que no apareguen. Si posem algun camp a que s\u00ed que aparega (\u00e9s a dir, amb el valor 1), els \u00fanics que apareixeran seran aquestos, a m\u00e9s del _id que per defecte sempre apareix. > db.alumnes.find({},{nom:1}) { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\" } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\" } Per tant si no volem que aparega _id posarem: > db.alumnes.find({},{_id:0}) { \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : {\"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } I si volem traure \u00fanicament el nom: > db.alumnes.find({},{nom:1,_id:0}) { \"nom\" : \"Abel\" } { \"nom\" : \"Berta\" } Per \u00faltim, com que a partir d'ara utilitzarem documents m\u00e9s complicats, si volem que ens apareguen els camps que retornem d'una forma un poc m\u00e9s elegant o bonica ( pretty ), posarem aquesta funci\u00f3 al final: find().pretty() > db.alumnes.find().pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" }","title":"Par\u00e0metres de find()"},{"location":"3__mongodb/#operadors","text":"Abans de comen\u00e7ar aquesta pregunta, anem a agafar unes dades de prova, que estan en el fitxer libros_ejemplo.json Nom\u00e9s heu de copiar el contingut del fitxer en la terminal del client de Mongo. Posem ac\u00ed el contingut per a que pugueu pegar-li una miradeta sense necessitat d'obrir-lo. Anir\u00e0 b\u00e9 per als exemples posteriors. db.libro.insertOne({ \"_id\":\"9788408117117\", \"titulo\":\"Circo M\u00e1ximo\", \"autor\":\"Santiago Posteguillo\", \"editorial\":\"Planeta\", \"enstock\":true, \"paginas\":1100, \"precio\":21.75, \"fecha\":new ISODate(\"2013-08-29T00:00:00Z\"), \"resumen\":\"Circo M\u00e1ximo, de Santiago Posteguillo, que ha escrito otras obras de narrativa hist\u00f3rica como Las Legiones Malditas o La traici\u00f3n de Roma, es la segunda parte de la trilog\u00eda de Trajano, que comenz\u00f3 con Los asesinos del emperador, un relato impactante, descomunal, descrito con un trepidante pulso narrativo destinado a trasla dar al lector a la Roma imperial de los c\u00e9sares. Santiago posteguillo se ha convertido en el autor espa\u00f1ol de referencia de la novela hist\u00f3rica sobre Roma y el mundo antiguo. Bienvenidos al mundo de Marco Ulpio Trajano. Circo M\u00e1ximo es la historia de Trajano y su gobierno, guerras y traiciones, lealtades insobornables e historias de amor imposibles. Hay una vestal, un juicio, inocentes acusados, un abogado especial, mensajes cifrados, c\u00f3digos secretos, batallas campales, fortalezas inexpugnables, asedios sin fin, dos aurigas rivales, el Anfiteatro, los gladiadores y tres carreras de cuadrigas. Hay tambi\u00e9n un caballo especial, diferente a todos, leyes antiguas olvidadas, sacrificios humanos, amargura y terror, pero tambi\u00e9n destellos de nobleza y esperanza, como la llama de Vesta, que mientras arde preserva a Roma. S\u00f3lo que hay noches en las que la llama del Templo de Vesta tiembla. La rueda de la Fortuna comienza entonces a girar. En esos momentos, todo puede pasar y hasta la vida del propio Trajano, aunque \u00e9l no lo sepa, corre peligro. Y, esto es lo mejor de todo, ocurri\u00f3: hubo un complot para asesinar a Marco Ulpio Trajano.\" }) db.libro.insertOne({ \"_id\":\"9788401342158\", \"titulo\":\"El juego de Ripper\", \"autor\":\"Isabel Allende\", \"editorial\":\"Plaza & Janes\", \"enstock\":true, \"paginas\":480, \"precio\":21.75, \"fecha\":new ISODate(\"2014-03-01T00:00:00Z\"), \"resumen\":\"Tal como predijo la astr\u00f3loga m\u00e1s reputada de San Francisco, una oleada de cr\u00edmenes comienza a sacudir la ciudad. En la investigaci\u00f3n sobre los asesinatos, el inspector Bob Mart\u00edn recibir\u00e1 la ayuda inesperada de un grupo de internautas especializados en juegos de rol, Ripper. 'Mi madre todav\u00eda est\u00e1 viva, pero la matar\u00e1 el Viernes Santo a medianoche', le advirti\u00f3 Amanda Mart\u00edn al inspector jefe y \u00e9ste no lo puso en duda, porque la chica hab\u00eda dado pruebas de saber m\u00e1s que \u00e9l y todos sus colegas del Departamento de Homicidios. La mujer estaba cautiva en alg\u00fan punto de los dieciocho mil kil\u00f3metros cuadrados de la bah\u00eda de San Francisco, ten\u00edan pocas horas para encontrarla con vida y \u00e9l no sab\u00eda por d\u00f3nde empezar a buscarla\", }) db.libro.insertOne({ \"_id\":\"9788496208919\", \"titulo\":\"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"autor\":\"George R.R. Martin\", \"editorial\":\"Gigamesh\", \"enstock\":true, \"paginas\":793, \"precio\":9.5, \"fecha\":new ISODate(\"2011-11-24T00:00:00Z\"), \"resumen\":\"Tras el largo verano, el invierno se acerca a los Siete Reinos. Lord Eddars Stark, se\u00f1or de Invernalia, deja sus dominios para unirse a la corte del rey Robert Baratheon el Usurpador, hombre d\u00edscolo y otrora guerrero audaz cuyas mayores aficiones son comer, beber y engendrar bastardos. Eddard Stark desempe\u00f1ar\u00e1 el cargo de M ano del Rey e intentar\u00e1 desentra\u00f1ar una mara\u00f1a de intrigas que pondr\u00e1 en peligro su vida... y la de los suyos. En un mundo cuyas estaciones duran d\u00e9cadas y en el que retazos de una magia inmemorial y olvidada surgen en los rincones m\u00e1s sombrios y maravillosos, la traici\u00f3n y la lealtad, la compasi\u00f3n y la sed de venganza, el amor y el poder hacen del juego de tronos una poderosa trampa que atrapa en sus fauces a los personajes... y al lector. 'El regreso triunfal de Martin a la fantas\u00eda de m\u00e1s alta calidad... con personajes desarrollados con maestr\u00eda, prosa h\u00e1bil y pura obstinaci\u00f3n.'\" }) db.libro.insertOne({ \"_id\":\"9788499088075\", \"titulo\":\"La ladrona de libros\", \"autor\":\"Markus Zusak\", \"editorial\":\"Debolsillo\", \"enstock\":false, \"paginas\":544, \"precio\":9.45, \"fecha\":new ISODate(\"2009-01-09T00:00:00Z\"), \"resumen\":\"En plena II Guerra Mundial, la peque\u00f1a Liesel hallar\u00e1 su salvaci\u00f3n en la lectura. Una novela preciosa, tremendamente humana y emocionante, que describe las peripecias de una ni\u00f1a alemana de nueve a\u00f1os desde que es dada en adopci\u00f3n por su madre hasta el final de la guerra. Su nueva familia, gente sencilla y nada afecta al na zismo, le ense\u00f1a a leer y a trav\u00e9s de los libros Rudy logra distraerse durante los bombardeos y combatir la tristeza. Pero es el libro que ella misma est\u00e1 escribiendo el que finalmente le salvar\u00e1 la vida.\", }) db.libro.insertOne({ \"_id\":\"9788415140054\", \"titulo\":\"La princesa de hielo\", \"autor\":\"Camilla Lackberg\", \"editorial\":\"Embolsillo\", \"enstock\":true, \"precio\":11, \"fecha\":new ISODate(\"2012-10-30T00:00:00Z\"), \"resumen\":\"Misterio y secretos familiares en una emocionante novela de suspense Erica vuelve a su pueblo natal tras el fallecimiento de sus padres, pero se va a encontrar con un nuevo drama. Aparentemente su amiga de la infancia, Alex, se ha suicidado. Pronto se descubre que no solamente fue asesinada sino que estaba embarazada. El primer sospechoso es Anders, un artista fracasado con quien Alex manten\u00eda una relaci\u00f3n especial. Pero poco despu\u00e9s de ser liberado por falta de pruebas, Anders aparece muerto en su domicilio. Con la ayuda del comisario Patrik, Erica investigar\u00e1 el pasado de su amiga Alex.\" }) db.libro.insertOne({ \"_id\":\"9788408113331\", \"titulo\":\"Las carreras de Escorpio\", \"autor\":\"Maggie Stiefvater\", \"editorial\":\"Planeta\", \"enstock\":false, \"paginas\":290, \"precio\":17.23, \"fecha\":new ISODate(\"2013-06-04T00:00:00Z\"), \"resumen\":\"En la peque\u00f1a isla de Thisby, cada noviembre los caballos de agua de la mitolog\u00eda celta emergen del mar. Y cada noviembre, los hombres los capturan para participar en una emocionante carrera mortal. En las carreras de Escorpio, algunos compiten para ganar. Otros para sobrevivir. Los jinetes intentan dominar a sus caballos de agua el tiempo suficiente para acabar la carrera. Algunos lo consiguen. El resto, muere en el intento. Sean Kendrick es el favorito, y necesita ganar la carrera para ganar, tambi\u00e9n, su libertad. Pero Puck Connolly est\u00e1 dispuesta a ser su m\u00e1s dura adversaria. Ella nunca quiso participar en las carreras. Pero no tiene elecci\u00f3n: o compite y gana o\u2026 lo pierde todo.\", }) db.libro.insertOne({ \"_id\":\"9788468738895\", \"titulo\":\"Las reglas del juego\", \"autor\":\"Anna Casanovas\", \"enstock\":true, \"paginas\":null, \"precio\":15.90, \"fecha\":new ISODate(\"2014-02-06T00:00:00Z\"), \"resumen\":\"Susana Lobato tiene la vida perfectamente planeada y est\u00e1 a punto de conseguir todo lo que quiere: va a tener su propio programa de noticias econ\u00f3micas y en dos meses va a casarse con un hombre maravilloso. Pero una noche Tim anula la boda y la abandona para perseguir un sue\u00f1o que no la incluye a ella.Kev MacMurray acaba de cumplir treinta y cinco a\u00f1os y siente que ha llegado el momento de dar un cambio a su vida. No sabe por qu\u00e9, pero \u00faltimamente se est\u00e1 asfixiando y est\u00e1 convencido de que no puede seguir donde est\u00e1. Lo \u00fanico que lo retiene es la boda de Tim, su mejor amigo.Pero Tim anula la boda y una noche Kev coincide con Susana y respira por primera vez en mucho tiempo.\u00bfPor qu\u00e9 no le hab\u00eda sucedido antes? Se supon\u00eda que \u00e9l y Susana no se soportaban \u00bfDesde cu\u00e1ndo siente que si no besa a la prometida de su mejor amigo no podr\u00e1 seguir respirando?Susana nunca hab\u00eda reaccionado as\u00ed con nadie. \u00bfPuede correr el riesgo de averiguar qu\u00e9 pasar\u00e1 si se entrega a Kev?Y qu\u00e9 pasar\u00e1 si vuelve Tim, \u00bfpodr\u00e1n dar un paso atr\u00e1s?.\", }) Podeu comprovar que hi ha 7 documents en la nova col\u00b7lecci\u00f3 libro : > db.libro.count() 7 I tamb\u00e9 podem consultar els t\u00edtols de forma c\u00f2moda: > db.libro.find( {} , {titulo:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\" } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } I un altre exemple, on consultem els llibres que estan en stock (hi ha un camp boole\u00e0 que ho diu: enstock ), mostrant t\u00edtol, editorial i preu > db.libro.find( {enstock: true} , {titulo:1 , editorial:1 , precio:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } I un \u00faltim exemple, on consultem els llibres que estan en stock i tenen un preu de 21.75 \u20ac, mostrant tot excepte el _id i el resum > db.libro.find( {enstock: true , precio: 21.75} , {titulo:1 , editorial:1 , > precio:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } Anem a mirar ara operadors que ens serviran per fer millor les consultes.","title":"Operadors"},{"location":"3__mongodb/#operadors-de-comparacio","text":"Fins ara en totes les condicions hem utilitzat la igualtat, si un determinat camp era igual a un determinat valor. Per\u00f2 hi ha infinitat de consultes en les quals voldrem altres operacions de comparaci\u00f3: major, major o igual, menor, ... Aquestos s\u00f3n els operadors de comparaci\u00f3: $lt ( less than ) menor $lte ( less than or equal ) menor o igual $gt ( gretaer than ) major $gte ( gretaer than or equal ) major o igual $ne ( not equal ) distint $eq ( equal ) igual (per\u00f2 aquest quasi que no caldria, perqu\u00e8 en no posar res es refereix a la igualtat com fins ara) La sintaxi per a la seua utilitzaci\u00f3 \u00e9s, com sempre, acoplar-se a la sintaxi JSON: clau : { $operador : valor [, ... ] } Aix\u00ed per exemple, per a buscar els llibres de m\u00e9s de 10 \u20ac: > db.libro.find( { precio : { $gt : 10 } } , { titulo:1 , precio:1 } ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"precio\" : 21.75 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } I per a buscar els llibres entre 10 i 20 \u20ac: > db.libro.find( { precio : { $gt : 10 , $lt:20 } } , { titulo:1 , precio:1 }) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9} \u00c9s especialment \u00fatil per a les dates, ja que dif\u00edcilment trobarem una data (i hora) exacta, i voldrem quasi sempre els documents anteriors a una data, o posteriors, o entre dues dates. Haurem d'anar amb compte pel tractament especial de les dates: hem de comparar coses del mateix tipus, i per tant la data amb la qual volem comparar l'haurem de tenir en forma de data: > var d = new ISODate(\"2013-01-01T00:00:00Z\") > db.libro.find( {fecha:{$gte:d} } , {fecha:1} ) { \"_id\" : \"9788408117117\", \"fecha\" : ISODate(\"2013-08-29T00:00:00Z\") } { \"_id\" : \"9788401342158\", \"fecha\" : ISODate(\"2014-03-01T00:00:00Z\") } { \"_id\" : \"9788408113331\", \"fecha\" : ISODate(\"2013-06-04T00:00:00Z\") } { \"_id\" : \"9788468738895\", \"fecha\" : ISODate(\"2014-02-06T00:00:00Z\") } $in Servir\u00e0 per a comprovar si el valor d'un camp est\u00e0 entre els d'una llista, proporcionada com un array. La sitaxi \u00e9s: clau : { $in : [valor1 , valor2 , ... , valorN] } I ac\u00ed tenim un exemple, els llibre de les editorials Planeta i Debolsillo: > db.libro.find( { editorial: {$in : [\"Planeta\" , \"Debolsillo\"]} } , {titulo: , editorial:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\"} { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\" } $nin \u00c9s el contrari, traura els que no estan en la llista. > db.libro.find( { editorial: {$nin : [\"Planeta\" , \"Debolsillo\"]} } , {titulo:1 , editorial:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Observeu com tamb\u00e9 trau els llibres que no tenen editorial, com \u00e9s el cas de l'\u00faltim llibre, Las reglas del juego $or L'operador anterior, $in , ja feia una esp\u00e8cie de OR, per\u00f2 sempre sobre el mateix camp. Si l'operaci\u00f3 OR la volem fer sobre camps distints, haurem d'utilitzar l'operador $or . La seua sintaxi ha de jugar amb la possibilitat de posar molts elements, i per tant conv\u00e9 l'array: $or : [ {clau1:valor1} , {clau2:valor2} , ... , {clauN:valorN} ] Ser\u00e0 cert si s'acompleix alguna de les condicions. Per exemple, traure els llibres que no estan en stock o que no tenen editorial: > db.libro.find( { $or : [ {enstock:false} , {editorial:null} ] } , {titulo:1 , enstock:1 , editorial:1} ) { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"enstock\" : false } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"enstock\" : false } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"enstock\" : true} $not Serveix per a negar una altra condici\u00f3. $not : { condici\u00f3 } Per exemple els llibres que no s\u00f3n de l'editorial Planeta (observeu que seria m\u00e9s senzill utilitzar l'operador $ne , per\u00f2 \u00e9s per a mostrar el seu funcionament: > db.libro.find( { editorial: {$not : {$eq:\"Planeta\"} } } , {titulo:1 , editorial:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } $exists Servir\u00e0 per a saber els documents que tenen un determinat camp clau : { $exists : _boolean_ } Depenet del valor boolean , el funcionament ser\u00e0: true : torna els documents en els quals existeix el camp, encara que el seu valor siga nul false : torna els documents que no tenen el camp. Anem a traure els llibres que tenen el camp paginas : > db.libro.find( { paginas: {$exists:true} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"paginas\" : 1100 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"paginas\" : 480 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"paginas\" : 793 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"paginas\" : 544 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"paginas\" : 290 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"paginas\" : null } Observeu com ens apareix tamb\u00e9 l'ultim llibre, que t\u00e9 el camp paginas amb el valor nul . En canvi si hagu\u00e9rem fet la consulta preguntant pels que s\u00f3n diferents de nul, no apareixeria aquest \u00faltim llibre: > db.libro.find( { paginas: {$ne:null} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"paginas\" : 1100 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"paginas\" : 480 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"paginas\" : 793 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"paginas\" : 544 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"paginas\" : 290 } I si posem false al valor en el $exists , \u00fanicament ens apareixer\u00e0 el llibre que no t\u00e9 el camp: > db.libro.find( { paginas: {$exists:false} } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } I per la mateixa ra\u00f3 que abans, si traiem els que tenen paginas a null, ens eixir\u00e0 tant qui no t\u00e9 el camp, com qui el t\u00e9 per\u00f2 amb valor nul: > db.libro.find( { paginas: null } , {titulo:1 , paginas:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"paginas\" : null} Per tant, per a segons quines coses, ens interessa l'operador $exists , en compte de jugar amb el nul.","title":"Operadors de comparaci\u00f3"},{"location":"3__mongodb/#expressions-regulars","text":"Mongo accepta les expressions regulars de forma nativa, cosa que d\u00f3na molta pot\u00e8ncia per a poder buscar informaci\u00f3 diversa. Les expressions regulars en Mongo tenen la mateixa sintaxi que en Perl, i que \u00e9s molt molt pareguda a la major part de llenguatges de programaci\u00f3. Mirem alguns exemples. Els llibres dins dels quals est\u00e0 la paraula juego : > db.libro.find( { titulo: /juego/ } , {titulo:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Ara que tenen la paraula juego sense importar maj\u00fascules o min\u00fascules: > db.libro.find( { titulo: /juego/i } , {titulo:1} ) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } I ara que tenen la paraula juego nom\u00e9s al principi. > db.libro.find( { titulo: /^juego/i } , {titulo:1} ) { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" } I ara els llibres que en el resum ( resumen ) tenen la paraula amiga o amigo , \u00e9s a dir amig seguit d'una a o una o : > db.libro.find( { resumen: /amig[ao]/i } , {titulo:1} ) { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" }","title":"Expressions regulars"},{"location":"3__mongodb/#arrays_1","text":"Les consultes dins d'arrays de Mongo s\u00f3n molt senzilles. La m\u00e9s senzilla \u00e9s quan busquem un valor d'un tipus senzill, i en aquest cas el que far\u00e0 Mongo \u00e9s buscar en tot l'array per si est\u00e0 aquest valor. \u00c9s a dir, exactament igual que el que hem fet fins ara. db.col_leccio1.find ( { clau_array : valor } ) Mirem-ho en un exemple. Anem a crear dos documents que tinguen un array cadascun, per exemple de colors. El creem en una col\u00b7lecci\u00f3 nova, anomenada colorins , en dos documents amb el mateix camp de tipus array, color , per\u00f2 amb dades diferents * *: > db.colorins.insert({color: [\"roig\",\"blau\",\"groc\"]}) > db.colorins.insert({color: [\"negre\",\"blanc\",\"roig\"]}) > db.colorins.find() { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Com es veu en la sintaxi, triar els documents que tenen un camp (en aquest cas d'array) que continga un valor, \u00e9s igual de senzill que quan es tracta d'un camp de tipus string, per exemple: > db.colorins.find({color:\"roig\"}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Tamb\u00e9 podem utilitzar qualsevol dels operadors vistos fins el moment, com per exemple l'operador $in , que mirar\u00e0 els documents que tenen algun dels colors que s'especifica a continuaci\u00f3: > db.colorins.find({color: {$in : [\"groc\",\"lila\"]} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } O per exemple tamb\u00e9 utilitzar expressions regulars : > db.colorins.find({color: /bl/ }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } $ all L'operador $all el podem utilitzar quan vulguem seleccionar els documents que en l'array tiguen tots els elements especificats. Per exemple, anem a buscar els document que tenen el color roig i blau. > db.colorins.find({color : { $all : [\"roig\",\"blau\"]} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } Sub\u00edndex Si volem mirar exactament una determinada posici\u00f3 de l'array, podem especificar la posici\u00f3 immediatament despr\u00e9s de la clau, separada per un punt . Recordeu que la primera posici\u00f3 \u00e9s la 0 . Hem de posar entre cometes la clau i la posici\u00f3, sin\u00f3 no sabr\u00e0 trobar-la. Per exemple, busquem els documents que tenen el roig en la primera posici\u00f3. > db.colorins.find({\"color.0\" : \"roig\"} ) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } Nota Accedir a una determinada posici\u00f3 \u00e9s f\u00e0cil, per\u00f2 no \u00e9s tan f\u00e0cil accedir a una posici\u00f3 calculada, per exemple a l'\u00faltima posici\u00f3. Ja fa falta coneixements un poc m\u00e9s avan\u00e7ats de JavaScript, per a posar dins del find() una funci\u00f3 en JavaScript, i actuar dins d'aquesta. \u00danicament de manera il\u00b7lustrativa, posem ac\u00ed la manera de traure els documents, l'\u00faltim color dels quals \u00e9s el roig. En ella ens creem una variable amb l'\u00faltim element de l'array (amb pop() ), i el comparem amb el color roig, tornant true en cas de que s\u00ed que siguen iguals: > db.colorins.find(function() { var a =this.color.pop(); return (a ==\"roig\")}) { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } Tamb\u00e9 hi ha una forma alternativa de fer-ho, que \u00e9s utilitzant l'operador $where , que ens permet crear condicions amb sintaxi JavaScript: > db.colorins.find({$where:\"this.color[this.color.length - 1]=='roig'\"}) { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } $size L'operador $size ens servir\u00e0 per a fer condicions sobre el n\u00famero d'elements d'un array. Incorporem 2 documents nous, amb 2 i 4 elements respectivament, per a poder comprovar-lo: > db.colorins.insertOne({color: [\"negre\",\"blanc\"]}) > db.colorins.insertOne({color: [\"taronja\",\"gris\",\"lila\",\"verd\"]}) > db.colorins.find() { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\", \"lila\", \"verd\" ] } Ara anem a seleccionar els documents que tenen 4 colors > db.colorins.find({color:{$size:4}}) { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\", \"lila\", \"verd\" ] } Nota L'operador $size nom\u00e9s admet un valor num\u00e8ric, i no es poden concatenar expressions amb altres operadors, com per exemple intentar la condici\u00f3 que la grand\u00e0ria de l'array siga menor o igual a un determinat valor. Es pot tornar a esquivar la q\u00fcesti\u00f3 amb l'operador $where , i posar la condici\u00f3 en JavaScript. Aix\u00ed la consulta dels documents que tenen 3 o menys colors la podr\u00edem traure d'aquesta manera: db.colorins.find({$where:\"this.color.length<=3\"}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\", \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\", \"roig\" ] } $slice L'operador $slice no \u00e9s un operador que es puga posar en les condicions (criteris), sin\u00f3 que servir\u00e0 per a extraure determinats elements de l'array, pel n\u00famero d'ordre d'aquestos elements en l'array. Nom\u00e9s el podrem posar, per tant, en el segon par\u00e0metre del find() . La sintaxi \u00e9s: clau : {$slice : x } Els valors que pot agafar x s\u00f3n: N\u00fameros positius: ser\u00e0 el n\u00famero d'elements del principi (per l'esquerra) N\u00fameros negatius: ser\u00e0 el n\u00famero d'elements del final (per la dreta) Un array de 2 elements ( [x,y] ): traur\u00e0 a partir de la posici\u00f3 x (0 \u00e9s el primer), tants elements com indique y Per exemple, anem a traure els dos primers colors de cada document: > db.colorins.find({} , {color:{$slice:2} }) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"roig\", \"blau\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"negre\", \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"taronja\", \"gris\" ] } O traure l'\u00faltim color: > db.colorins.find({} , {color:{$slice:-1 }}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ \"blanc\" ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"verd\" ] } O traure el tercer element, tinguen els que tinguen. Recordeu que el segon element, \u00e9s el de la posici\u00f3 2, i en volem traure 1. > db.colorins.find({} , {color:{$slice:[2,1] }}) { \"_id\" : ObjectId(\"56e1438ff6663c8169030e09\"), \"color\" : [ \"groc\" ] } { \"_id\" : ObjectId(\"56e14398f6663c8169030e0a\"), \"color\" : [ \"roig\" ] } { \"_id\" : ObjectId(\"56e16972aa3c92aaed389da6\"), \"color\" : [ ] } { \"_id\" : ObjectId(\"56e16990aa3c92aaed389da7\"), \"color\" : [ \"lila\" ] }","title":"Arrays"},{"location":"3__mongodb/#recerques-en-objectes","text":"Per a fer recerques en camps que a la seua vegada s\u00f3n objectes (o documents dins de documents, en la terminologia de Mongo), nom\u00e9s hem de posar la ruta de les claus separant per mig de punts, i cuidar de posar-la entre cometes. Aix\u00ed, per exemple, anem a fer una consulta sobre la col\u00b7lecci\u00f3 d'alumnes, que eren uns documents en els quals hi havia algun camp de tipus objecte. > db.alumnes.find().pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } { \"_id\" : ObjectId(\"56dfdbd136d8b095cb6bd57a\"), \"nom\" : \"Berta\", \"cognoms\" : \"Bernat Cantero\" } Es podrien traure els documents (els alumnes) que viuen en el codi postal 12502. Ens ha d'eixir l'\u00fanic alumne del qual tenim l'adre\u00e7a, que justament t\u00e9 aquest codi postal. Recordeu que en la clau (realment clau.subclau), ha d'anar entre cometes. Hem posat al final pretty() per a una millor lectura, per\u00f2 evidentment no \u00e9s necessari. > db.alumnes.find({\"adre\u00e7a.cp\": \"12502\"}).pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } I funcionaria igual amb qualsevol n\u00famero de subnivells, \u00e9s a dir, documents que tenen objectes, els quals tenen objectes, ... I tamb\u00e9 amb altres tipus d'operadors, o expressions regulars, ... Per exemple, tots els alumnes de Castell\u00f3 (el codi postal ha de comen\u00e7ar per 12 i contenir 3 xifres m\u00e9s, \u00e9s a dir, car\u00e0cter del 0 al 9, i 3 vegades. > db.alumnes.find({\"adre\u00e7a.cp\": /^12[0-9]{3}/}).pretty() { \"_id\" : ObjectId(\"56debe3017bf4ed437dc77c8\"), \"nom\" : \"Abel\", \"cognoms\" : \"Bernat Cantera\", \"edat\" : 22, \"adre\u00e7a\" : { \"carrer\" : \"Major\", \"numero\" : 7, \"cp\" : \"12502\" }, \"nota\" : [ 9.5, 9 ] } Limit, Skip i Sort Una vegada tenim feta una consulta, podem limitar el nombre de documents que ens ha de tornar, o ordenar-los. Per a aix\u00f2 hi ha uns m\u00e8todes que apliqiuem al final del find() , \u00e9s a dir, a continuaci\u00f3 del find() , separats per un punt. Ho aplicarem als llibres, que \u00e9s on tenim m\u00e9s documents. I no mostrem tots els camps, per a una millor lectura: > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } limit( n ) Limita el n\u00famero de documents tornats a n documents. > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).limit(3) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } Si el n\u00famero de documents que fa la consulta \u00e9s menor que n , doncs se'n tornaran menys. Aix\u00ed per exemple, de l'editorial Planeta nom\u00e9s hi ha dos llibres. Encara que posem limit(3), se'n tornaran 2. > db.libro.find({editorial:\"Planeta\"} , {titulo:1 , precio:1 , > editorial:1}).limit(3) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\": \"Planeta\", \"precio\" : 17.23 } skip( n ) Se saltaran els primers n documents. Si hi haguera menys documents dels que se salten, doncs no se'n mostraria cap. > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).skip(2) { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } sort() Serveix per a ordenar. Com a par\u00e0metre se li passar\u00e0 un objecte JSON amb les claus per a ordenar, i els valors seran: 1: ordre ascendent -1: ordre descendent Si posem m\u00e9s d'una clau, s'ordenar\u00e0 pel primer, en cas d'empat pel segon, ... En aquest exemple ordenem pel preu > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).sort({precio:1}) { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } I com d\u00e9iem, es pot posar m\u00e9s d'un camp d'ordenaci\u00f3. Per exemple, per editorial en ordre ascendent, i per preu en ordre descendent > db.libro.find({} , {titulo:1 , precio:1 , editorial:1}).sort({editorial:1 , precio:-1}) { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\", \"precio\" : 9.45 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\", \"precio\" : 11 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\", \"precio\" : 9.5 } { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } Observeu com el primer \u00e9s el que no t\u00e9 editorial (equivalent a null). I com que hi ha dos de l'editorial Planeta, apareix primer el m\u00e9s car, i despr\u00e9s el m\u00e9s barat. I evidentment, es poden combinar els m\u00e8todes limit, skip i sort. En aquest exemple traurem el segon i tercer llibre m\u00e9s car. Per a aix\u00f2 ordenem per preu de forma descendent, saltem un i limitem a 2. No importa l'ordre com col\u00b7locar skip, limit i sort. > db.libro.find({} , {titulo:1 , precio:1 , > editorial:1}).sort({precio:-1}).skip(1).limit(2) { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\", \"precio\" : 21.75 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\", \"precio\" : 17.23 }","title":"Recerques en objectes"},{"location":"3__mongodb/#39-agregacio","text":"L'agregaci\u00f3 ens permetr\u00e0 fer consultes molt avan\u00e7ades. \u00c9s un proc\u00e9s un poc complicat per\u00f2 molt potent. Ens donar\u00e0 una pot\u00e8ncia quasi com la del SQL quan comencem a utilitzar el GROUP BY i HAVING. La t\u00e8cnica que s'utilitza \u00e9s la del pipeline , \u00e9s a dir fer una s\u00e8rie de comandos, cadascun agafa les dades que proporciona l'anterior i a la seua vegada proporciona les dades al seg\u00fcent comando. D'aquesta manera es tractar\u00e0 un conjunt de documents i es faran \"operacions\" sobre ells seq\u00fcencialment en blocs: filtrat, projecci\u00f3, agrupacions, ordenaci\u00f3, limitaci\u00f3 i skipping (saltar alguns). La sintaxi ser\u00e0: db.col_leccio1.aggregate ( _operador $matc_ h , _operador $projec_ t , _operador $group_ , _operador $sort_ , _operador $limit_ , _operador $skip_ ) L'ordre dels operadors pot canviar, per\u00f2 hem de tenir en compte que els comandos s'executen en el ordre en qu\u00e8 els posem (d'esquerra a dreta). Aix\u00ed, per exemple, pot ser molt convenient posar el primer operador el $match, que \u00e9s el de seleccionar documents, aix\u00ed les altres operacions es faran sobre menys documents i aniran m\u00e9s r\u00e0pides. Cada par\u00e0metre del aggregate, \u00e9s a dir, cada operador tindr\u00e0 format JSON, i per tant sempre ser\u00e0 de l'estil: { $operador : { clau:valor , ... } }","title":"3.9 - Agregaci\u00f3"},{"location":"3__mongodb/#match","text":"Servir\u00e0 per a filtrar els documents. Aleshores, l'agregaci\u00f3 nom\u00e9s afectar\u00e0 als documents seleccionats. Es poden utilitzar tots els operadors que hem anat estudiant. El seg\u00fcent exemple selecciona els documents de l'editorial Planeta. Ho fa per mig de aggregate , per\u00f2 com no fem res m\u00e9s, senzillament selecciona els documents. > db.libro.aggregate({$match:{editorial:\"Planeta\"}}) En el seg\u00fcent exemple, a m\u00e9s de seleccionar els de l'editorial Planeta despr\u00e9s apliquem una projecci\u00f3 sobre els camps t\u00edtol i editorial, per a poder visualitzar millor el resultat. > db.libro.aggregate({$match:{editorial:\"Planeta\"}},{$project:{titulo:1,editorial:1}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\"} { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\": \"Planeta\" }","title":"$match"},{"location":"3__mongodb/#project","text":"Ens permet projectar sobre determinats camps del document, per\u00f2 \u00e9s molt m\u00e9s complet que en la projecci\u00f3 \"normal\" que hav\u00edem fet fins ara, ja que permet tamb\u00e9 renomenar camps, fer c\u00e0lculs, etc. Projeccci\u00f3 La manera m\u00e9s senzilla, evidentment \u00e9s projectar sobre alguns camps dels existents, i el funcionament \u00e9s id\u00e8ntic al de l'altra vegada (valors 1 per a que apareguen, 0 per a que no apareguen; per defecte _id sempre apareix): > db.libro.aggregate({$project:{titulo:1,editorial:1}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"editorial\" : \"Planeta\" } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"editorial\" : \"Plaza & Janes\" } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"editorial\" : \"Gigamesh\" } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"editorial\" : \"Debolsillo\" } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"editorial\" : \"Embolsillo\" } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"editorial\" : \"Planeta\" } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\" } Renomenar $project tamb\u00e9 ens permet renomenar camps existents (despr\u00e9s veurem que tamb\u00e9 c\u00e0lculs). La manera ser\u00e0 posar d'aquest manera: { $project : { \"nom_nou\" : \"$camp_vell\" }} El secret est\u00e0 en el d\u00f2lar que va davant del camp vell, ja que d'aquesta manera ens referim al valor d'aquest camp. Aix\u00ed per exemple renomenem el camp enstock a disponible , a banda de traure el t\u00edtol: > db.libro.aggregate({$project:{titulo:1 , disponible:\"$enstock\"}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"disponible\" : true } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"disponible\" : true } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\" disponible\" : true } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"disponible\" : false } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"disponible\" : true } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"disponible\" : false } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"disponible\" : true } Camps calculats Amb aquest nom gen\u00e8ric ens referirem a tots els c\u00e0lculs, expressions i m\u00e9s coses que podrem posar per a trasnsformar el que ja tenim. Com veiem, a\u00e7\u00f2 \u00e9s molt m\u00e9s potent que la projecci\u00f3 normal. Expressions matem\u00e0tiques : Podrem aplicar f\u00f3rmules per a sumar ( $add ), restar ( $subtract ), multiplicar ( $multiply ), dividir ( $divide ) i m\u00e9s coses (pot\u00e8ncia, arrel quadrada, valor absolut, m\u00f2dul, ...). Cada operaci\u00f3 t\u00e9 el seu operador que ser\u00e0 una paraula precedida pel d\u00f2lar, i amb la sintaxi de JSON, on posarem els operands en un array. Per exemple, traurem t\u00edtol del llibre, preu i preu en pessetes (multiplicant per 166.386) > db.libro.aggregate({$project:{titulo:1 , precio:1 , preu_pessetes:{$multiply:[\"$precio\" , 166.386]}}}) { \"_id\" : \"9788408117117\", \"titulo\" : \"Circo M\u00e1ximo\", \"precio\" : 21.75, \"preu_pessetes\" : 3618.8955 } { \"_id\" : \"9788401342158\", \"titulo\" : \"El juego de Ripper\", \"precio\" : 21.75, \"preu_pessetes\" : 3618.8955 } { \"_id\" : \"9788496208919\", \"titulo\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1\", \"precio\" : 9.5, \"preu_pessetes\" : 1580.667 } { \"_id\" : \"9788499088075\", \"titulo\" : \"La ladrona de libros\", \"precio\" : 9.45, \"preu_pessetes\" : 1572.3476999999998 } { \"_id\" : \"9788415140054\", \"titulo\" : \"La princesa de hielo\", \"precio\" : 11, \"preu_pessetes\" : 1830.2459999999999 } { \"_id\" : \"9788408113331\", \"titulo\" : \"Las carreras de Escorpio\", \"precio\" : 17.23, \"preu_pessetes\" : 2866.83078 } { \"_id\" : \"9788468738895\", \"titulo\" : \"Las reglas del juego\", \"precio\" : 15.9, \"preu_pessetes\" : 2645.5374 } Expressions de dates : Ja veurem i ja podem anar intuint que moltes agregacions estaran basades en el temps, per a poder fer consultes de documents de la setmana passada, o el mes passat, ... Per a poder fer aquestes agregacions, hi ha un conjunt d'expressions que permeten extraure f\u00e0cilment d'una data el seu dia, mes, any, ... en forma de n\u00famero S\u00f3n les expressions: $year, $month, $week, $dayOfMonth, $DayOfWeek, $dayOfYear, $hour, $minute i $second . En el seg\u00fcent exemple traurem tots els documents, projectant per la data, any i mes: > db.libro.aggregate({$project : {fecha:1 , a\u00f1o:{$year:\"$fecha\"} , mes:{$month:\"$fecha\"}}}) { \"_id\" : \"9788408117117\", \"fecha\" : ISODate(\"2013-08-29T00:00:00Z\"), \"a\u00f1o\" : 2013, \"mes\" : 8 } { \"_id\" : \"9788401342158\", \"fecha\" : ISODate(\"2014-03-01T00:00:00Z\"), \"a\u00f1o\" : 2014, \"mes\" : 3 } { \"_id\" : \"9788496208919\", \"fecha\" : ISODate(\"2011-11-24T00:00:00Z\"), \"a\u00f1o\" : 2011, \"mes\" : 11 } { \"_id\" : \"9788499088075\", \"fecha\" : ISODate(\"2009-01-09T00:00:00Z\"), \"a\u00f1o\" : 2009, \"mes\" : 1 } { \"_id\" : \"9788415140054\", \"fecha\" : ISODate(\"2012-10-30T00:00:00Z\"), \"a\u00f1o\" : 2012, \"mes\" : 10 } { \"_id\" : \"9788408113331\", \"fecha\" : ISODate(\"2013-06-04T00:00:00Z\"), \"a\u00f1o\" : 2013, \"mes\" : 6 } { \"_id\" : \"9788468738895\", \"fecha\" : ISODate(\"2014-02-06T00:00:00Z\"), \"a\u00f1o\" : 2014, \"mes\" : 2 } Expressions de strings : Ens permeten manipular els strings per a extraure subcadenes, concatenar, passar a maj\u00fascules o min\u00fascules. Aquestes s\u00f3n algunes de les funcions: $substr : [exp , inici , llarg\u00e0ria] : extrau una subcadena del string del primer par\u00e0metre, des de la posici\u00f3 que indica el segon par\u00e0metre (o primer car\u00e0cter) i tants car\u00e0cters com el tercer par\u00e0metre $concat : [ exp1 , exp2 , ...] : concatena les expressions que hi ha en l'array $toLower : exp i $toUpper : exp : converteixen l'expressi\u00f3 a maj\u00fascules i min\u00fascules respectivament Per exemple, anem a traure el t\u00edtol dels llibres amb l'autor entre par\u00e8ntesis: > db.libro.aggregate({$project: { \"Llibre:\" : {$concat : [\"$titulo\" , \" (\" , \"$autor\" , \")\"]}}}) { \"_id\" : \"9788408117117\", \"Llibre:\" : \"Circo M\u00e1ximo (Santiago Posteguillo)\" } { \"_id\" : \"9788401342158\", \"Llibre:\" : \"El juego de Ripper (Isabel Allende)\" } { \"_id\" : \"9788496208919\", \"Llibre:\" : \"Juego de tronos: Canci\u00f3n de hielo y fuego 1 (George R.R. Martin)\" } { \"_id\" : \"9788499088075\", \"Llibre:\" : \"La ladrona de libros (Markus Zusak)\" } { \"_id\" : \"9788415140054\", \"Llibre:\" : \"La princesa de hielo (Camilla Lackberg)\" } { \"_id\" : \"9788408113331\", \"Llibre:\" : \"Las carreras de Escorpio (Maggie Stiefvater)\" } { \"_id\" : \"9788468738895\", \"Llibre:\" : \"Las reglas del juego (Anna Casanovas)\"} I ara el mateix, per\u00f2 amb el t\u00edtol en maj\u00fascules: > db.libro.aggregate({$project: { \"Llibre:\" : {$concat : [{$toUpper:\"$titulo\"}, \" (\" , \"$autor\" , \")\"]}}}) { \"_id\" : \"9788408117117\", \"Llibre:\" : \"CIRCO M\u00e1XIMO (Santiago Posteguillo)\" } { \"_id\" : \"9788401342158\", \"Llibre:\" : \"EL JUEGO DE RIPPER (Isabel Allende)\" } { \"_id\" : \"9788496208919\", \"Llibre:\" : \"JUEGO DE TRONOS: CANCI\u00f3N DE HIELO Y FUEGO 1 (George R.R. Martin)\" } { \"_id\" : \"9788499088075\", \"Llibre:\" : \"LA LADRONA DE LIBROS (Markus Zusak)\" } { \"_id\" : \"9788415140054\", \"Llibre:\" : \"LA PRINCESA DE HIELO (Camilla Lackberg)\" } { \"_id\" : \"9788408113331\", \"Llibre:\" : \"LAS CARRERAS DE ESCORPIO (Maggie Stiefvater)\" } { \"_id\" : \"9788468738895\", \"Llibre:\" : \"LAS REGLAS DEL JUEGO (Anna Casanovas)\" }","title":"$project"},{"location":"3__mongodb/#group","text":"Realitza grups sobre els documents seleccionats pr\u00e8viament, per a valors iguals del camp o expressions que determinem. Posteriorment, amb els grups, podrem realitzar operacions, com sumar o traure la mitjana d'alguna quantitat dels documents del grup, o el m\u00e0xim o m\u00ednim, ... Per a poder agrupar, haurem de definir com a _id del grup el camp o camps pels valors dels quals volem agrupar. Per exemple, si volem agrupar els llibres per l'editorial, haurem de definir el _id del grup el camp editorial $group : { \"_id\" : _camp o camps_ } Si agrupem per un \u00fanic camp, senzillament el posem amb un d\u00f2lar davant i entre cometes. Si \u00e9s m\u00e9s d'un camp, els posem com un objecte. Per exemple, agrupem per editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" } } ) { \"_id\" : \"Debolsillo\" } { \"_id\" : null } { \"_id\" : \"Gigamesh\" } { \"_id\" : \"Embolsillo\" } { \"_id\" : \"Plaza & Janes\" } { \"_id\" : \"Planeta\" } Podem observar com hi ha algun llibre que no t\u00e9 editorial. Ara agrupem per any de publicaci\u00f3 (l'extraurem del camp fecha ): > db.libro.aggregate( { $group : { \"_id\" : { \"any\" : { $year : \"$fecha\" } } }} ) { \"_id\" : { \"any\" : 2012 } } { \"_id\" : { \"any\" : 2009 } } { \"_id\" : { \"any\" : 2011 } } { \"_id\" : { \"any\" : 2014 } } { \"_id\" : { \"any\" : 2013 } } I ara agrupem per editorial i any de publicaci\u00f3 (els dos llibres de Planeta s\u00f3n del 2013) > db.libro.aggregate( { $group : { \"_id\" : { \"Editorial\" : \"$editorial\" , \"any\" : { $year : \"$fecha\" } } } } ) { \"_id\" : { \"Editorial\" : \"Embolsillo\", \"any\" : 2012 } } { \"_id\" : { \"any\" : 2014 } } { \"_id\" : { \"Editorial\" : \"Debolsillo\", \"any\" : 2009 } } { \"_id\" : { \"Editorial\" : \"Gigamesh\", \"any\" : 2011 } } { \"_id\" : { \"Editorial\" : \"Plaza & Janes\", \"any\" : 2014 } } { \"_id\" : { \"Editorial\" : \"Planeta\", \"any\" : 2013 } } Operadors d'agrupaci\u00f3 Ens permetran fer alguna operaci\u00f3 sobre els documents del grup. Es posen com a segon par\u00e0metre del grup (despr\u00e9s de la definici\u00f3 del _id ). $sum : valor : sumar\u00e0 el valor de tots els documents del grup. El valor pot ser un camp num\u00e8ric, o alguna altra cosa m\u00e9s complicada. $avg : valor : calcular\u00e0 la mitjana dels valors per als documents del grup $max : valor : m\u00e0xim $min : valor : m\u00ednim $first : exp : agafar\u00e0 el primer valor de l'expressi\u00f3 del grup, ignorant les altres del grup $last : exp : agafar\u00e0 l'\u00faltim La documentaci\u00f3 diu que tamb\u00e9 existeix l'operador $count , per\u00f2 a partir d'una determinada versi\u00f3. Es pot substituir la seua utilitzaci\u00f3 per l'operador $sum , sumant la quantitat 1. Per exemple, la suma dels preus dels llibres de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"suma_preus\" : {$sum : \"$precio\"} } } ) { \"_id\" : \"Debolsillo\", \"suma_preus\" : 9.45 } { \"_id\" : null, \"suma_preus\" : 15.9 } { \"_id\" : \"Gigamesh\", \"suma_preus\" : 9.5 } { \"_id\" : \"Embolsillo\", \"suma_preus\" : 11 } { \"_id\" : \"Plaza & Janes\", \"suma_preus\" : 21.75 } { \"_id\" : \"Planeta\", \"suma_preus\" : 38.980000000000004 } O la mitjana dels preus de cada any: > db.libro.aggregate( { $group : { \"_id\" : { \"any\" : { $year : \"$fecha\" } } , \"mitjana preus\" : { $avg : \"$precio\" } } } ) { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 } { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } I ara intentem comptar la quantitat de llibres de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"quants\" : { $sum : 1} } } ) { \"_id\" : \"Debolsillo\", \"quants\" : 1 } { \"_id\" : null, \"quants\" : 1 } { \"_id\" : \"Gigamesh\", \"quants\" : 1 } { \"_id\" : \"Embolsillo\", \"quants\" : 1 } { \"_id\" : \"Plaza & Janes\", \"quants\" : 1 } { \"_id\" : \"Planeta\", \"quants\" : 2 }","title":"$group"},{"location":"3__mongodb/#sort","text":"Serveix per a ordenar i segueix la mateixa sint\u00e0xi que en les consultes normal (1: ordre ascendent; -1: ordre descendent). Podrem ordenar pels camps normals o per camps clalculats. Per exemple ordenem per la suma de preus de cada editorial: > db.libro.aggregate( { $group : { \"_id\" : \"$editorial\" , \"suma_preus\" : { $sum : \"$precio\"} } } , { $sort : { suma_preus : 1 } }) { \"_id\" : \"Debolsillo\", \"suma_preus\" : 9.45 } { \"_id\" : \"Gigamesh\", \"suma_preus\" : 9.5 } { \"_id\" : \"Embolsillo\", \"suma_preus\" : 11 } { \"_id\" : null, \"suma_preus\" : 15.9 } { \"_id\" : \"Plaza & Janes\", \"suma_preus\" : 21.75 } { \"_id\" : \"Planeta\", \"suma_preus\" : 38.980000000000004 } I ara ordenem de forma descendent per la mitjana de preus de cada any: > db.libro.aggregate( { $group : { \"_id\" : {\"any\":{$year:\"$fecha\"}} , \"mitjana preus\":{$avg:\"$precio\"} } } , {$sort:{\"mitjana preus\":-1}}) { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 } { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 }","title":"$sort"},{"location":"3__mongodb/#limit","text":"Limita el resultat del aggregate al n\u00famero indicat. Per exemple, els tres anys de mitjana de preus m\u00e9s cara. \u00c9s com l'\u00faltim exemple, afegint el l\u00edmit: > db.libro.aggregate({$group:{\"_id\":{\"any\":{$year:\"$fecha\"}},\"mitjana preus\":{$avg:\"$precio\"}}} , {$sort:{\"mitjana preus\":-1}} , {$limit:3}) { \"_id\" : { \"any\" : 2013 }, \"mitjana preus\" : 19.490000000000002 } { \"_id\" : { \"any\" : 2014 }, \"mitjana preus\" : 18.825 } { \"_id\" : { \"any\" : 2012 }, \"mitjana preus\" : 11 }","title":"$limit"},{"location":"3__mongodb/#skip","text":"Salta el n\u00famero indicat En l'exemple anterior, ara saltem els 3 primers: > db.libro.aggregate({$group:{\"_id\":{\"any\":{$year:\"$fecha\"}},\"mitjana preus\":{$avg:\"$precio\"}}} , {$sort:{\"mitjana preus\":-1}} , {$skip:3}) { \"_id\" : { \"any\" : 2011 }, \"mitjana preus\" : 9.5 } { \"_id\" : { \"any\" : 2009 }, \"mitjana preus\" : 9.45 }","title":"$skip"},{"location":"3__mongodb/#310-resum-comandos","text":"Per a qualsevol operaci\u00f3 s'ha de posar db seguit del nom de la col\u00b7lecci\u00f3, i despr\u00e9s l'operaci\u00f3 que volem fer. Operacions sobre el servidor MongoDB Connectar a MongoDB => mongo Seleccionar la base de dades => use miBaseDeDatos Mostrar totes les bases de dades en el teu servidor MongoDB => show dbs Mostrar els usuaris de la base de dades actual => show users Mostrar els rols definits en la base de dades actual => show roles Mostrar la versi\u00f3 del servidor MongoDB => db.version() Mostrar el nom de la BD del servidor MongoDB => db.getName() Mostrar les operacions que s\u2019estan executant en el servidor => db.currentOp() Mostrar informaci\u00f3 de la base de dades actual => db.stats() Operacions sobre col\u00b7leccions Mostrar totes les col\u00b7leccions en la base de dades seleccionada => show collections Crear una col\u00b7lecci\u00f3 dins de la base de dades on estiguem situats => db.createCollection(\"nom_de_la_col\u00b7lecci\u00f3\") Altres funcions sobre una col\u00b7lecci\u00f3 db.nom_de_la_col\u00b7lecci\u00f3.XXXXXXX Eliminar la col\u00b7lecci\u00f3 => drop() Formatar l\u2019eixida => pretty() Comptar de manera precisa el nombre de documents de la col\u00b7lecci\u00f3 => countDocuments() Realitzar un recompte per a una estimaci\u00f3 r\u00e0pida => estimatedDocumentCount() Operacions CRUD dins de la col\u00b7lecci\u00f3 db.nom_de_la_col\u00b7lecci\u00f3.XXXXXXX Create (crear document/s) => insertOne() , insertMany() Read (llegir, buscar document/s) => findOne() , find() , group() , sort() , limit() , skip() Update (modificar document/s) => updateOne() , updateMany() , replaceOne() Delete (eliminar document/s) => deleteOne() , deleteMany() Operacions avan\u00e7ades Pipeline o agregaci\u00f3 => aggregation()","title":"3.10 - Resum Comandos"},{"location":"3__mongodb/#exercicis","text":"","title":"Exercicis"},{"location":"3__mongodb/#exercici-2","text":"Sobre la teua Base de Dades MONGODB treballarem sobre la col\u00b7lecci\u00f3 libro , la mateixa que hem utilitzat en els exemples. Si no la tens creada, executa les sent\u00e8ncies del principi de la pregunta 3.8 - Operadors de consulta/ Operadors . Fes les seg\u00fcents consultes. Copia-les en un \u00fanic fitxer de text, de forma numerada. \u00c9s aquest fitxer el que haur\u00e0s de pujar. Busca els llibres que tenen m\u00e9s de 500 p\u00e0gines. Visualitza el _id, el t\u00edtol i el n\u00famero de p\u00e0gines. Busca els llibres de l'any 2014. Visualitza \u00fanicament t\u00edtol i data. Busca els llibres de l'editorial Planeta. Visualitza \u00fanicament t\u00edtol i editorial. Busca els llibres de l'editorial Planeta de m\u00e9s de 500 p\u00e0gines. Visualitza \u00fanicament t\u00edtol, editorial i p\u00e0gines. Busca els llibres que no tenen editorial. Visualitza \u00fanicament t\u00edtol i editorial. Busca els llibres que en el resum contenen la paraula caballo . Visualitza el resum per poder comprovar-ho. Han d'eixir 2 llibres, Circo m\u00e1ximo i Las carreras de Escorpio . Utilitzant la funci\u00f3 aggregate , trau l'editorial i la mitjana de p\u00e0gines d'aquelles editorials que tenen una mitjana de p\u00e0gines superior a 500. Eixiran 3 editorials. Incrementar el preu dels llibres de l'editorial Planeta en 2\u20ac (recordeu que per a modificar m\u00e9s d'un document, hem de posar com a tercer par\u00e0metre l'opci\u00f3 {multi:true} ). Crear el camp editorial amb el valor nul, per a tots aquells documents que no tinguen el camp editorial. Fer l'operaci\u00f3 inversa: eliminar el camp editorial per a tots aquells que el tinguen nul. Traure l'any del llibre, a partir de la fecha (ser\u00e0 un camp calculat anomenat a\u00f1o ). Aprofita el camp anterior per a traure els llibres estrictament anteriors a l'any 2013. Visualitza titulo , fecha i a\u00f1o .","title":"Exercici 2"},{"location":"3__mongodb/#exercici-3","text":"Aquest exercici l'has de realitzar sobre la teua BD de MongoDB (col\u00b7lecci\u00f3 pelicula ). title : Fight Club writer : Chuck Palahniuk year : 1999 actors : [ Brad Pitt Edward Norton ] title : Pulp Fiction writer : Quentin Tarantino year : 1994 actors : [ John Travolta Uma Thurman ] title : Inglorious Basterds writer : Quentin Tarantino year : 2009 actors : [ Brad Pitt Diane Kruger Eli Roth ] title : The Hobbit: An Unexpected Journey writer : J.R.R. Tolkein year : 2012 franchise : The Hobbit title : The Hobbit: The Desolation of Smaug writer : J.R.R. Tolkein year : 2013 franchise : The Hobbit title : The Hobbit: The Battle of the Five Armies writer : J.R.R. Tolkein year : 2012 franchise : The Hobbit synopsis : Bilbo y compa\u00f1\u00eda se ven obligados a participar en una guerra contra una serie de combatientes y evitar que la Lonely Mountain caiga en manos de una oscuridad creciente. title : Pee Wee Herman's Big Adventure title : Avatar Inserir tots els documents anteriors. Ha de ser obligat\u00f2riament amb una \u00fanica sent\u00e8ncia, per a la qual cosa pots utilitzar variables, una per a cada document. Consultar tots els documents Obtenir els documents amb writer igual a \"Quentin Tarantino\" Obtenir els documents amb actors que incloguen a \"Brad Pitt\" Obtenir els documents amb franchise igual a \"The Hobbit\" Obtenir totes les pel\u00b7l\u00edcules dels anys 90. Obtenir les pel\u00b7l\u00edcules estrenades entre l'any 2000 i el 2010. Agregar sinopsis a \"The Hobbit: An Unexpected Journey\" : \"Un hobbit reacio, Bilbo Baggins, se dirige a Lonely Mountain con un en\u00e9rgico grupo de enanos para reclamar su hogar en la monta\u00f1a, y el oro que contiene, del drag\u00f3n Smaug\". Agregar sinopsis a \"The Hobbit: The Desolation of Smaug \": \"Los enanos, junto con Bilbo Baggins y Gandalf the Grey, contin\u00faan su b\u00fasqueda para recuperar Erebor, su tierra natal, de manos de Smaug. Bilbo Baggins est\u00e1 en posesi\u00f3n de un anillo misterioso y m\u00e1gico\". Agregar un actor anomenat \"Samuel L. Jackson\" a la pel\u00b7l\u00edcula \"Pulp Fiction\" Trobar les pel\u00b7l\u00edcules que en la sinopsis continguen la paraula \"Bilbo\" Trobar les pel\u00b7l\u00edcules que en la sinopsis continguen la paraula \"Gandalf\" Trobar les pel\u00b7l\u00edcules que en la sinopsis continguen la paraula \"Bilbo\" i no la paraula \"Gandalf\" . S'aconsella utilitzar l'operador $and Trobar les pel\u00b7l\u00edcules que en la sinopsis continguen la paraula \"enanos\" o \"hobbit\" Trobar les pel\u00b7l\u00edcules que en la sinopsis continguen les paraules \"oro\" i \"drag\u00f3n\" Eliminar la pel\u00b7l\u00edcula \"Pee Wee Herman's Big Adventure\" Eliminar la pel\u00b7l\u00edcula \"Avatar\" Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercici 3"},{"location":"4_relaciones_mongo/","text":"Implementaci\u00f3n de Relaciones en MongoDB MongoDB, al ser una base de datos NoSQL , no maneja relaciones de la misma manera que SQL . Sin embargo, permite representar relaciones entre documentos utilizando dos enfoques principales: 1\ufe0f\u20e3 Relaciones mediante documentos embebidos. 2\ufe0f\u20e3 Relaciones mediante referencias. Cada enfoque tiene ventajas y desventajas, seg\u00fan el caso de uso. 4.1. Relaci\u00f3n con Documentos Embebidos Este enfoque anida los datos relacionados dentro del mismo documento . Se usa cuando los datos relacionados se consultan frecuentemente juntos y no crecen demasiado en tama\u00f1o. Ejemplo : Cliente con sus Pedidos embebidos { \"_id\": 1, \"nombre\": \"Juan\", \"email\": \"juan@email.com\", \"pedidos\": [ { \"producto\": \"Laptop\", \"total\": 1200 }, { \"producto\": \"Mouse\", \"total\": 25 } ] } \u2705 Ventajas \u2714 R\u00e1pida recuperaci\u00f3n de datos (no requiere JOINs ). \u2714 Menos consultas a la base de datos. \u2714 Buena opci\u00f3n si los datos no crecen demasiado. \u274c Desventajas \u2716 Si los pedidos crecen mucho, el documento se hace muy grande. \u2716 No se pueden actualizar pedidos de forma independiente sin modificar el cliente. 4.2. Relaci\u00f3n con Referencias En este enfoque, los documentos almacenan solo referencias (IDs) de documentos en otras colecciones . Se usa cuando los datos son reutilizados en m\u00faltiples documentos o crecen mucho en tama\u00f1o. Estas referencias pueden ser de dos tipos; referencias manuales o por DBRefs. Ejemplo : Cliente y Pedidos en colecciones separadas con referencia Colecci\u00f3n clientes { \"_id\": 1, \"nombre\": \"Juan\", \"email\": \"juan@email.com\", \"pedidos\": [101, 102] // Referencias a pedidos } Colecci\u00f3n pedidos [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"total\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"total\": 25 } ] \u2705 Ventajas \u2714 Evita documentos muy grandes. \u2714 Permite reutilizar datos sin duplicarlos. \u2714 Se pueden actualizar las referencias sin modificar el documento original. \u274c Desventajas \u2716 Se necesitan consultas adicionales ( $lookup ) para traer los datos completos. \u2716 Puede ser m\u00e1s lento en consultas frecuentes. \"Regla general Si los datos relacionados son de uso frecuente y peque\u00f1os \u2192 Usa documentos embebidos. Si los datos crecen mucho o se usan en varias colecciones \u2192 Usa referencias con $lookup . 4.3. Relaciones en MongoDB con $lookup En MongoDB , la agregaci\u00f3n con $lookup permite realizar joins entre colecciones. Es \u00fatil cuando seguimos un enfoque de modelado de datos con referencias , donde almacenamos solo el ObjectId en lugar de los documentos embebidos. Sintaxis { $lookup: { from: <collection_to_join>, localField: <field_from_the_input_documents>, foreignField: <field_from_collection>, as: <output_array_field> } } Ejemplo 1 : Relacionar la coleci\u00f3n Usuarios con sus Pedidos Colecci\u00f3n usuarios [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\" }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\" } ] Colecci\u00f3n pedidos [ { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 }, { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] Consulta con $lookup para unir usuarios con sus pedidos db.usuarios.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", // Colecci\u00f3n a unir \"localField\": \"_id\", // Campo en la colecci\u00f3n actual (usuarios) \"foreignField\": \"usuario_id\", // Campo en la otra colecci\u00f3n (pedidos) \"as\": \"pedidos\" // Nombre del campo de salida con los pedidos } } ]) Resultado esperado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\", \"pedidos\": [ { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\", \"pedidos\": [ { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] } ] Ejemplo 2 : Realcionar la colecci\u00f3n autores con sus libros. db.createCollection(\"authors\"); db.createCollection(\"books\"); // Primera instrucci\u00f3n db.authors.insertOne({ name: \"Diego\", email: \"dcortes@example.com\", age: 25 }); // Segunda instrucci\u00f3n (Se debe obtener el ID del autor y remplazar) db.books.insertMany([ { name: \"Philosopher's Stone\", author_id: ObjectId(\"id_of_author\") }, { name: \"Secret of programming\", author_id: ObjectId(\"id_of_author\") } ]); db.getCollection(\"authors\").aggregate([{ $lookup: { from: \"books\", localField: \"_id\", foreignField: \"author_id\", as: \"books\" } }]); Resultado esperado { \"_id\" : ObjectId(\"64a8397a001cd56690c6a9cd\"), \"name\" : \"Diego\", \"email\" : \"dcortes@example.com\", \"age\" : NumberInt(25), \"books\" : [ { \"_id\" : ObjectId(\"64a839a7001cd56690c6a9ce\"), \"name\" : \"Philosopher's Stone\", \"author_id\" : ObjectId(\"64a8397a001cd56690c6a9cd\") }, { \"_id\" : ObjectId(\"64a839a7001cd56690c6a9cf\"), \"name\" : \"Secret of programming\", \"author_id\" : ObjectId(\"64a8397a001cd56690c6a9cd\") } ] } $lookup anidado Siguiendo con el ejemplo de usuarios y sus pedidos, si cada pedido tiene detalles en una tercera colecci\u00f3n detalles_pedido , podemos anidar otro $lookup: Ejemplo : Relacionar Usuarios con Pedidos y detalles_pedido Colecci\u00f3n usuarios [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\" }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\" } ] Colecci\u00f3n pedidos [ { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 }, { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] Colecci\u00f3n detalles_pedido [ { \"_id\": 201, \"pedido_id\": 101, \"cantidad\": 1, \"garantia\": \"2 a\u00f1os\" }, { \"_id\": 202, \"pedido_id\": 102, \"cantidad\": 2, \"garantia\": \"1 a\u00f1o\" }, { \"_id\": 203, \"pedido_id\": 103, \"cantidad\": 1, \"garantia\": \"3 a\u00f1os\" } ] Consulta con $lookup anidado La idea es obtener una lista de usuarios con sus pedidos, y dentro de cada pedido, los detalles de ese pedido. db.usuarios.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"usuario_id\", \"as\": \"pedidos\" } }, { \"$unwind\": \"$pedidos\" // Descompone el array de pedidos }, { \"$lookup\": { \"from\": \"detalles_pedido\", \"localField\": \"pedidos._id\", \"foreignField\": \"pedido_id\", \"as\": \"pedidos.detalles\" } }, { \"$group\": { \"_id\": \"$_id\", \"nombre\": { \"$first\": \"$nombre\" }, \"email\": { \"$first\": \"$email\" }, \"pedidos\": { \"$push\": \"$pedidos\" } } } ]) Resultado esperado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\", \"pedidos\": [ { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200, \"detalles\": [ { \"_id\": 201, \"pedido_id\": 101, \"cantidad\": 1, \"garantia\": \"2 a\u00f1os\" } ] }, { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50, \"detalles\": [ { \"_id\": 202, \"pedido_id\": 102, \"cantidad\": 2, \"garantia\": \"1 a\u00f1o\" } ] } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\", \"pedidos\": [ { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80, \"detalles\": [ { \"_id\": 203, \"pedido_id\": 103, \"cantidad\": 1, \"garantia\": \"3 a\u00f1os\" } ] } ] } ] \ud83c\udfaf Explicaci\u00f3n del Pipeline $lookup (usuarios \u2192 pedidos): Une los pedidos a cada usuario. $unwind (pedidos): Descompone la lista de pedidos para poder hacer otro $lookup. $lookup (pedidos \u2192 detalles_pedido): Une los detalles a cada pedido. $group: Vuelve a agrupar los datos para reconstruir la estructura. El operador $unwind El operador $unwind en MongoDB descompone un array dentro de un documento en m\u00faltiples documentos, cada uno con un solo elemento del array. Es especialmente \u00fatil cuando trabajamos con $lookup , porque las consultas de agregaci\u00f3n en MongoDB manejan arrays, y a veces es necesario convertirlos en documentos individuales para hacer m\u00e1s joins o transformaciones. \u00bfCu\u00e1ndo se usa $unwind? \u2714 Cuando necesitas descomponer arrays en documentos individuales. \u2714 Para hacer joins en m\u00faltiples niveles (como unir detalles_pedido a cada pedido). \u2714 Para hacer c\u00e1lculos en elementos individuales de un array, como contar cu\u00e1ntos productos ha comprado un usuario. Ejemplo sin $unwind db.usuarios.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"usuario_id\", \"as\": \"pedidos\" } } ]) Resultado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": [ { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"pedidos\": [ { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] } ] Cada usuario tiene un array con sus pedidos, pero si queremos hacer un segundo $lookup (por ejemplo, para unir detalles de los pedidos), MongoDB no puede unir arrays directamente. Ejemplo con $unwind db.usuarios.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"usuario_id\", \"as\": \"pedidos\" } }, { \"$unwind\": \"$pedidos\" } ]) Resultado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 } }, { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } }, { \"_id\": 2, \"nombre\": \"Ana\", \"pedidos\": { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } } ] Ahora, cada usuario tiene m\u00faltiples documentos, uno por cada pedido, lo que permite realizar otro $lookup con detalles_pedido. Exercici 4 Intenta implementar en MongoDB part de la Base de Dades relacional factures , concretament, comen\u00e7a per les taules CATEGORIA i ARTICLE, que les haur\u00e0s de representar com a documents de 2 col\u00b7leccions (col\u00b7lecci\u00f3 categoria i col\u00b7lecci\u00f3 articulo ). En els documents de la col\u00b7lecci\u00f3 categoria , el codi de categoria ser\u00e0 el _id , mentre que en els documents de la col\u00b7lecci\u00f3 articulo , el codi de l'article ser\u00e0 el _id . Insereix els documents corresponents a les categories de l'exercici Ex_1 ( factures ). Insereix els documents corresponents als articles de l'exercici Ex_2 ( factures ). Fes una consulta en qu\u00e8 apareguen tots els articles amb la seua descripci\u00f3 i tamb\u00e9 la descripci\u00f3 de la seua categoria. Modifica l'anterior per a que apareguen nom\u00e9s les descripcions de l'article i de la categoria. Com que les dades del document reunit, que en aquest cas \u00e9s categoria, podem utilitzar $unwind per a \"desconstruir\" aquest array. Una vegada desconstru\u00eft l'array \u00e9s quan podrem projectar sobre la descripci\u00f3 de l'article (directament) i sobre la descripci\u00f3 de la categoria reanomenant el camp i subcamp. Fes una consulta on aparega la descripci\u00f3 de cada categoria, amb el n\u00famero d'articles de cada categoria i el preu mitj\u00e0. Insereix els documents corresponents als clients de l'exercici Ex_3 ( factures ). No ens importar\u00e0 el codi de poblaci\u00f3. Insereix les factures corresponents als exercicis Ex_4 ( factures ) i Ex_5 ( factures ). Observa que la millor manera d'introduir les l\u00ednies de factura \u00e9s dins de la mateixa factura, en un array. Fes una consulta per a traure el n\u00famero de factura i el seu total. Modifica l'anterior per a traure tamb\u00e9 el nom del client de la factura Trau un llistat de clients, com a m\u00ednim amb el seu nom, i dels articles que ha comprat, com a m\u00ednim amb la descripci\u00f3 de l'article Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"4 - Relacions en MongoDB"},{"location":"4_relaciones_mongo/#implementacion-de-relaciones-en-mongodb","text":"MongoDB, al ser una base de datos NoSQL , no maneja relaciones de la misma manera que SQL . Sin embargo, permite representar relaciones entre documentos utilizando dos enfoques principales: 1\ufe0f\u20e3 Relaciones mediante documentos embebidos. 2\ufe0f\u20e3 Relaciones mediante referencias. Cada enfoque tiene ventajas y desventajas, seg\u00fan el caso de uso.","title":"Implementaci\u00f3n de Relaciones en MongoDB"},{"location":"4_relaciones_mongo/#41-relacion-con-documentos-embebidos","text":"Este enfoque anida los datos relacionados dentro del mismo documento . Se usa cuando los datos relacionados se consultan frecuentemente juntos y no crecen demasiado en tama\u00f1o. Ejemplo : Cliente con sus Pedidos embebidos { \"_id\": 1, \"nombre\": \"Juan\", \"email\": \"juan@email.com\", \"pedidos\": [ { \"producto\": \"Laptop\", \"total\": 1200 }, { \"producto\": \"Mouse\", \"total\": 25 } ] } \u2705 Ventajas \u2714 R\u00e1pida recuperaci\u00f3n de datos (no requiere JOINs ). \u2714 Menos consultas a la base de datos. \u2714 Buena opci\u00f3n si los datos no crecen demasiado. \u274c Desventajas \u2716 Si los pedidos crecen mucho, el documento se hace muy grande. \u2716 No se pueden actualizar pedidos de forma independiente sin modificar el cliente.","title":"4.1. Relaci\u00f3n con Documentos Embebidos"},{"location":"4_relaciones_mongo/#42-relacion-con-referencias","text":"En este enfoque, los documentos almacenan solo referencias (IDs) de documentos en otras colecciones . Se usa cuando los datos son reutilizados en m\u00faltiples documentos o crecen mucho en tama\u00f1o. Estas referencias pueden ser de dos tipos; referencias manuales o por DBRefs. Ejemplo : Cliente y Pedidos en colecciones separadas con referencia Colecci\u00f3n clientes { \"_id\": 1, \"nombre\": \"Juan\", \"email\": \"juan@email.com\", \"pedidos\": [101, 102] // Referencias a pedidos } Colecci\u00f3n pedidos [ { \"_id\": 101, \"cliente_id\": 1, \"producto\": \"Laptop\", \"total\": 1200 }, { \"_id\": 102, \"cliente_id\": 1, \"producto\": \"Mouse\", \"total\": 25 } ] \u2705 Ventajas \u2714 Evita documentos muy grandes. \u2714 Permite reutilizar datos sin duplicarlos. \u2714 Se pueden actualizar las referencias sin modificar el documento original. \u274c Desventajas \u2716 Se necesitan consultas adicionales ( $lookup ) para traer los datos completos. \u2716 Puede ser m\u00e1s lento en consultas frecuentes. \"Regla general Si los datos relacionados son de uso frecuente y peque\u00f1os \u2192 Usa documentos embebidos. Si los datos crecen mucho o se usan en varias colecciones \u2192 Usa referencias con $lookup .","title":"4.2. Relaci\u00f3n con Referencias"},{"location":"4_relaciones_mongo/#43-relaciones-en-mongodb-con-lookup","text":"En MongoDB , la agregaci\u00f3n con $lookup permite realizar joins entre colecciones. Es \u00fatil cuando seguimos un enfoque de modelado de datos con referencias , donde almacenamos solo el ObjectId en lugar de los documentos embebidos. Sintaxis { $lookup: { from: <collection_to_join>, localField: <field_from_the_input_documents>, foreignField: <field_from_collection>, as: <output_array_field> } } Ejemplo 1 : Relacionar la coleci\u00f3n Usuarios con sus Pedidos Colecci\u00f3n usuarios [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\" }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\" } ] Colecci\u00f3n pedidos [ { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 }, { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] Consulta con $lookup para unir usuarios con sus pedidos db.usuarios.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", // Colecci\u00f3n a unir \"localField\": \"_id\", // Campo en la colecci\u00f3n actual (usuarios) \"foreignField\": \"usuario_id\", // Campo en la otra colecci\u00f3n (pedidos) \"as\": \"pedidos\" // Nombre del campo de salida con los pedidos } } ]) Resultado esperado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\", \"pedidos\": [ { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\", \"pedidos\": [ { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] } ] Ejemplo 2 : Realcionar la colecci\u00f3n autores con sus libros. db.createCollection(\"authors\"); db.createCollection(\"books\"); // Primera instrucci\u00f3n db.authors.insertOne({ name: \"Diego\", email: \"dcortes@example.com\", age: 25 }); // Segunda instrucci\u00f3n (Se debe obtener el ID del autor y remplazar) db.books.insertMany([ { name: \"Philosopher's Stone\", author_id: ObjectId(\"id_of_author\") }, { name: \"Secret of programming\", author_id: ObjectId(\"id_of_author\") } ]); db.getCollection(\"authors\").aggregate([{ $lookup: { from: \"books\", localField: \"_id\", foreignField: \"author_id\", as: \"books\" } }]); Resultado esperado { \"_id\" : ObjectId(\"64a8397a001cd56690c6a9cd\"), \"name\" : \"Diego\", \"email\" : \"dcortes@example.com\", \"age\" : NumberInt(25), \"books\" : [ { \"_id\" : ObjectId(\"64a839a7001cd56690c6a9ce\"), \"name\" : \"Philosopher's Stone\", \"author_id\" : ObjectId(\"64a8397a001cd56690c6a9cd\") }, { \"_id\" : ObjectId(\"64a839a7001cd56690c6a9cf\"), \"name\" : \"Secret of programming\", \"author_id\" : ObjectId(\"64a8397a001cd56690c6a9cd\") } ] }","title":"4.3. Relaciones en MongoDB con $lookup"},{"location":"4_relaciones_mongo/#lookup-anidado","text":"Siguiendo con el ejemplo de usuarios y sus pedidos, si cada pedido tiene detalles en una tercera colecci\u00f3n detalles_pedido , podemos anidar otro $lookup: Ejemplo : Relacionar Usuarios con Pedidos y detalles_pedido Colecci\u00f3n usuarios [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\" }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\" } ] Colecci\u00f3n pedidos [ { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 }, { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] Colecci\u00f3n detalles_pedido [ { \"_id\": 201, \"pedido_id\": 101, \"cantidad\": 1, \"garantia\": \"2 a\u00f1os\" }, { \"_id\": 202, \"pedido_id\": 102, \"cantidad\": 2, \"garantia\": \"1 a\u00f1o\" }, { \"_id\": 203, \"pedido_id\": 103, \"cantidad\": 1, \"garantia\": \"3 a\u00f1os\" } ] Consulta con $lookup anidado La idea es obtener una lista de usuarios con sus pedidos, y dentro de cada pedido, los detalles de ese pedido. db.usuarios.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"usuario_id\", \"as\": \"pedidos\" } }, { \"$unwind\": \"$pedidos\" // Descompone el array de pedidos }, { \"$lookup\": { \"from\": \"detalles_pedido\", \"localField\": \"pedidos._id\", \"foreignField\": \"pedido_id\", \"as\": \"pedidos.detalles\" } }, { \"$group\": { \"_id\": \"$_id\", \"nombre\": { \"$first\": \"$nombre\" }, \"email\": { \"$first\": \"$email\" }, \"pedidos\": { \"$push\": \"$pedidos\" } } } ]) Resultado esperado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"email\": \"carlos@example.com\", \"pedidos\": [ { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200, \"detalles\": [ { \"_id\": 201, \"pedido_id\": 101, \"cantidad\": 1, \"garantia\": \"2 a\u00f1os\" } ] }, { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50, \"detalles\": [ { \"_id\": 202, \"pedido_id\": 102, \"cantidad\": 2, \"garantia\": \"1 a\u00f1o\" } ] } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"email\": \"ana@example.com\", \"pedidos\": [ { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80, \"detalles\": [ { \"_id\": 203, \"pedido_id\": 103, \"cantidad\": 1, \"garantia\": \"3 a\u00f1os\" } ] } ] } ] \ud83c\udfaf Explicaci\u00f3n del Pipeline $lookup (usuarios \u2192 pedidos): Une los pedidos a cada usuario. $unwind (pedidos): Descompone la lista de pedidos para poder hacer otro $lookup. $lookup (pedidos \u2192 detalles_pedido): Une los detalles a cada pedido. $group: Vuelve a agrupar los datos para reconstruir la estructura.","title":"$lookup anidado"},{"location":"4_relaciones_mongo/#el-operador-unwind","text":"El operador $unwind en MongoDB descompone un array dentro de un documento en m\u00faltiples documentos, cada uno con un solo elemento del array. Es especialmente \u00fatil cuando trabajamos con $lookup , porque las consultas de agregaci\u00f3n en MongoDB manejan arrays, y a veces es necesario convertirlos en documentos individuales para hacer m\u00e1s joins o transformaciones. \u00bfCu\u00e1ndo se usa $unwind? \u2714 Cuando necesitas descomponer arrays en documentos individuales. \u2714 Para hacer joins en m\u00faltiples niveles (como unir detalles_pedido a cada pedido). \u2714 Para hacer c\u00e1lculos en elementos individuales de un array, como contar cu\u00e1ntos productos ha comprado un usuario. Ejemplo sin $unwind db.usuarios.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"usuario_id\", \"as\": \"pedidos\" } } ]) Resultado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": [ { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 }, { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } ] }, { \"_id\": 2, \"nombre\": \"Ana\", \"pedidos\": [ { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } ] } ] Cada usuario tiene un array con sus pedidos, pero si queremos hacer un segundo $lookup (por ejemplo, para unir detalles de los pedidos), MongoDB no puede unir arrays directamente. Ejemplo con $unwind db.usuarios.aggregate([ { \"$lookup\": { \"from\": \"pedidos\", \"localField\": \"_id\", \"foreignField\": \"usuario_id\", \"as\": \"pedidos\" } }, { \"$unwind\": \"$pedidos\" } ]) Resultado [ { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": { \"_id\": 101, \"usuario_id\": 1, \"producto\": \"Laptop\", \"precio\": 1200 } }, { \"_id\": 1, \"nombre\": \"Carlos\", \"pedidos\": { \"_id\": 102, \"usuario_id\": 1, \"producto\": \"Mouse\", \"precio\": 50 } }, { \"_id\": 2, \"nombre\": \"Ana\", \"pedidos\": { \"_id\": 103, \"usuario_id\": 2, \"producto\": \"Teclado\", \"precio\": 80 } } ] Ahora, cada usuario tiene m\u00faltiples documentos, uno por cada pedido, lo que permite realizar otro $lookup con detalles_pedido.","title":"El operador $unwind"},{"location":"4_relaciones_mongo/#exercici-4","text":"Intenta implementar en MongoDB part de la Base de Dades relacional factures , concretament, comen\u00e7a per les taules CATEGORIA i ARTICLE, que les haur\u00e0s de representar com a documents de 2 col\u00b7leccions (col\u00b7lecci\u00f3 categoria i col\u00b7lecci\u00f3 articulo ). En els documents de la col\u00b7lecci\u00f3 categoria , el codi de categoria ser\u00e0 el _id , mentre que en els documents de la col\u00b7lecci\u00f3 articulo , el codi de l'article ser\u00e0 el _id . Insereix els documents corresponents a les categories de l'exercici Ex_1 ( factures ). Insereix els documents corresponents als articles de l'exercici Ex_2 ( factures ). Fes una consulta en qu\u00e8 apareguen tots els articles amb la seua descripci\u00f3 i tamb\u00e9 la descripci\u00f3 de la seua categoria. Modifica l'anterior per a que apareguen nom\u00e9s les descripcions de l'article i de la categoria. Com que les dades del document reunit, que en aquest cas \u00e9s categoria, podem utilitzar $unwind per a \"desconstruir\" aquest array. Una vegada desconstru\u00eft l'array \u00e9s quan podrem projectar sobre la descripci\u00f3 de l'article (directament) i sobre la descripci\u00f3 de la categoria reanomenant el camp i subcamp. Fes una consulta on aparega la descripci\u00f3 de cada categoria, amb el n\u00famero d'articles de cada categoria i el preu mitj\u00e0. Insereix els documents corresponents als clients de l'exercici Ex_3 ( factures ). No ens importar\u00e0 el codi de poblaci\u00f3. Insereix les factures corresponents als exercicis Ex_4 ( factures ) i Ex_5 ( factures ). Observa que la millor manera d'introduir les l\u00ednies de factura \u00e9s dins de la mateixa factura, en un array. Fes una consulta per a traure el n\u00famero de factura i el seu total. Modifica l'anterior per a traure tamb\u00e9 el nom del client de la factura Trau un llistat de clients, com a m\u00ednim amb el seu nom, i dels articles que ha comprat, com a m\u00ednim amb la descripci\u00f3 de l'article Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercici 4"},{"location":"5_actividad_mongo/","text":"Pr\u00e1ctica Mongo 1\ufe0f\u20e3 Dise\u00f1o de la base de datos MongoDB: Dise\u00f1a una base de datos MongoDB que sea adecuada para un escenario de tu elecci\u00f3n. Describe la estructura de la base de datos, incluyendo las colecciones y los documentos que la componen (al menos 3 colecciones relacionadas). Incorpora una imagen ilustrando la BD. 2\ufe0f\u20e3 Creaci\u00f3n y poblaci\u00f3n de la base de datos MongoDB: Crea la base de datos y las colecciones necesarias en MongoDB, utilizando los comandos adecuados. Inserta datos en la base de datos, asegur\u00e1ndose de que los documentos cumplan con la estructura definida en el dise\u00f1o. 3\ufe0f\u20e3 Operaciones CRUD en MongoDB: Muestra y realiza ejemplos concretos de c\u00f3mo realizar operaciones de inserci\u00f3n, consulta, actualizaci\u00f3n y eliminaci\u00f3n de documentos en la base de datos. 4\ufe0f\u20e3 Consultas y filtros en MongoDB: Realiza consultas en la base de datos MongoDB para obtener informaci\u00f3n mediante el uso de la funci\u00f3n aggregate. Realiza consultas en la base de datos MongoDB para obtener informaci\u00f3n que combine varias colecciones (uso de $lookup y $unwind). 5\ufe0f\u20e3 Gesti\u00f3n de \u00edndices en MongoDB: Investiga sobre la importancia de los \u00edndices en MongoDB y c\u00f3mo pueden mejorar el rendimiento de las consultas. Crea y gestiona \u00edndices en la base de datos MongoDB, utilizando los comandos adecuados. 6\ufe0f\u20e3 Entrega Deber\u00e1s entregar un documento en formato digital que funcionar\u00e1 como tutorial. Puedes utilizar cualquier recurso educativo abierto, incluso puedes utilizar varios, por ejemplo pdf, infograf\u00eda, presentaci\u00f3n, ebook, mapa mental, mural digital, v\u00eddeo, etc. Cada apartado contendr\u00e1 una explicaci\u00f3n de lo que se pide y vendr\u00e1 acompa\u00f1ado de capturas de pantalla o el c\u00f3digo que has utilizado para su consecuci\u00f3n.","title":"Pr\u00e1ctica Mongo"},{"location":"5_actividad_mongo/#practica-mongo","text":"1\ufe0f\u20e3 Dise\u00f1o de la base de datos MongoDB: Dise\u00f1a una base de datos MongoDB que sea adecuada para un escenario de tu elecci\u00f3n. Describe la estructura de la base de datos, incluyendo las colecciones y los documentos que la componen (al menos 3 colecciones relacionadas). Incorpora una imagen ilustrando la BD. 2\ufe0f\u20e3 Creaci\u00f3n y poblaci\u00f3n de la base de datos MongoDB: Crea la base de datos y las colecciones necesarias en MongoDB, utilizando los comandos adecuados. Inserta datos en la base de datos, asegur\u00e1ndose de que los documentos cumplan con la estructura definida en el dise\u00f1o. 3\ufe0f\u20e3 Operaciones CRUD en MongoDB: Muestra y realiza ejemplos concretos de c\u00f3mo realizar operaciones de inserci\u00f3n, consulta, actualizaci\u00f3n y eliminaci\u00f3n de documentos en la base de datos. 4\ufe0f\u20e3 Consultas y filtros en MongoDB: Realiza consultas en la base de datos MongoDB para obtener informaci\u00f3n mediante el uso de la funci\u00f3n aggregate. Realiza consultas en la base de datos MongoDB para obtener informaci\u00f3n que combine varias colecciones (uso de $lookup y $unwind). 5\ufe0f\u20e3 Gesti\u00f3n de \u00edndices en MongoDB: Investiga sobre la importancia de los \u00edndices en MongoDB y c\u00f3mo pueden mejorar el rendimiento de las consultas. Crea y gestiona \u00edndices en la base de datos MongoDB, utilizando los comandos adecuados. 6\ufe0f\u20e3 Entrega Deber\u00e1s entregar un documento en formato digital que funcionar\u00e1 como tutorial. Puedes utilizar cualquier recurso educativo abierto, incluso puedes utilizar varios, por ejemplo pdf, infograf\u00eda, presentaci\u00f3n, ebook, mapa mental, mural digital, v\u00eddeo, etc. Cada apartado contendr\u00e1 una explicaci\u00f3n de lo que se pide y vendr\u00e1 acompa\u00f1ado de capturas de pantalla o el c\u00f3digo que has utilizado para su consecuci\u00f3n.","title":"Pr\u00e1ctica Mongo"},{"location":"exercicis_mongo/","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercicis mongo"},{"location":"exercicis_redis/","text":"Exercicis Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"\u270f\ufe0f Exercicis"},{"location":"exercicis_redis/#exercicis","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 4.0","title":"Exercicis"}]}